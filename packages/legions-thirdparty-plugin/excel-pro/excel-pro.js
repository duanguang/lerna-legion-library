/**
 * legions-thirdparty-plugin v0.0.8
 * (c) 2021 duanguang
 * @license MIT
 */
var legionsThirdpartyExcelPlugin = (function (exports, crypto$1, fs, events, buffer, util, stream, string_decoder$1) {
	'use strict';

	function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

	var crypto__default = /*#__PURE__*/_interopDefaultLegacy(crypto$1);
	var fs__default = /*#__PURE__*/_interopDefaultLegacy(fs);
	var events__default = /*#__PURE__*/_interopDefaultLegacy(events);
	var buffer__default = /*#__PURE__*/_interopDefaultLegacy(buffer);
	var util__default = /*#__PURE__*/_interopDefaultLegacy(util);
	var stream__default = /*#__PURE__*/_interopDefaultLegacy(stream);
	var string_decoder__default = /*#__PURE__*/_interopDefaultLegacy(string_decoder$1);

	var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function commonjsRequire () {
		throw new Error('Dynamic requires are not currently supported by rollup-plugin-commonjs');
	}

	function unwrapExports (x) {
		return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
	}

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	var check = function (it) {
	  return it && it.Math == Math && it;
	};

	// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
	var global_1 =
	  // eslint-disable-next-line no-undef
	  check(typeof globalThis == 'object' && globalThis) ||
	  check(typeof window == 'object' && window) ||
	  check(typeof self == 'object' && self) ||
	  check(typeof commonjsGlobal == 'object' && commonjsGlobal) ||
	  // eslint-disable-next-line no-new-func
	  Function('return this')();

	var fails = function (exec) {
	  try {
	    return !!exec();
	  } catch (error) {
	    return true;
	  }
	};

	// Thank's IE8 for his funny defineProperty
	var descriptors = !fails(function () {
	  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] != 7;
	});

	var nativePropertyIsEnumerable = {}.propertyIsEnumerable;
	var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

	// Nashorn ~ JDK8 bug
	var NASHORN_BUG = getOwnPropertyDescriptor && !nativePropertyIsEnumerable.call({ 1: 2 }, 1);

	// `Object.prototype.propertyIsEnumerable` method implementation
	// https://tc39.github.io/ecma262/#sec-object.prototype.propertyisenumerable
	var f = NASHORN_BUG ? function propertyIsEnumerable(V) {
	  var descriptor = getOwnPropertyDescriptor(this, V);
	  return !!descriptor && descriptor.enumerable;
	} : nativePropertyIsEnumerable;

	var objectPropertyIsEnumerable = {
		f: f
	};

	var createPropertyDescriptor = function (bitmap, value) {
	  return {
	    enumerable: !(bitmap & 1),
	    configurable: !(bitmap & 2),
	    writable: !(bitmap & 4),
	    value: value
	  };
	};

	var toString = {}.toString;

	var classofRaw = function (it) {
	  return toString.call(it).slice(8, -1);
	};

	var split = ''.split;

	// fallback for non-array-like ES3 and non-enumerable old V8 strings
	var indexedObject = fails(function () {
	  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
	  // eslint-disable-next-line no-prototype-builtins
	  return !Object('z').propertyIsEnumerable(0);
	}) ? function (it) {
	  return classofRaw(it) == 'String' ? split.call(it, '') : Object(it);
	} : Object;

	// `RequireObjectCoercible` abstract operation
	// https://tc39.github.io/ecma262/#sec-requireobjectcoercible
	var requireObjectCoercible = function (it) {
	  if (it == undefined) throw TypeError("Can't call method on " + it);
	  return it;
	};

	// toObject with fallback for non-array-like ES3 strings



	var toIndexedObject = function (it) {
	  return indexedObject(requireObjectCoercible(it));
	};

	var isObject = function (it) {
	  return typeof it === 'object' ? it !== null : typeof it === 'function';
	};

	// `ToPrimitive` abstract operation
	// https://tc39.github.io/ecma262/#sec-toprimitive
	// instead of the ES6 spec version, we didn't implement @@toPrimitive case
	// and the second argument - flag - preferred type is a string
	var toPrimitive = function (input, PREFERRED_STRING) {
	  if (!isObject(input)) return input;
	  var fn, val;
	  if (PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;
	  if (typeof (fn = input.valueOf) == 'function' && !isObject(val = fn.call(input))) return val;
	  if (!PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;
	  throw TypeError("Can't convert object to primitive value");
	};

	var hasOwnProperty = {}.hasOwnProperty;

	var has = function (it, key) {
	  return hasOwnProperty.call(it, key);
	};

	var document$1 = global_1.document;
	// typeof document.createElement is 'object' in old IE
	var EXISTS = isObject(document$1) && isObject(document$1.createElement);

	var documentCreateElement = function (it) {
	  return EXISTS ? document$1.createElement(it) : {};
	};

	// Thank's IE8 for his funny defineProperty
	var ie8DomDefine = !descriptors && !fails(function () {
	  return Object.defineProperty(documentCreateElement('div'), 'a', {
	    get: function () { return 7; }
	  }).a != 7;
	});

	var nativeGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

	// `Object.getOwnPropertyDescriptor` method
	// https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptor
	var f$1 = descriptors ? nativeGetOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
	  O = toIndexedObject(O);
	  P = toPrimitive(P, true);
	  if (ie8DomDefine) try {
	    return nativeGetOwnPropertyDescriptor(O, P);
	  } catch (error) { /* empty */ }
	  if (has(O, P)) return createPropertyDescriptor(!objectPropertyIsEnumerable.f.call(O, P), O[P]);
	};

	var objectGetOwnPropertyDescriptor = {
		f: f$1
	};

	var anObject = function (it) {
	  if (!isObject(it)) {
	    throw TypeError(String(it) + ' is not an object');
	  } return it;
	};

	var nativeDefineProperty = Object.defineProperty;

	// `Object.defineProperty` method
	// https://tc39.github.io/ecma262/#sec-object.defineproperty
	var f$2 = descriptors ? nativeDefineProperty : function defineProperty(O, P, Attributes) {
	  anObject(O);
	  P = toPrimitive(P, true);
	  anObject(Attributes);
	  if (ie8DomDefine) try {
	    return nativeDefineProperty(O, P, Attributes);
	  } catch (error) { /* empty */ }
	  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported');
	  if ('value' in Attributes) O[P] = Attributes.value;
	  return O;
	};

	var objectDefineProperty = {
		f: f$2
	};

	var createNonEnumerableProperty = descriptors ? function (object, key, value) {
	  return objectDefineProperty.f(object, key, createPropertyDescriptor(1, value));
	} : function (object, key, value) {
	  object[key] = value;
	  return object;
	};

	var setGlobal = function (key, value) {
	  try {
	    createNonEnumerableProperty(global_1, key, value);
	  } catch (error) {
	    global_1[key] = value;
	  } return value;
	};

	var SHARED = '__core-js_shared__';
	var store = global_1[SHARED] || setGlobal(SHARED, {});

	var sharedStore = store;

	var functionToString = Function.toString;

	// this helper broken in `3.4.1-3.4.4`, so we can't use `shared` helper
	if (typeof sharedStore.inspectSource != 'function') {
	  sharedStore.inspectSource = function (it) {
	    return functionToString.call(it);
	  };
	}

	var inspectSource = sharedStore.inspectSource;

	var WeakMap$1 = global_1.WeakMap;

	var nativeWeakMap = typeof WeakMap$1 === 'function' && /native code/.test(inspectSource(WeakMap$1));

	var shared = createCommonjsModule(function (module) {
	(module.exports = function (key, value) {
	  return sharedStore[key] || (sharedStore[key] = value !== undefined ? value : {});
	})('versions', []).push({
	  version: '3.6.5',
	  mode:  'global',
	  copyright: 'Â© 2020 Denis Pushkarev (zloirock.ru)'
	});
	});

	var id = 0;
	var postfix = Math.random();

	var uid = function (key) {
	  return 'Symbol(' + String(key === undefined ? '' : key) + ')_' + (++id + postfix).toString(36);
	};

	var keys = shared('keys');

	var sharedKey = function (key) {
	  return keys[key] || (keys[key] = uid(key));
	};

	var hiddenKeys = {};

	var WeakMap$2 = global_1.WeakMap;
	var set, get, has$1;

	var enforce = function (it) {
	  return has$1(it) ? get(it) : set(it, {});
	};

	var getterFor = function (TYPE) {
	  return function (it) {
	    var state;
	    if (!isObject(it) || (state = get(it)).type !== TYPE) {
	      throw TypeError('Incompatible receiver, ' + TYPE + ' required');
	    } return state;
	  };
	};

	if (nativeWeakMap) {
	  var store$1 = new WeakMap$2();
	  var wmget = store$1.get;
	  var wmhas = store$1.has;
	  var wmset = store$1.set;
	  set = function (it, metadata) {
	    wmset.call(store$1, it, metadata);
	    return metadata;
	  };
	  get = function (it) {
	    return wmget.call(store$1, it) || {};
	  };
	  has$1 = function (it) {
	    return wmhas.call(store$1, it);
	  };
	} else {
	  var STATE = sharedKey('state');
	  hiddenKeys[STATE] = true;
	  set = function (it, metadata) {
	    createNonEnumerableProperty(it, STATE, metadata);
	    return metadata;
	  };
	  get = function (it) {
	    return has(it, STATE) ? it[STATE] : {};
	  };
	  has$1 = function (it) {
	    return has(it, STATE);
	  };
	}

	var internalState = {
	  set: set,
	  get: get,
	  has: has$1,
	  enforce: enforce,
	  getterFor: getterFor
	};

	var redefine = createCommonjsModule(function (module) {
	var getInternalState = internalState.get;
	var enforceInternalState = internalState.enforce;
	var TEMPLATE = String(String).split('String');

	(module.exports = function (O, key, value, options) {
	  var unsafe = options ? !!options.unsafe : false;
	  var simple = options ? !!options.enumerable : false;
	  var noTargetGet = options ? !!options.noTargetGet : false;
	  if (typeof value == 'function') {
	    if (typeof key == 'string' && !has(value, 'name')) createNonEnumerableProperty(value, 'name', key);
	    enforceInternalState(value).source = TEMPLATE.join(typeof key == 'string' ? key : '');
	  }
	  if (O === global_1) {
	    if (simple) O[key] = value;
	    else setGlobal(key, value);
	    return;
	  } else if (!unsafe) {
	    delete O[key];
	  } else if (!noTargetGet && O[key]) {
	    simple = true;
	  }
	  if (simple) O[key] = value;
	  else createNonEnumerableProperty(O, key, value);
	// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
	})(Function.prototype, 'toString', function toString() {
	  return typeof this == 'function' && getInternalState(this).source || inspectSource(this);
	});
	});

	var path = global_1;

	var aFunction = function (variable) {
	  return typeof variable == 'function' ? variable : undefined;
	};

	var getBuiltIn = function (namespace, method) {
	  return arguments.length < 2 ? aFunction(path[namespace]) || aFunction(global_1[namespace])
	    : path[namespace] && path[namespace][method] || global_1[namespace] && global_1[namespace][method];
	};

	var ceil = Math.ceil;
	var floor = Math.floor;

	// `ToInteger` abstract operation
	// https://tc39.github.io/ecma262/#sec-tointeger
	var toInteger = function (argument) {
	  return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument);
	};

	var min = Math.min;

	// `ToLength` abstract operation
	// https://tc39.github.io/ecma262/#sec-tolength
	var toLength = function (argument) {
	  return argument > 0 ? min(toInteger(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
	};

	var max = Math.max;
	var min$1 = Math.min;

	// Helper for a popular repeating case of the spec:
	// Let integer be ? ToInteger(index).
	// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).
	var toAbsoluteIndex = function (index, length) {
	  var integer = toInteger(index);
	  return integer < 0 ? max(integer + length, 0) : min$1(integer, length);
	};

	// `Array.prototype.{ indexOf, includes }` methods implementation
	var createMethod = function (IS_INCLUDES) {
	  return function ($this, el, fromIndex) {
	    var O = toIndexedObject($this);
	    var length = toLength(O.length);
	    var index = toAbsoluteIndex(fromIndex, length);
	    var value;
	    // Array#includes uses SameValueZero equality algorithm
	    // eslint-disable-next-line no-self-compare
	    if (IS_INCLUDES && el != el) while (length > index) {
	      value = O[index++];
	      // eslint-disable-next-line no-self-compare
	      if (value != value) return true;
	    // Array#indexOf ignores holes, Array#includes - not
	    } else for (;length > index; index++) {
	      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
	    } return !IS_INCLUDES && -1;
	  };
	};

	var arrayIncludes = {
	  // `Array.prototype.includes` method
	  // https://tc39.github.io/ecma262/#sec-array.prototype.includes
	  includes: createMethod(true),
	  // `Array.prototype.indexOf` method
	  // https://tc39.github.io/ecma262/#sec-array.prototype.indexof
	  indexOf: createMethod(false)
	};

	var indexOf = arrayIncludes.indexOf;


	var objectKeysInternal = function (object, names) {
	  var O = toIndexedObject(object);
	  var i = 0;
	  var result = [];
	  var key;
	  for (key in O) !has(hiddenKeys, key) && has(O, key) && result.push(key);
	  // Don't enum bug & hidden keys
	  while (names.length > i) if (has(O, key = names[i++])) {
	    ~indexOf(result, key) || result.push(key);
	  }
	  return result;
	};

	// IE8- don't enum bug keys
	var enumBugKeys = [
	  'constructor',
	  'hasOwnProperty',
	  'isPrototypeOf',
	  'propertyIsEnumerable',
	  'toLocaleString',
	  'toString',
	  'valueOf'
	];

	var hiddenKeys$1 = enumBugKeys.concat('length', 'prototype');

	// `Object.getOwnPropertyNames` method
	// https://tc39.github.io/ecma262/#sec-object.getownpropertynames
	var f$3 = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
	  return objectKeysInternal(O, hiddenKeys$1);
	};

	var objectGetOwnPropertyNames = {
		f: f$3
	};

	var f$4 = Object.getOwnPropertySymbols;

	var objectGetOwnPropertySymbols = {
		f: f$4
	};

	// all object keys, includes non-enumerable and symbols
	var ownKeys = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {
	  var keys = objectGetOwnPropertyNames.f(anObject(it));
	  var getOwnPropertySymbols = objectGetOwnPropertySymbols.f;
	  return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;
	};

	var copyConstructorProperties = function (target, source) {
	  var keys = ownKeys(source);
	  var defineProperty = objectDefineProperty.f;
	  var getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;
	  for (var i = 0; i < keys.length; i++) {
	    var key = keys[i];
	    if (!has(target, key)) defineProperty(target, key, getOwnPropertyDescriptor(source, key));
	  }
	};

	var replacement = /#|\.prototype\./;

	var isForced = function (feature, detection) {
	  var value = data[normalize(feature)];
	  return value == POLYFILL ? true
	    : value == NATIVE ? false
	    : typeof detection == 'function' ? fails(detection)
	    : !!detection;
	};

	var normalize = isForced.normalize = function (string) {
	  return String(string).replace(replacement, '.').toLowerCase();
	};

	var data = isForced.data = {};
	var NATIVE = isForced.NATIVE = 'N';
	var POLYFILL = isForced.POLYFILL = 'P';

	var isForced_1 = isForced;

	var getOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f;






	/*
	  options.target      - name of the target object
	  options.global      - target is the global object
	  options.stat        - export as static methods of target
	  options.proto       - export as prototype methods of target
	  options.real        - real prototype method for the `pure` version
	  options.forced      - export even if the native feature is available
	  options.bind        - bind methods to the target, required for the `pure` version
	  options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version
	  options.unsafe      - use the simple assignment of property instead of delete + defineProperty
	  options.sham        - add a flag to not completely full polyfills
	  options.enumerable  - export as enumerable property
	  options.noTargetGet - prevent calling a getter on target
	*/
	var _export = function (options, source) {
	  var TARGET = options.target;
	  var GLOBAL = options.global;
	  var STATIC = options.stat;
	  var FORCED, target, key, targetProperty, sourceProperty, descriptor;
	  if (GLOBAL) {
	    target = global_1;
	  } else if (STATIC) {
	    target = global_1[TARGET] || setGlobal(TARGET, {});
	  } else {
	    target = (global_1[TARGET] || {}).prototype;
	  }
	  if (target) for (key in source) {
	    sourceProperty = source[key];
	    if (options.noTargetGet) {
	      descriptor = getOwnPropertyDescriptor$1(target, key);
	      targetProperty = descriptor && descriptor.value;
	    } else targetProperty = target[key];
	    FORCED = isForced_1(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
	    // contained in target
	    if (!FORCED && targetProperty !== undefined) {
	      if (typeof sourceProperty === typeof targetProperty) continue;
	      copyConstructorProperties(sourceProperty, targetProperty);
	    }
	    // add a flag to not completely full polyfills
	    if (options.sham || (targetProperty && targetProperty.sham)) {
	      createNonEnumerableProperty(sourceProperty, 'sham', true);
	    }
	    // extend global
	    redefine(target, key, sourceProperty, options);
	  }
	};

	var nativePromiseConstructor = global_1.Promise;

	var redefineAll = function (target, src, options) {
	  for (var key in src) redefine(target, key, src[key], options);
	  return target;
	};

	var nativeSymbol = !!Object.getOwnPropertySymbols && !fails(function () {
	  // Chrome 38 Symbol has incorrect toString conversion
	  // eslint-disable-next-line no-undef
	  return !String(Symbol());
	});

	var useSymbolAsUid = nativeSymbol
	  // eslint-disable-next-line no-undef
	  && !Symbol.sham
	  // eslint-disable-next-line no-undef
	  && typeof Symbol.iterator == 'symbol';

	var WellKnownSymbolsStore = shared('wks');
	var Symbol$1 = global_1.Symbol;
	var createWellKnownSymbol = useSymbolAsUid ? Symbol$1 : Symbol$1 && Symbol$1.withoutSetter || uid;

	var wellKnownSymbol = function (name) {
	  if (!has(WellKnownSymbolsStore, name)) {
	    if (nativeSymbol && has(Symbol$1, name)) WellKnownSymbolsStore[name] = Symbol$1[name];
	    else WellKnownSymbolsStore[name] = createWellKnownSymbol('Symbol.' + name);
	  } return WellKnownSymbolsStore[name];
	};

	var defineProperty = objectDefineProperty.f;



	var TO_STRING_TAG = wellKnownSymbol('toStringTag');

	var setToStringTag = function (it, TAG, STATIC) {
	  if (it && !has(it = STATIC ? it : it.prototype, TO_STRING_TAG)) {
	    defineProperty(it, TO_STRING_TAG, { configurable: true, value: TAG });
	  }
	};

	var SPECIES = wellKnownSymbol('species');

	var setSpecies = function (CONSTRUCTOR_NAME) {
	  var Constructor = getBuiltIn(CONSTRUCTOR_NAME);
	  var defineProperty = objectDefineProperty.f;

	  if (descriptors && Constructor && !Constructor[SPECIES]) {
	    defineProperty(Constructor, SPECIES, {
	      configurable: true,
	      get: function () { return this; }
	    });
	  }
	};

	var aFunction$1 = function (it) {
	  if (typeof it != 'function') {
	    throw TypeError(String(it) + ' is not a function');
	  } return it;
	};

	var anInstance = function (it, Constructor, name) {
	  if (!(it instanceof Constructor)) {
	    throw TypeError('Incorrect ' + (name ? name + ' ' : '') + 'invocation');
	  } return it;
	};

	var iterators = {};

	var ITERATOR = wellKnownSymbol('iterator');
	var ArrayPrototype = Array.prototype;

	// check on default Array iterator
	var isArrayIteratorMethod = function (it) {
	  return it !== undefined && (iterators.Array === it || ArrayPrototype[ITERATOR] === it);
	};

	// optional / simple context binding
	var functionBindContext = function (fn, that, length) {
	  aFunction$1(fn);
	  if (that === undefined) return fn;
	  switch (length) {
	    case 0: return function () {
	      return fn.call(that);
	    };
	    case 1: return function (a) {
	      return fn.call(that, a);
	    };
	    case 2: return function (a, b) {
	      return fn.call(that, a, b);
	    };
	    case 3: return function (a, b, c) {
	      return fn.call(that, a, b, c);
	    };
	  }
	  return function (/* ...args */) {
	    return fn.apply(that, arguments);
	  };
	};

	var TO_STRING_TAG$1 = wellKnownSymbol('toStringTag');
	var test = {};

	test[TO_STRING_TAG$1] = 'z';

	var toStringTagSupport = String(test) === '[object z]';

	var TO_STRING_TAG$2 = wellKnownSymbol('toStringTag');
	// ES3 wrong here
	var CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) == 'Arguments';

	// fallback for IE11 Script Access Denied error
	var tryGet = function (it, key) {
	  try {
	    return it[key];
	  } catch (error) { /* empty */ }
	};

	// getting tag from ES6+ `Object.prototype.toString`
	var classof = toStringTagSupport ? classofRaw : function (it) {
	  var O, tag, result;
	  return it === undefined ? 'Undefined' : it === null ? 'Null'
	    // @@toStringTag case
	    : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG$2)) == 'string' ? tag
	    // builtinTag case
	    : CORRECT_ARGUMENTS ? classofRaw(O)
	    // ES3 arguments fallback
	    : (result = classofRaw(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : result;
	};

	var ITERATOR$1 = wellKnownSymbol('iterator');

	var getIteratorMethod = function (it) {
	  if (it != undefined) return it[ITERATOR$1]
	    || it['@@iterator']
	    || iterators[classof(it)];
	};

	// call something on iterator step with safe closing on error
	var callWithSafeIterationClosing = function (iterator, fn, value, ENTRIES) {
	  try {
	    return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value);
	  // 7.4.6 IteratorClose(iterator, completion)
	  } catch (error) {
	    var returnMethod = iterator['return'];
	    if (returnMethod !== undefined) anObject(returnMethod.call(iterator));
	    throw error;
	  }
	};

	var iterate_1 = createCommonjsModule(function (module) {
	var Result = function (stopped, result) {
	  this.stopped = stopped;
	  this.result = result;
	};

	var iterate = module.exports = function (iterable, fn, that, AS_ENTRIES, IS_ITERATOR) {
	  var boundFunction = functionBindContext(fn, that, AS_ENTRIES ? 2 : 1);
	  var iterator, iterFn, index, length, result, next, step;

	  if (IS_ITERATOR) {
	    iterator = iterable;
	  } else {
	    iterFn = getIteratorMethod(iterable);
	    if (typeof iterFn != 'function') throw TypeError('Target is not iterable');
	    // optimisation for array iterators
	    if (isArrayIteratorMethod(iterFn)) {
	      for (index = 0, length = toLength(iterable.length); length > index; index++) {
	        result = AS_ENTRIES
	          ? boundFunction(anObject(step = iterable[index])[0], step[1])
	          : boundFunction(iterable[index]);
	        if (result && result instanceof Result) return result;
	      } return new Result(false);
	    }
	    iterator = iterFn.call(iterable);
	  }

	  next = iterator.next;
	  while (!(step = next.call(iterator)).done) {
	    result = callWithSafeIterationClosing(iterator, boundFunction, step.value, AS_ENTRIES);
	    if (typeof result == 'object' && result && result instanceof Result) return result;
	  } return new Result(false);
	};

	iterate.stop = function (result) {
	  return new Result(true, result);
	};
	});

	var ITERATOR$2 = wellKnownSymbol('iterator');
	var SAFE_CLOSING = false;

	try {
	  var called = 0;
	  var iteratorWithReturn = {
	    next: function () {
	      return { done: !!called++ };
	    },
	    'return': function () {
	      SAFE_CLOSING = true;
	    }
	  };
	  iteratorWithReturn[ITERATOR$2] = function () {
	    return this;
	  };
	  // eslint-disable-next-line no-throw-literal
	  Array.from(iteratorWithReturn, function () { throw 2; });
	} catch (error) { /* empty */ }

	var checkCorrectnessOfIteration = function (exec, SKIP_CLOSING) {
	  if (!SKIP_CLOSING && !SAFE_CLOSING) return false;
	  var ITERATION_SUPPORT = false;
	  try {
	    var object = {};
	    object[ITERATOR$2] = function () {
	      return {
	        next: function () {
	          return { done: ITERATION_SUPPORT = true };
	        }
	      };
	    };
	    exec(object);
	  } catch (error) { /* empty */ }
	  return ITERATION_SUPPORT;
	};

	var SPECIES$1 = wellKnownSymbol('species');

	// `SpeciesConstructor` abstract operation
	// https://tc39.github.io/ecma262/#sec-speciesconstructor
	var speciesConstructor = function (O, defaultConstructor) {
	  var C = anObject(O).constructor;
	  var S;
	  return C === undefined || (S = anObject(C)[SPECIES$1]) == undefined ? defaultConstructor : aFunction$1(S);
	};

	var html = getBuiltIn('document', 'documentElement');

	var engineUserAgent = getBuiltIn('navigator', 'userAgent') || '';

	var engineIsIos = /(iphone|ipod|ipad).*applewebkit/i.test(engineUserAgent);

	var location = global_1.location;
	var set$1 = global_1.setImmediate;
	var clear = global_1.clearImmediate;
	var process$1 = global_1.process;
	var MessageChannel = global_1.MessageChannel;
	var Dispatch = global_1.Dispatch;
	var counter = 0;
	var queue = {};
	var ONREADYSTATECHANGE = 'onreadystatechange';
	var defer, channel, port;

	var run = function (id) {
	  // eslint-disable-next-line no-prototype-builtins
	  if (queue.hasOwnProperty(id)) {
	    var fn = queue[id];
	    delete queue[id];
	    fn();
	  }
	};

	var runner = function (id) {
	  return function () {
	    run(id);
	  };
	};

	var listener = function (event) {
	  run(event.data);
	};

	var post = function (id) {
	  // old engines have not location.origin
	  global_1.postMessage(id + '', location.protocol + '//' + location.host);
	};

	// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
	if (!set$1 || !clear) {
	  set$1 = function setImmediate(fn) {
	    var args = [];
	    var i = 1;
	    while (arguments.length > i) args.push(arguments[i++]);
	    queue[++counter] = function () {
	      // eslint-disable-next-line no-new-func
	      (typeof fn == 'function' ? fn : Function(fn)).apply(undefined, args);
	    };
	    defer(counter);
	    return counter;
	  };
	  clear = function clearImmediate(id) {
	    delete queue[id];
	  };
	  // Node.js 0.8-
	  if (classofRaw(process$1) == 'process') {
	    defer = function (id) {
	      process$1.nextTick(runner(id));
	    };
	  // Sphere (JS game engine) Dispatch API
	  } else if (Dispatch && Dispatch.now) {
	    defer = function (id) {
	      Dispatch.now(runner(id));
	    };
	  // Browsers with MessageChannel, includes WebWorkers
	  // except iOS - https://github.com/zloirock/core-js/issues/624
	  } else if (MessageChannel && !engineIsIos) {
	    channel = new MessageChannel();
	    port = channel.port2;
	    channel.port1.onmessage = listener;
	    defer = functionBindContext(port.postMessage, port, 1);
	  // Browsers with postMessage, skip WebWorkers
	  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
	  } else if (
	    global_1.addEventListener &&
	    typeof postMessage == 'function' &&
	    !global_1.importScripts &&
	    !fails(post) &&
	    location.protocol !== 'file:'
	  ) {
	    defer = post;
	    global_1.addEventListener('message', listener, false);
	  // IE8-
	  } else if (ONREADYSTATECHANGE in documentCreateElement('script')) {
	    defer = function (id) {
	      html.appendChild(documentCreateElement('script'))[ONREADYSTATECHANGE] = function () {
	        html.removeChild(this);
	        run(id);
	      };
	    };
	  // Rest old browsers
	  } else {
	    defer = function (id) {
	      setTimeout(runner(id), 0);
	    };
	  }
	}

	var task = {
	  set: set$1,
	  clear: clear
	};

	var getOwnPropertyDescriptor$2 = objectGetOwnPropertyDescriptor.f;

	var macrotask = task.set;


	var MutationObserver = global_1.MutationObserver || global_1.WebKitMutationObserver;
	var process$2 = global_1.process;
	var Promise$1 = global_1.Promise;
	var IS_NODE = classofRaw(process$2) == 'process';
	// Node.js 11 shows ExperimentalWarning on getting `queueMicrotask`
	var queueMicrotaskDescriptor = getOwnPropertyDescriptor$2(global_1, 'queueMicrotask');
	var queueMicrotask = queueMicrotaskDescriptor && queueMicrotaskDescriptor.value;

	var flush, head, last, notify, toggle, node, promise, then;

	// modern engines have queueMicrotask method
	if (!queueMicrotask) {
	  flush = function () {
	    var parent, fn;
	    if (IS_NODE && (parent = process$2.domain)) parent.exit();
	    while (head) {
	      fn = head.fn;
	      head = head.next;
	      try {
	        fn();
	      } catch (error) {
	        if (head) notify();
	        else last = undefined;
	        throw error;
	      }
	    } last = undefined;
	    if (parent) parent.enter();
	  };

	  // Node.js
	  if (IS_NODE) {
	    notify = function () {
	      process$2.nextTick(flush);
	    };
	  // browsers with MutationObserver, except iOS - https://github.com/zloirock/core-js/issues/339
	  } else if (MutationObserver && !engineIsIos) {
	    toggle = true;
	    node = document.createTextNode('');
	    new MutationObserver(flush).observe(node, { characterData: true });
	    notify = function () {
	      node.data = toggle = !toggle;
	    };
	  // environments with maybe non-completely correct, but existent Promise
	  } else if (Promise$1 && Promise$1.resolve) {
	    // Promise.resolve without an argument throws an error in LG WebOS 2
	    promise = Promise$1.resolve(undefined);
	    then = promise.then;
	    notify = function () {
	      then.call(promise, flush);
	    };
	  // for other environments - macrotask based on:
	  // - setImmediate
	  // - MessageChannel
	  // - window.postMessag
	  // - onreadystatechange
	  // - setTimeout
	  } else {
	    notify = function () {
	      // strange IE + webpack dev server bug - use .call(global)
	      macrotask.call(global_1, flush);
	    };
	  }
	}

	var microtask = queueMicrotask || function (fn) {
	  var task = { fn: fn, next: undefined };
	  if (last) last.next = task;
	  if (!head) {
	    head = task;
	    notify();
	  } last = task;
	};

	var PromiseCapability = function (C) {
	  var resolve, reject;
	  this.promise = new C(function ($$resolve, $$reject) {
	    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
	    resolve = $$resolve;
	    reject = $$reject;
	  });
	  this.resolve = aFunction$1(resolve);
	  this.reject = aFunction$1(reject);
	};

	// 25.4.1.5 NewPromiseCapability(C)
	var f$5 = function (C) {
	  return new PromiseCapability(C);
	};

	var newPromiseCapability = {
		f: f$5
	};

	var promiseResolve = function (C, x) {
	  anObject(C);
	  if (isObject(x) && x.constructor === C) return x;
	  var promiseCapability = newPromiseCapability.f(C);
	  var resolve = promiseCapability.resolve;
	  resolve(x);
	  return promiseCapability.promise;
	};

	var hostReportErrors = function (a, b) {
	  var console = global_1.console;
	  if (console && console.error) {
	    arguments.length === 1 ? console.error(a) : console.error(a, b);
	  }
	};

	var perform = function (exec) {
	  try {
	    return { error: false, value: exec() };
	  } catch (error) {
	    return { error: true, value: error };
	  }
	};

	var process$3 = global_1.process;
	var versions = process$3 && process$3.versions;
	var v8 = versions && versions.v8;
	var match, version;

	if (v8) {
	  match = v8.split('.');
	  version = match[0] + match[1];
	} else if (engineUserAgent) {
	  match = engineUserAgent.match(/Edge\/(\d+)/);
	  if (!match || match[1] >= 74) {
	    match = engineUserAgent.match(/Chrome\/(\d+)/);
	    if (match) version = match[1];
	  }
	}

	var engineV8Version = version && +version;

	var task$1 = task.set;










	var SPECIES$2 = wellKnownSymbol('species');
	var PROMISE = 'Promise';
	var getInternalState = internalState.get;
	var setInternalState = internalState.set;
	var getInternalPromiseState = internalState.getterFor(PROMISE);
	var PromiseConstructor = nativePromiseConstructor;
	var TypeError$1 = global_1.TypeError;
	var document$2 = global_1.document;
	var process$4 = global_1.process;
	var $fetch = getBuiltIn('fetch');
	var newPromiseCapability$1 = newPromiseCapability.f;
	var newGenericPromiseCapability = newPromiseCapability$1;
	var IS_NODE$1 = classofRaw(process$4) == 'process';
	var DISPATCH_EVENT = !!(document$2 && document$2.createEvent && global_1.dispatchEvent);
	var UNHANDLED_REJECTION = 'unhandledrejection';
	var REJECTION_HANDLED = 'rejectionhandled';
	var PENDING = 0;
	var FULFILLED = 1;
	var REJECTED = 2;
	var HANDLED = 1;
	var UNHANDLED = 2;
	var Internal, OwnPromiseCapability, PromiseWrapper, nativeThen;

	var FORCED = isForced_1(PROMISE, function () {
	  var GLOBAL_CORE_JS_PROMISE = inspectSource(PromiseConstructor) !== String(PromiseConstructor);
	  if (!GLOBAL_CORE_JS_PROMISE) {
	    // V8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
	    // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
	    // We can't detect it synchronously, so just check versions
	    if (engineV8Version === 66) return true;
	    // Unhandled rejections tracking support, NodeJS Promise without it fails @@species test
	    if (!IS_NODE$1 && typeof PromiseRejectionEvent != 'function') return true;
	  }
	  // We can't use @@species feature detection in V8 since it causes
	  // deoptimization and performance degradation
	  // https://github.com/zloirock/core-js/issues/679
	  if (engineV8Version >= 51 && /native code/.test(PromiseConstructor)) return false;
	  // Detect correctness of subclassing with @@species support
	  var promise = PromiseConstructor.resolve(1);
	  var FakePromise = function (exec) {
	    exec(function () { /* empty */ }, function () { /* empty */ });
	  };
	  var constructor = promise.constructor = {};
	  constructor[SPECIES$2] = FakePromise;
	  return !(promise.then(function () { /* empty */ }) instanceof FakePromise);
	});

	var INCORRECT_ITERATION = FORCED || !checkCorrectnessOfIteration(function (iterable) {
	  PromiseConstructor.all(iterable)['catch'](function () { /* empty */ });
	});

	// helpers
	var isThenable = function (it) {
	  var then;
	  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
	};

	var notify$1 = function (promise, state, isReject) {
	  if (state.notified) return;
	  state.notified = true;
	  var chain = state.reactions;
	  microtask(function () {
	    var value = state.value;
	    var ok = state.state == FULFILLED;
	    var index = 0;
	    // variable length - can't use forEach
	    while (chain.length > index) {
	      var reaction = chain[index++];
	      var handler = ok ? reaction.ok : reaction.fail;
	      var resolve = reaction.resolve;
	      var reject = reaction.reject;
	      var domain = reaction.domain;
	      var result, then, exited;
	      try {
	        if (handler) {
	          if (!ok) {
	            if (state.rejection === UNHANDLED) onHandleUnhandled(promise, state);
	            state.rejection = HANDLED;
	          }
	          if (handler === true) result = value;
	          else {
	            if (domain) domain.enter();
	            result = handler(value); // can throw
	            if (domain) {
	              domain.exit();
	              exited = true;
	            }
	          }
	          if (result === reaction.promise) {
	            reject(TypeError$1('Promise-chain cycle'));
	          } else if (then = isThenable(result)) {
	            then.call(result, resolve, reject);
	          } else resolve(result);
	        } else reject(value);
	      } catch (error) {
	        if (domain && !exited) domain.exit();
	        reject(error);
	      }
	    }
	    state.reactions = [];
	    state.notified = false;
	    if (isReject && !state.rejection) onUnhandled(promise, state);
	  });
	};

	var dispatchEvent = function (name, promise, reason) {
	  var event, handler;
	  if (DISPATCH_EVENT) {
	    event = document$2.createEvent('Event');
	    event.promise = promise;
	    event.reason = reason;
	    event.initEvent(name, false, true);
	    global_1.dispatchEvent(event);
	  } else event = { promise: promise, reason: reason };
	  if (handler = global_1['on' + name]) handler(event);
	  else if (name === UNHANDLED_REJECTION) hostReportErrors('Unhandled promise rejection', reason);
	};

	var onUnhandled = function (promise, state) {
	  task$1.call(global_1, function () {
	    var value = state.value;
	    var IS_UNHANDLED = isUnhandled(state);
	    var result;
	    if (IS_UNHANDLED) {
	      result = perform(function () {
	        if (IS_NODE$1) {
	          process$4.emit('unhandledRejection', value, promise);
	        } else dispatchEvent(UNHANDLED_REJECTION, promise, value);
	      });
	      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
	      state.rejection = IS_NODE$1 || isUnhandled(state) ? UNHANDLED : HANDLED;
	      if (result.error) throw result.value;
	    }
	  });
	};

	var isUnhandled = function (state) {
	  return state.rejection !== HANDLED && !state.parent;
	};

	var onHandleUnhandled = function (promise, state) {
	  task$1.call(global_1, function () {
	    if (IS_NODE$1) {
	      process$4.emit('rejectionHandled', promise);
	    } else dispatchEvent(REJECTION_HANDLED, promise, state.value);
	  });
	};

	var bind = function (fn, promise, state, unwrap) {
	  return function (value) {
	    fn(promise, state, value, unwrap);
	  };
	};

	var internalReject = function (promise, state, value, unwrap) {
	  if (state.done) return;
	  state.done = true;
	  if (unwrap) state = unwrap;
	  state.value = value;
	  state.state = REJECTED;
	  notify$1(promise, state, true);
	};

	var internalResolve = function (promise, state, value, unwrap) {
	  if (state.done) return;
	  state.done = true;
	  if (unwrap) state = unwrap;
	  try {
	    if (promise === value) throw TypeError$1("Promise can't be resolved itself");
	    var then = isThenable(value);
	    if (then) {
	      microtask(function () {
	        var wrapper = { done: false };
	        try {
	          then.call(value,
	            bind(internalResolve, promise, wrapper, state),
	            bind(internalReject, promise, wrapper, state)
	          );
	        } catch (error) {
	          internalReject(promise, wrapper, error, state);
	        }
	      });
	    } else {
	      state.value = value;
	      state.state = FULFILLED;
	      notify$1(promise, state, false);
	    }
	  } catch (error) {
	    internalReject(promise, { done: false }, error, state);
	  }
	};

	// constructor polyfill
	if (FORCED) {
	  // 25.4.3.1 Promise(executor)
	  PromiseConstructor = function Promise(executor) {
	    anInstance(this, PromiseConstructor, PROMISE);
	    aFunction$1(executor);
	    Internal.call(this);
	    var state = getInternalState(this);
	    try {
	      executor(bind(internalResolve, this, state), bind(internalReject, this, state));
	    } catch (error) {
	      internalReject(this, state, error);
	    }
	  };
	  // eslint-disable-next-line no-unused-vars
	  Internal = function Promise(executor) {
	    setInternalState(this, {
	      type: PROMISE,
	      done: false,
	      notified: false,
	      parent: false,
	      reactions: [],
	      rejection: false,
	      state: PENDING,
	      value: undefined
	    });
	  };
	  Internal.prototype = redefineAll(PromiseConstructor.prototype, {
	    // `Promise.prototype.then` method
	    // https://tc39.github.io/ecma262/#sec-promise.prototype.then
	    then: function then(onFulfilled, onRejected) {
	      var state = getInternalPromiseState(this);
	      var reaction = newPromiseCapability$1(speciesConstructor(this, PromiseConstructor));
	      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
	      reaction.fail = typeof onRejected == 'function' && onRejected;
	      reaction.domain = IS_NODE$1 ? process$4.domain : undefined;
	      state.parent = true;
	      state.reactions.push(reaction);
	      if (state.state != PENDING) notify$1(this, state, false);
	      return reaction.promise;
	    },
	    // `Promise.prototype.catch` method
	    // https://tc39.github.io/ecma262/#sec-promise.prototype.catch
	    'catch': function (onRejected) {
	      return this.then(undefined, onRejected);
	    }
	  });
	  OwnPromiseCapability = function () {
	    var promise = new Internal();
	    var state = getInternalState(promise);
	    this.promise = promise;
	    this.resolve = bind(internalResolve, promise, state);
	    this.reject = bind(internalReject, promise, state);
	  };
	  newPromiseCapability.f = newPromiseCapability$1 = function (C) {
	    return C === PromiseConstructor || C === PromiseWrapper
	      ? new OwnPromiseCapability(C)
	      : newGenericPromiseCapability(C);
	  };

	  if ( typeof nativePromiseConstructor == 'function') {
	    nativeThen = nativePromiseConstructor.prototype.then;

	    // wrap native Promise#then for native async functions
	    redefine(nativePromiseConstructor.prototype, 'then', function then(onFulfilled, onRejected) {
	      var that = this;
	      return new PromiseConstructor(function (resolve, reject) {
	        nativeThen.call(that, resolve, reject);
	      }).then(onFulfilled, onRejected);
	    // https://github.com/zloirock/core-js/issues/640
	    }, { unsafe: true });

	    // wrap fetch result
	    if (typeof $fetch == 'function') _export({ global: true, enumerable: true, forced: true }, {
	      // eslint-disable-next-line no-unused-vars
	      fetch: function fetch(input /* , init */) {
	        return promiseResolve(PromiseConstructor, $fetch.apply(global_1, arguments));
	      }
	    });
	  }
	}

	_export({ global: true, wrap: true, forced: FORCED }, {
	  Promise: PromiseConstructor
	});

	setToStringTag(PromiseConstructor, PROMISE, false);
	setSpecies(PROMISE);

	PromiseWrapper = getBuiltIn(PROMISE);

	// statics
	_export({ target: PROMISE, stat: true, forced: FORCED }, {
	  // `Promise.reject` method
	  // https://tc39.github.io/ecma262/#sec-promise.reject
	  reject: function reject(r) {
	    var capability = newPromiseCapability$1(this);
	    capability.reject.call(undefined, r);
	    return capability.promise;
	  }
	});

	_export({ target: PROMISE, stat: true, forced:  FORCED }, {
	  // `Promise.resolve` method
	  // https://tc39.github.io/ecma262/#sec-promise.resolve
	  resolve: function resolve(x) {
	    return promiseResolve( this, x);
	  }
	});

	_export({ target: PROMISE, stat: true, forced: INCORRECT_ITERATION }, {
	  // `Promise.all` method
	  // https://tc39.github.io/ecma262/#sec-promise.all
	  all: function all(iterable) {
	    var C = this;
	    var capability = newPromiseCapability$1(C);
	    var resolve = capability.resolve;
	    var reject = capability.reject;
	    var result = perform(function () {
	      var $promiseResolve = aFunction$1(C.resolve);
	      var values = [];
	      var counter = 0;
	      var remaining = 1;
	      iterate_1(iterable, function (promise) {
	        var index = counter++;
	        var alreadyCalled = false;
	        values.push(undefined);
	        remaining++;
	        $promiseResolve.call(C, promise).then(function (value) {
	          if (alreadyCalled) return;
	          alreadyCalled = true;
	          values[index] = value;
	          --remaining || resolve(values);
	        }, reject);
	      });
	      --remaining || resolve(values);
	    });
	    if (result.error) reject(result.value);
	    return capability.promise;
	  },
	  // `Promise.race` method
	  // https://tc39.github.io/ecma262/#sec-promise.race
	  race: function race(iterable) {
	    var C = this;
	    var capability = newPromiseCapability$1(C);
	    var reject = capability.reject;
	    var result = perform(function () {
	      var $promiseResolve = aFunction$1(C.resolve);
	      iterate_1(iterable, function (promise) {
	        $promiseResolve.call(C, promise).then(capability.resolve, reject);
	      });
	    });
	    if (result.error) reject(result.value);
	    return capability.promise;
	  }
	});

	// `Object.keys` method
	// https://tc39.github.io/ecma262/#sec-object.keys
	var objectKeys = Object.keys || function keys(O) {
	  return objectKeysInternal(O, enumBugKeys);
	};

	// `ToObject` abstract operation
	// https://tc39.github.io/ecma262/#sec-toobject
	var toObject = function (argument) {
	  return Object(requireObjectCoercible(argument));
	};

	var nativeAssign = Object.assign;
	var defineProperty$1 = Object.defineProperty;

	// `Object.assign` method
	// https://tc39.github.io/ecma262/#sec-object.assign
	var objectAssign = !nativeAssign || fails(function () {
	  // should have correct order of operations (Edge bug)
	  if (descriptors && nativeAssign({ b: 1 }, nativeAssign(defineProperty$1({}, 'a', {
	    enumerable: true,
	    get: function () {
	      defineProperty$1(this, 'b', {
	        value: 3,
	        enumerable: false
	      });
	    }
	  }), { b: 2 })).b !== 1) return true;
	  // should work with symbols and should have deterministic property order (V8 bug)
	  var A = {};
	  var B = {};
	  // eslint-disable-next-line no-undef
	  var symbol = Symbol();
	  var alphabet = 'abcdefghijklmnopqrst';
	  A[symbol] = 7;
	  alphabet.split('').forEach(function (chr) { B[chr] = chr; });
	  return nativeAssign({}, A)[symbol] != 7 || objectKeys(nativeAssign({}, B)).join('') != alphabet;
	}) ? function assign(target, source) { // eslint-disable-line no-unused-vars
	  var T = toObject(target);
	  var argumentsLength = arguments.length;
	  var index = 1;
	  var getOwnPropertySymbols = objectGetOwnPropertySymbols.f;
	  var propertyIsEnumerable = objectPropertyIsEnumerable.f;
	  while (argumentsLength > index) {
	    var S = indexedObject(arguments[index++]);
	    var keys = getOwnPropertySymbols ? objectKeys(S).concat(getOwnPropertySymbols(S)) : objectKeys(S);
	    var length = keys.length;
	    var j = 0;
	    var key;
	    while (length > j) {
	      key = keys[j++];
	      if (!descriptors || propertyIsEnumerable.call(S, key)) T[key] = S[key];
	    }
	  } return T;
	} : nativeAssign;

	// `Object.assign` method
	// https://tc39.github.io/ecma262/#sec-object.assign
	_export({ target: 'Object', stat: true, forced: Object.assign !== objectAssign }, {
	  assign: objectAssign
	});

	var FAILS_ON_PRIMITIVES = fails(function () { objectKeys(1); });

	// `Object.keys` method
	// https://tc39.github.io/ecma262/#sec-object.keys
	_export({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES }, {
	  keys: function keys(it) {
	    return objectKeys(toObject(it));
	  }
	});

	var propertyIsEnumerable = objectPropertyIsEnumerable.f;

	// `Object.{ entries, values }` methods implementation
	var createMethod$1 = function (TO_ENTRIES) {
	  return function (it) {
	    var O = toIndexedObject(it);
	    var keys = objectKeys(O);
	    var length = keys.length;
	    var i = 0;
	    var result = [];
	    var key;
	    while (length > i) {
	      key = keys[i++];
	      if (!descriptors || propertyIsEnumerable.call(O, key)) {
	        result.push(TO_ENTRIES ? [key, O[key]] : O[key]);
	      }
	    }
	    return result;
	  };
	};

	var objectToArray = {
	  // `Object.entries` method
	  // https://tc39.github.io/ecma262/#sec-object.entries
	  entries: createMethod$1(true),
	  // `Object.values` method
	  // https://tc39.github.io/ecma262/#sec-object.values
	  values: createMethod$1(false)
	};

	var $values = objectToArray.values;

	// `Object.values` method
	// https://tc39.github.io/ecma262/#sec-object.values
	_export({ target: 'Object', stat: true }, {
	  values: function values(O) {
	    return $values(O);
	  }
	});

	// `IsArray` abstract operation
	// https://tc39.github.io/ecma262/#sec-isarray
	var isArray = Array.isArray || function isArray(arg) {
	  return classofRaw(arg) == 'Array';
	};

	// `Object.defineProperties` method
	// https://tc39.github.io/ecma262/#sec-object.defineproperties
	var objectDefineProperties = descriptors ? Object.defineProperties : function defineProperties(O, Properties) {
	  anObject(O);
	  var keys = objectKeys(Properties);
	  var length = keys.length;
	  var index = 0;
	  var key;
	  while (length > index) objectDefineProperty.f(O, key = keys[index++], Properties[key]);
	  return O;
	};

	var GT = '>';
	var LT = '<';
	var PROTOTYPE = 'prototype';
	var SCRIPT = 'script';
	var IE_PROTO = sharedKey('IE_PROTO');

	var EmptyConstructor = function () { /* empty */ };

	var scriptTag = function (content) {
	  return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;
	};

	// Create object with fake `null` prototype: use ActiveX Object with cleared prototype
	var NullProtoObjectViaActiveX = function (activeXDocument) {
	  activeXDocument.write(scriptTag(''));
	  activeXDocument.close();
	  var temp = activeXDocument.parentWindow.Object;
	  activeXDocument = null; // avoid memory leak
	  return temp;
	};

	// Create object with fake `null` prototype: use iframe Object with cleared prototype
	var NullProtoObjectViaIFrame = function () {
	  // Thrash, waste and sodomy: IE GC bug
	  var iframe = documentCreateElement('iframe');
	  var JS = 'java' + SCRIPT + ':';
	  var iframeDocument;
	  iframe.style.display = 'none';
	  html.appendChild(iframe);
	  // https://github.com/zloirock/core-js/issues/475
	  iframe.src = String(JS);
	  iframeDocument = iframe.contentWindow.document;
	  iframeDocument.open();
	  iframeDocument.write(scriptTag('document.F=Object'));
	  iframeDocument.close();
	  return iframeDocument.F;
	};

	// Check for document.domain and active x support
	// No need to use active x approach when document.domain is not set
	// see https://github.com/es-shims/es5-shim/issues/150
	// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
	// avoid IE GC bug
	var activeXDocument;
	var NullProtoObject = function () {
	  try {
	    /* global ActiveXObject */
	    activeXDocument = document.domain && new ActiveXObject('htmlfile');
	  } catch (error) { /* ignore */ }
	  NullProtoObject = activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame();
	  var length = enumBugKeys.length;
	  while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
	  return NullProtoObject();
	};

	hiddenKeys[IE_PROTO] = true;

	// `Object.create` method
	// https://tc39.github.io/ecma262/#sec-object.create
	var objectCreate = Object.create || function create(O, Properties) {
	  var result;
	  if (O !== null) {
	    EmptyConstructor[PROTOTYPE] = anObject(O);
	    result = new EmptyConstructor();
	    EmptyConstructor[PROTOTYPE] = null;
	    // add "__proto__" for Object.getPrototypeOf polyfill
	    result[IE_PROTO] = O;
	  } else result = NullProtoObject();
	  return Properties === undefined ? result : objectDefineProperties(result, Properties);
	};

	var nativeGetOwnPropertyNames = objectGetOwnPropertyNames.f;

	var toString$1 = {}.toString;

	var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
	  ? Object.getOwnPropertyNames(window) : [];

	var getWindowNames = function (it) {
	  try {
	    return nativeGetOwnPropertyNames(it);
	  } catch (error) {
	    return windowNames.slice();
	  }
	};

	// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
	var f$6 = function getOwnPropertyNames(it) {
	  return windowNames && toString$1.call(it) == '[object Window]'
	    ? getWindowNames(it)
	    : nativeGetOwnPropertyNames(toIndexedObject(it));
	};

	var objectGetOwnPropertyNamesExternal = {
		f: f$6
	};

	var f$7 = wellKnownSymbol;

	var wellKnownSymbolWrapped = {
		f: f$7
	};

	var defineProperty$2 = objectDefineProperty.f;

	var defineWellKnownSymbol = function (NAME) {
	  var Symbol = path.Symbol || (path.Symbol = {});
	  if (!has(Symbol, NAME)) defineProperty$2(Symbol, NAME, {
	    value: wellKnownSymbolWrapped.f(NAME)
	  });
	};

	var SPECIES$3 = wellKnownSymbol('species');

	// `ArraySpeciesCreate` abstract operation
	// https://tc39.github.io/ecma262/#sec-arrayspeciescreate
	var arraySpeciesCreate = function (originalArray, length) {
	  var C;
	  if (isArray(originalArray)) {
	    C = originalArray.constructor;
	    // cross-realm fallback
	    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;
	    else if (isObject(C)) {
	      C = C[SPECIES$3];
	      if (C === null) C = undefined;
	    }
	  } return new (C === undefined ? Array : C)(length === 0 ? 0 : length);
	};

	var push = [].push;

	// `Array.prototype.{ forEach, map, filter, some, every, find, findIndex }` methods implementation
	var createMethod$2 = function (TYPE) {
	  var IS_MAP = TYPE == 1;
	  var IS_FILTER = TYPE == 2;
	  var IS_SOME = TYPE == 3;
	  var IS_EVERY = TYPE == 4;
	  var IS_FIND_INDEX = TYPE == 6;
	  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
	  return function ($this, callbackfn, that, specificCreate) {
	    var O = toObject($this);
	    var self = indexedObject(O);
	    var boundFunction = functionBindContext(callbackfn, that, 3);
	    var length = toLength(self.length);
	    var index = 0;
	    var create = specificCreate || arraySpeciesCreate;
	    var target = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
	    var value, result;
	    for (;length > index; index++) if (NO_HOLES || index in self) {
	      value = self[index];
	      result = boundFunction(value, index, O);
	      if (TYPE) {
	        if (IS_MAP) target[index] = result; // map
	        else if (result) switch (TYPE) {
	          case 3: return true;              // some
	          case 5: return value;             // find
	          case 6: return index;             // findIndex
	          case 2: push.call(target, value); // filter
	        } else if (IS_EVERY) return false;  // every
	      }
	    }
	    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
	  };
	};

	var arrayIteration = {
	  // `Array.prototype.forEach` method
	  // https://tc39.github.io/ecma262/#sec-array.prototype.foreach
	  forEach: createMethod$2(0),
	  // `Array.prototype.map` method
	  // https://tc39.github.io/ecma262/#sec-array.prototype.map
	  map: createMethod$2(1),
	  // `Array.prototype.filter` method
	  // https://tc39.github.io/ecma262/#sec-array.prototype.filter
	  filter: createMethod$2(2),
	  // `Array.prototype.some` method
	  // https://tc39.github.io/ecma262/#sec-array.prototype.some
	  some: createMethod$2(3),
	  // `Array.prototype.every` method
	  // https://tc39.github.io/ecma262/#sec-array.prototype.every
	  every: createMethod$2(4),
	  // `Array.prototype.find` method
	  // https://tc39.github.io/ecma262/#sec-array.prototype.find
	  find: createMethod$2(5),
	  // `Array.prototype.findIndex` method
	  // https://tc39.github.io/ecma262/#sec-array.prototype.findIndex
	  findIndex: createMethod$2(6)
	};

	var $forEach = arrayIteration.forEach;

	var HIDDEN = sharedKey('hidden');
	var SYMBOL = 'Symbol';
	var PROTOTYPE$1 = 'prototype';
	var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');
	var setInternalState$1 = internalState.set;
	var getInternalState$1 = internalState.getterFor(SYMBOL);
	var ObjectPrototype = Object[PROTOTYPE$1];
	var $Symbol = global_1.Symbol;
	var $stringify = getBuiltIn('JSON', 'stringify');
	var nativeGetOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f;
	var nativeDefineProperty$1 = objectDefineProperty.f;
	var nativeGetOwnPropertyNames$1 = objectGetOwnPropertyNamesExternal.f;
	var nativePropertyIsEnumerable$1 = objectPropertyIsEnumerable.f;
	var AllSymbols = shared('symbols');
	var ObjectPrototypeSymbols = shared('op-symbols');
	var StringToSymbolRegistry = shared('string-to-symbol-registry');
	var SymbolToStringRegistry = shared('symbol-to-string-registry');
	var WellKnownSymbolsStore$1 = shared('wks');
	var QObject = global_1.QObject;
	// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
	var USE_SETTER = !QObject || !QObject[PROTOTYPE$1] || !QObject[PROTOTYPE$1].findChild;

	// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
	var setSymbolDescriptor = descriptors && fails(function () {
	  return objectCreate(nativeDefineProperty$1({}, 'a', {
	    get: function () { return nativeDefineProperty$1(this, 'a', { value: 7 }).a; }
	  })).a != 7;
	}) ? function (O, P, Attributes) {
	  var ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor$1(ObjectPrototype, P);
	  if (ObjectPrototypeDescriptor) delete ObjectPrototype[P];
	  nativeDefineProperty$1(O, P, Attributes);
	  if (ObjectPrototypeDescriptor && O !== ObjectPrototype) {
	    nativeDefineProperty$1(ObjectPrototype, P, ObjectPrototypeDescriptor);
	  }
	} : nativeDefineProperty$1;

	var wrap = function (tag, description) {
	  var symbol = AllSymbols[tag] = objectCreate($Symbol[PROTOTYPE$1]);
	  setInternalState$1(symbol, {
	    type: SYMBOL,
	    tag: tag,
	    description: description
	  });
	  if (!descriptors) symbol.description = description;
	  return symbol;
	};

	var isSymbol = useSymbolAsUid ? function (it) {
	  return typeof it == 'symbol';
	} : function (it) {
	  return Object(it) instanceof $Symbol;
	};

	var $defineProperty = function defineProperty(O, P, Attributes) {
	  if (O === ObjectPrototype) $defineProperty(ObjectPrototypeSymbols, P, Attributes);
	  anObject(O);
	  var key = toPrimitive(P, true);
	  anObject(Attributes);
	  if (has(AllSymbols, key)) {
	    if (!Attributes.enumerable) {
	      if (!has(O, HIDDEN)) nativeDefineProperty$1(O, HIDDEN, createPropertyDescriptor(1, {}));
	      O[HIDDEN][key] = true;
	    } else {
	      if (has(O, HIDDEN) && O[HIDDEN][key]) O[HIDDEN][key] = false;
	      Attributes = objectCreate(Attributes, { enumerable: createPropertyDescriptor(0, false) });
	    } return setSymbolDescriptor(O, key, Attributes);
	  } return nativeDefineProperty$1(O, key, Attributes);
	};

	var $defineProperties = function defineProperties(O, Properties) {
	  anObject(O);
	  var properties = toIndexedObject(Properties);
	  var keys = objectKeys(properties).concat($getOwnPropertySymbols(properties));
	  $forEach(keys, function (key) {
	    if (!descriptors || $propertyIsEnumerable.call(properties, key)) $defineProperty(O, key, properties[key]);
	  });
	  return O;
	};

	var $create = function create(O, Properties) {
	  return Properties === undefined ? objectCreate(O) : $defineProperties(objectCreate(O), Properties);
	};

	var $propertyIsEnumerable = function propertyIsEnumerable(V) {
	  var P = toPrimitive(V, true);
	  var enumerable = nativePropertyIsEnumerable$1.call(this, P);
	  if (this === ObjectPrototype && has(AllSymbols, P) && !has(ObjectPrototypeSymbols, P)) return false;
	  return enumerable || !has(this, P) || !has(AllSymbols, P) || has(this, HIDDEN) && this[HIDDEN][P] ? enumerable : true;
	};

	var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(O, P) {
	  var it = toIndexedObject(O);
	  var key = toPrimitive(P, true);
	  if (it === ObjectPrototype && has(AllSymbols, key) && !has(ObjectPrototypeSymbols, key)) return;
	  var descriptor = nativeGetOwnPropertyDescriptor$1(it, key);
	  if (descriptor && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) {
	    descriptor.enumerable = true;
	  }
	  return descriptor;
	};

	var $getOwnPropertyNames = function getOwnPropertyNames(O) {
	  var names = nativeGetOwnPropertyNames$1(toIndexedObject(O));
	  var result = [];
	  $forEach(names, function (key) {
	    if (!has(AllSymbols, key) && !has(hiddenKeys, key)) result.push(key);
	  });
	  return result;
	};

	var $getOwnPropertySymbols = function getOwnPropertySymbols(O) {
	  var IS_OBJECT_PROTOTYPE = O === ObjectPrototype;
	  var names = nativeGetOwnPropertyNames$1(IS_OBJECT_PROTOTYPE ? ObjectPrototypeSymbols : toIndexedObject(O));
	  var result = [];
	  $forEach(names, function (key) {
	    if (has(AllSymbols, key) && (!IS_OBJECT_PROTOTYPE || has(ObjectPrototype, key))) {
	      result.push(AllSymbols[key]);
	    }
	  });
	  return result;
	};

	// `Symbol` constructor
	// https://tc39.github.io/ecma262/#sec-symbol-constructor
	if (!nativeSymbol) {
	  $Symbol = function Symbol() {
	    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor');
	    var description = !arguments.length || arguments[0] === undefined ? undefined : String(arguments[0]);
	    var tag = uid(description);
	    var setter = function (value) {
	      if (this === ObjectPrototype) setter.call(ObjectPrototypeSymbols, value);
	      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
	      setSymbolDescriptor(this, tag, createPropertyDescriptor(1, value));
	    };
	    if (descriptors && USE_SETTER) setSymbolDescriptor(ObjectPrototype, tag, { configurable: true, set: setter });
	    return wrap(tag, description);
	  };

	  redefine($Symbol[PROTOTYPE$1], 'toString', function toString() {
	    return getInternalState$1(this).tag;
	  });

	  redefine($Symbol, 'withoutSetter', function (description) {
	    return wrap(uid(description), description);
	  });

	  objectPropertyIsEnumerable.f = $propertyIsEnumerable;
	  objectDefineProperty.f = $defineProperty;
	  objectGetOwnPropertyDescriptor.f = $getOwnPropertyDescriptor;
	  objectGetOwnPropertyNames.f = objectGetOwnPropertyNamesExternal.f = $getOwnPropertyNames;
	  objectGetOwnPropertySymbols.f = $getOwnPropertySymbols;

	  wellKnownSymbolWrapped.f = function (name) {
	    return wrap(wellKnownSymbol(name), name);
	  };

	  if (descriptors) {
	    // https://github.com/tc39/proposal-Symbol-description
	    nativeDefineProperty$1($Symbol[PROTOTYPE$1], 'description', {
	      configurable: true,
	      get: function description() {
	        return getInternalState$1(this).description;
	      }
	    });
	    {
	      redefine(ObjectPrototype, 'propertyIsEnumerable', $propertyIsEnumerable, { unsafe: true });
	    }
	  }
	}

	_export({ global: true, wrap: true, forced: !nativeSymbol, sham: !nativeSymbol }, {
	  Symbol: $Symbol
	});

	$forEach(objectKeys(WellKnownSymbolsStore$1), function (name) {
	  defineWellKnownSymbol(name);
	});

	_export({ target: SYMBOL, stat: true, forced: !nativeSymbol }, {
	  // `Symbol.for` method
	  // https://tc39.github.io/ecma262/#sec-symbol.for
	  'for': function (key) {
	    var string = String(key);
	    if (has(StringToSymbolRegistry, string)) return StringToSymbolRegistry[string];
	    var symbol = $Symbol(string);
	    StringToSymbolRegistry[string] = symbol;
	    SymbolToStringRegistry[symbol] = string;
	    return symbol;
	  },
	  // `Symbol.keyFor` method
	  // https://tc39.github.io/ecma262/#sec-symbol.keyfor
	  keyFor: function keyFor(sym) {
	    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol');
	    if (has(SymbolToStringRegistry, sym)) return SymbolToStringRegistry[sym];
	  },
	  useSetter: function () { USE_SETTER = true; },
	  useSimple: function () { USE_SETTER = false; }
	});

	_export({ target: 'Object', stat: true, forced: !nativeSymbol, sham: !descriptors }, {
	  // `Object.create` method
	  // https://tc39.github.io/ecma262/#sec-object.create
	  create: $create,
	  // `Object.defineProperty` method
	  // https://tc39.github.io/ecma262/#sec-object.defineproperty
	  defineProperty: $defineProperty,
	  // `Object.defineProperties` method
	  // https://tc39.github.io/ecma262/#sec-object.defineproperties
	  defineProperties: $defineProperties,
	  // `Object.getOwnPropertyDescriptor` method
	  // https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptors
	  getOwnPropertyDescriptor: $getOwnPropertyDescriptor
	});

	_export({ target: 'Object', stat: true, forced: !nativeSymbol }, {
	  // `Object.getOwnPropertyNames` method
	  // https://tc39.github.io/ecma262/#sec-object.getownpropertynames
	  getOwnPropertyNames: $getOwnPropertyNames,
	  // `Object.getOwnPropertySymbols` method
	  // https://tc39.github.io/ecma262/#sec-object.getownpropertysymbols
	  getOwnPropertySymbols: $getOwnPropertySymbols
	});

	// Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives
	// https://bugs.chromium.org/p/v8/issues/detail?id=3443
	_export({ target: 'Object', stat: true, forced: fails(function () { objectGetOwnPropertySymbols.f(1); }) }, {
	  getOwnPropertySymbols: function getOwnPropertySymbols(it) {
	    return objectGetOwnPropertySymbols.f(toObject(it));
	  }
	});

	// `JSON.stringify` method behavior with symbols
	// https://tc39.github.io/ecma262/#sec-json.stringify
	if ($stringify) {
	  var FORCED_JSON_STRINGIFY = !nativeSymbol || fails(function () {
	    var symbol = $Symbol();
	    // MS Edge converts symbol values to JSON as {}
	    return $stringify([symbol]) != '[null]'
	      // WebKit converts symbol values to JSON as null
	      || $stringify({ a: symbol }) != '{}'
	      // V8 throws on boxed symbols
	      || $stringify(Object(symbol)) != '{}';
	  });

	  _export({ target: 'JSON', stat: true, forced: FORCED_JSON_STRINGIFY }, {
	    // eslint-disable-next-line no-unused-vars
	    stringify: function stringify(it, replacer, space) {
	      var args = [it];
	      var index = 1;
	      var $replacer;
	      while (arguments.length > index) args.push(arguments[index++]);
	      $replacer = replacer;
	      if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
	      if (!isArray(replacer)) replacer = function (key, value) {
	        if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
	        if (!isSymbol(value)) return value;
	      };
	      args[1] = replacer;
	      return $stringify.apply(null, args);
	    }
	  });
	}

	// `Symbol.prototype[@@toPrimitive]` method
	// https://tc39.github.io/ecma262/#sec-symbol.prototype-@@toprimitive
	if (!$Symbol[PROTOTYPE$1][TO_PRIMITIVE]) {
	  createNonEnumerableProperty($Symbol[PROTOTYPE$1], TO_PRIMITIVE, $Symbol[PROTOTYPE$1].valueOf);
	}
	// `Symbol.prototype[@@toStringTag]` property
	// https://tc39.github.io/ecma262/#sec-symbol.prototype-@@tostringtag
	setToStringTag($Symbol, SYMBOL);

	hiddenKeys[HIDDEN] = true;

	// `Symbol.asyncIterator` well-known symbol
	// https://tc39.github.io/ecma262/#sec-symbol.asynciterator
	defineWellKnownSymbol('asyncIterator');

	var UNSCOPABLES = wellKnownSymbol('unscopables');
	var ArrayPrototype$1 = Array.prototype;

	// Array.prototype[@@unscopables]
	// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
	if (ArrayPrototype$1[UNSCOPABLES] == undefined) {
	  objectDefineProperty.f(ArrayPrototype$1, UNSCOPABLES, {
	    configurable: true,
	    value: objectCreate(null)
	  });
	}

	// add a key to Array.prototype[@@unscopables]
	var addToUnscopables = function (key) {
	  ArrayPrototype$1[UNSCOPABLES][key] = true;
	};

	var correctPrototypeGetter = !fails(function () {
	  function F() { /* empty */ }
	  F.prototype.constructor = null;
	  return Object.getPrototypeOf(new F()) !== F.prototype;
	});

	var IE_PROTO$1 = sharedKey('IE_PROTO');
	var ObjectPrototype$1 = Object.prototype;

	// `Object.getPrototypeOf` method
	// https://tc39.github.io/ecma262/#sec-object.getprototypeof
	var objectGetPrototypeOf = correctPrototypeGetter ? Object.getPrototypeOf : function (O) {
	  O = toObject(O);
	  if (has(O, IE_PROTO$1)) return O[IE_PROTO$1];
	  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
	    return O.constructor.prototype;
	  } return O instanceof Object ? ObjectPrototype$1 : null;
	};

	var ITERATOR$3 = wellKnownSymbol('iterator');
	var BUGGY_SAFARI_ITERATORS = false;

	var returnThis = function () { return this; };

	// `%IteratorPrototype%` object
	// https://tc39.github.io/ecma262/#sec-%iteratorprototype%-object
	var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;

	if ([].keys) {
	  arrayIterator = [].keys();
	  // Safari 8 has buggy iterators w/o `next`
	  if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;
	  else {
	    PrototypeOfArrayIteratorPrototype = objectGetPrototypeOf(objectGetPrototypeOf(arrayIterator));
	    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;
	  }
	}

	if (IteratorPrototype == undefined) IteratorPrototype = {};

	// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
	if ( !has(IteratorPrototype, ITERATOR$3)) {
	  createNonEnumerableProperty(IteratorPrototype, ITERATOR$3, returnThis);
	}

	var iteratorsCore = {
	  IteratorPrototype: IteratorPrototype,
	  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS
	};

	var IteratorPrototype$1 = iteratorsCore.IteratorPrototype;





	var returnThis$1 = function () { return this; };

	var createIteratorConstructor = function (IteratorConstructor, NAME, next) {
	  var TO_STRING_TAG = NAME + ' Iterator';
	  IteratorConstructor.prototype = objectCreate(IteratorPrototype$1, { next: createPropertyDescriptor(1, next) });
	  setToStringTag(IteratorConstructor, TO_STRING_TAG, false);
	  iterators[TO_STRING_TAG] = returnThis$1;
	  return IteratorConstructor;
	};

	var aPossiblePrototype = function (it) {
	  if (!isObject(it) && it !== null) {
	    throw TypeError("Can't set " + String(it) + ' as a prototype');
	  } return it;
	};

	// `Object.setPrototypeOf` method
	// https://tc39.github.io/ecma262/#sec-object.setprototypeof
	// Works with __proto__ only. Old v8 can't work with null proto objects.
	/* eslint-disable no-proto */
	var objectSetPrototypeOf = Object.setPrototypeOf || ('__proto__' in {} ? function () {
	  var CORRECT_SETTER = false;
	  var test = {};
	  var setter;
	  try {
	    setter = Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set;
	    setter.call(test, []);
	    CORRECT_SETTER = test instanceof Array;
	  } catch (error) { /* empty */ }
	  return function setPrototypeOf(O, proto) {
	    anObject(O);
	    aPossiblePrototype(proto);
	    if (CORRECT_SETTER) setter.call(O, proto);
	    else O.__proto__ = proto;
	    return O;
	  };
	}() : undefined);

	var IteratorPrototype$2 = iteratorsCore.IteratorPrototype;
	var BUGGY_SAFARI_ITERATORS$1 = iteratorsCore.BUGGY_SAFARI_ITERATORS;
	var ITERATOR$4 = wellKnownSymbol('iterator');
	var KEYS = 'keys';
	var VALUES = 'values';
	var ENTRIES = 'entries';

	var returnThis$2 = function () { return this; };

	var defineIterator = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
	  createIteratorConstructor(IteratorConstructor, NAME, next);

	  var getIterationMethod = function (KIND) {
	    if (KIND === DEFAULT && defaultIterator) return defaultIterator;
	    if (!BUGGY_SAFARI_ITERATORS$1 && KIND in IterablePrototype) return IterablePrototype[KIND];
	    switch (KIND) {
	      case KEYS: return function keys() { return new IteratorConstructor(this, KIND); };
	      case VALUES: return function values() { return new IteratorConstructor(this, KIND); };
	      case ENTRIES: return function entries() { return new IteratorConstructor(this, KIND); };
	    } return function () { return new IteratorConstructor(this); };
	  };

	  var TO_STRING_TAG = NAME + ' Iterator';
	  var INCORRECT_VALUES_NAME = false;
	  var IterablePrototype = Iterable.prototype;
	  var nativeIterator = IterablePrototype[ITERATOR$4]
	    || IterablePrototype['@@iterator']
	    || DEFAULT && IterablePrototype[DEFAULT];
	  var defaultIterator = !BUGGY_SAFARI_ITERATORS$1 && nativeIterator || getIterationMethod(DEFAULT);
	  var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;
	  var CurrentIteratorPrototype, methods, KEY;

	  // fix native
	  if (anyNativeIterator) {
	    CurrentIteratorPrototype = objectGetPrototypeOf(anyNativeIterator.call(new Iterable()));
	    if (IteratorPrototype$2 !== Object.prototype && CurrentIteratorPrototype.next) {
	      if ( objectGetPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype$2) {
	        if (objectSetPrototypeOf) {
	          objectSetPrototypeOf(CurrentIteratorPrototype, IteratorPrototype$2);
	        } else if (typeof CurrentIteratorPrototype[ITERATOR$4] != 'function') {
	          createNonEnumerableProperty(CurrentIteratorPrototype, ITERATOR$4, returnThis$2);
	        }
	      }
	      // Set @@toStringTag to native iterators
	      setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true);
	    }
	  }

	  // fix Array#{values, @@iterator}.name in V8 / FF
	  if (DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
	    INCORRECT_VALUES_NAME = true;
	    defaultIterator = function values() { return nativeIterator.call(this); };
	  }

	  // define iterator
	  if ( IterablePrototype[ITERATOR$4] !== defaultIterator) {
	    createNonEnumerableProperty(IterablePrototype, ITERATOR$4, defaultIterator);
	  }
	  iterators[NAME] = defaultIterator;

	  // export additional methods
	  if (DEFAULT) {
	    methods = {
	      values: getIterationMethod(VALUES),
	      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
	      entries: getIterationMethod(ENTRIES)
	    };
	    if (FORCED) for (KEY in methods) {
	      if (BUGGY_SAFARI_ITERATORS$1 || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
	        redefine(IterablePrototype, KEY, methods[KEY]);
	      }
	    } else _export({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS$1 || INCORRECT_VALUES_NAME }, methods);
	  }

	  return methods;
	};

	var ARRAY_ITERATOR = 'Array Iterator';
	var setInternalState$2 = internalState.set;
	var getInternalState$2 = internalState.getterFor(ARRAY_ITERATOR);

	// `Array.prototype.entries` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.entries
	// `Array.prototype.keys` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.keys
	// `Array.prototype.values` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.values
	// `Array.prototype[@@iterator]` method
	// https://tc39.github.io/ecma262/#sec-array.prototype-@@iterator
	// `CreateArrayIterator` internal method
	// https://tc39.github.io/ecma262/#sec-createarrayiterator
	var es_array_iterator = defineIterator(Array, 'Array', function (iterated, kind) {
	  setInternalState$2(this, {
	    type: ARRAY_ITERATOR,
	    target: toIndexedObject(iterated), // target
	    index: 0,                          // next index
	    kind: kind                         // kind
	  });
	// `%ArrayIteratorPrototype%.next` method
	// https://tc39.github.io/ecma262/#sec-%arrayiteratorprototype%.next
	}, function () {
	  var state = getInternalState$2(this);
	  var target = state.target;
	  var kind = state.kind;
	  var index = state.index++;
	  if (!target || index >= target.length) {
	    state.target = undefined;
	    return { value: undefined, done: true };
	  }
	  if (kind == 'keys') return { value: index, done: false };
	  if (kind == 'values') return { value: target[index], done: false };
	  return { value: [index, target[index]], done: false };
	}, 'values');

	// argumentsList[@@iterator] is %ArrayProto_values%
	// https://tc39.github.io/ecma262/#sec-createunmappedargumentsobject
	// https://tc39.github.io/ecma262/#sec-createmappedargumentsobject
	iterators.Arguments = iterators.Array;

	// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
	addToUnscopables('keys');
	addToUnscopables('values');
	addToUnscopables('entries');

	var defineProperty$3 = Object.defineProperty;
	var cache = {};

	var thrower = function (it) { throw it; };

	var arrayMethodUsesToLength = function (METHOD_NAME, options) {
	  if (has(cache, METHOD_NAME)) return cache[METHOD_NAME];
	  if (!options) options = {};
	  var method = [][METHOD_NAME];
	  var ACCESSORS = has(options, 'ACCESSORS') ? options.ACCESSORS : false;
	  var argument0 = has(options, 0) ? options[0] : thrower;
	  var argument1 = has(options, 1) ? options[1] : undefined;

	  return cache[METHOD_NAME] = !!method && !fails(function () {
	    if (ACCESSORS && !descriptors) return true;
	    var O = { length: -1 };

	    if (ACCESSORS) defineProperty$3(O, 1, { enumerable: true, get: thrower });
	    else O[1] = 1;

	    method.call(O, argument0, argument1);
	  });
	};

	var $includes = arrayIncludes.includes;



	var USES_TO_LENGTH = arrayMethodUsesToLength('indexOf', { ACCESSORS: true, 1: 0 });

	// `Array.prototype.includes` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.includes
	_export({ target: 'Array', proto: true, forced: !USES_TO_LENGTH }, {
	  includes: function includes(el /* , fromIndex = 0 */) {
	    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
	addToUnscopables('includes');

	var $findIndex = arrayIteration.findIndex;



	var FIND_INDEX = 'findIndex';
	var SKIPS_HOLES = true;

	var USES_TO_LENGTH$1 = arrayMethodUsesToLength(FIND_INDEX);

	// Shouldn't skip holes
	if (FIND_INDEX in []) Array(1)[FIND_INDEX](function () { SKIPS_HOLES = false; });

	// `Array.prototype.findIndex` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.findindex
	_export({ target: 'Array', proto: true, forced: SKIPS_HOLES || !USES_TO_LENGTH$1 }, {
	  findIndex: function findIndex(callbackfn /* , that = undefined */) {
	    return $findIndex(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
	addToUnscopables(FIND_INDEX);

	var $find = arrayIteration.find;



	var FIND = 'find';
	var SKIPS_HOLES$1 = true;

	var USES_TO_LENGTH$2 = arrayMethodUsesToLength(FIND);

	// Shouldn't skip holes
	if (FIND in []) Array(1)[FIND](function () { SKIPS_HOLES$1 = false; });

	// `Array.prototype.find` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.find
	_export({ target: 'Array', proto: true, forced: SKIPS_HOLES$1 || !USES_TO_LENGTH$2 }, {
	  find: function find(callbackfn /* , that = undefined */) {
	    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
	addToUnscopables(FIND);

	var fromCharCode = String.fromCharCode;
	var nativeFromCodePoint = String.fromCodePoint;

	// length should be 1, old FF problem
	var INCORRECT_LENGTH = !!nativeFromCodePoint && nativeFromCodePoint.length != 1;

	// `String.fromCodePoint` method
	// https://tc39.github.io/ecma262/#sec-string.fromcodepoint
	_export({ target: 'String', stat: true, forced: INCORRECT_LENGTH }, {
	  fromCodePoint: function fromCodePoint(x) { // eslint-disable-line no-unused-vars
	    var elements = [];
	    var length = arguments.length;
	    var i = 0;
	    var code;
	    while (length > i) {
	      code = +arguments[i++];
	      if (toAbsoluteIndex(code, 0x10FFFF) !== code) throw RangeError(code + ' is not a valid code point');
	      elements.push(code < 0x10000
	        ? fromCharCode(code)
	        : fromCharCode(((code -= 0x10000) >> 10) + 0xD800, code % 0x400 + 0xDC00)
	      );
	    } return elements.join('');
	  }
	});

	var MATCH = wellKnownSymbol('match');

	// `IsRegExp` abstract operation
	// https://tc39.github.io/ecma262/#sec-isregexp
	var isRegexp = function (it) {
	  var isRegExp;
	  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : classofRaw(it) == 'RegExp');
	};

	var notARegexp = function (it) {
	  if (isRegexp(it)) {
	    throw TypeError("The method doesn't accept regular expressions");
	  } return it;
	};

	var MATCH$1 = wellKnownSymbol('match');

	var correctIsRegexpLogic = function (METHOD_NAME) {
	  var regexp = /./;
	  try {
	    '/./'[METHOD_NAME](regexp);
	  } catch (e) {
	    try {
	      regexp[MATCH$1] = false;
	      return '/./'[METHOD_NAME](regexp);
	    } catch (f) { /* empty */ }
	  } return false;
	};

	// `String.prototype.includes` method
	// https://tc39.github.io/ecma262/#sec-string.prototype.includes
	_export({ target: 'String', proto: true, forced: !correctIsRegexpLogic('includes') }, {
	  includes: function includes(searchString /* , position = 0 */) {
	    return !!~String(requireObjectCoercible(this))
	      .indexOf(notARegexp(searchString), arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	// `Number.isNaN` method
	// https://tc39.github.io/ecma262/#sec-number.isnan
	_export({ target: 'Number', stat: true }, {
	  isNaN: function isNaN(number) {
	    // eslint-disable-next-line no-self-compare
	    return number != number;
	  }
	});

	var runtime_1 = createCommonjsModule(function (module) {
	/**
	 * Copyright (c) 2014-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */

	var runtime = (function (exports) {

	  var Op = Object.prototype;
	  var hasOwn = Op.hasOwnProperty;
	  var undefined$1; // More compressible than void 0.
	  var $Symbol = typeof Symbol === "function" ? Symbol : {};
	  var iteratorSymbol = $Symbol.iterator || "@@iterator";
	  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
	  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

	  function define(obj, key, value) {
	    Object.defineProperty(obj, key, {
	      value: value,
	      enumerable: true,
	      configurable: true,
	      writable: true
	    });
	    return obj[key];
	  }
	  try {
	    // IE 8 has a broken Object.defineProperty that only works on DOM objects.
	    define({}, "");
	  } catch (err) {
	    define = function(obj, key, value) {
	      return obj[key] = value;
	    };
	  }

	  function wrap(innerFn, outerFn, self, tryLocsList) {
	    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
	    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
	    var generator = Object.create(protoGenerator.prototype);
	    var context = new Context(tryLocsList || []);

	    // The ._invoke method unifies the implementations of the .next,
	    // .throw, and .return methods.
	    generator._invoke = makeInvokeMethod(innerFn, self, context);

	    return generator;
	  }
	  exports.wrap = wrap;

	  // Try/catch helper to minimize deoptimizations. Returns a completion
	  // record like context.tryEntries[i].completion. This interface could
	  // have been (and was previously) designed to take a closure to be
	  // invoked without arguments, but in all the cases we care about we
	  // already have an existing method we want to call, so there's no need
	  // to create a new function object. We can even get away with assuming
	  // the method takes exactly one argument, since that happens to be true
	  // in every case, so we don't have to touch the arguments object. The
	  // only additional allocation required is the completion record, which
	  // has a stable shape and so hopefully should be cheap to allocate.
	  function tryCatch(fn, obj, arg) {
	    try {
	      return { type: "normal", arg: fn.call(obj, arg) };
	    } catch (err) {
	      return { type: "throw", arg: err };
	    }
	  }

	  var GenStateSuspendedStart = "suspendedStart";
	  var GenStateSuspendedYield = "suspendedYield";
	  var GenStateExecuting = "executing";
	  var GenStateCompleted = "completed";

	  // Returning this object from the innerFn has the same effect as
	  // breaking out of the dispatch switch statement.
	  var ContinueSentinel = {};

	  // Dummy constructor functions that we use as the .constructor and
	  // .constructor.prototype properties for functions that return Generator
	  // objects. For full spec compliance, you may wish to configure your
	  // minifier not to mangle the names of these two functions.
	  function Generator() {}
	  function GeneratorFunction() {}
	  function GeneratorFunctionPrototype() {}

	  // This is a polyfill for %IteratorPrototype% for environments that
	  // don't natively support it.
	  var IteratorPrototype = {};
	  IteratorPrototype[iteratorSymbol] = function () {
	    return this;
	  };

	  var getProto = Object.getPrototypeOf;
	  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
	  if (NativeIteratorPrototype &&
	      NativeIteratorPrototype !== Op &&
	      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
	    // This environment has a native %IteratorPrototype%; use it instead
	    // of the polyfill.
	    IteratorPrototype = NativeIteratorPrototype;
	  }

	  var Gp = GeneratorFunctionPrototype.prototype =
	    Generator.prototype = Object.create(IteratorPrototype);
	  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
	  GeneratorFunctionPrototype.constructor = GeneratorFunction;
	  GeneratorFunction.displayName = define(
	    GeneratorFunctionPrototype,
	    toStringTagSymbol,
	    "GeneratorFunction"
	  );

	  // Helper for defining the .next, .throw, and .return methods of the
	  // Iterator interface in terms of a single ._invoke method.
	  function defineIteratorMethods(prototype) {
	    ["next", "throw", "return"].forEach(function(method) {
	      define(prototype, method, function(arg) {
	        return this._invoke(method, arg);
	      });
	    });
	  }

	  exports.isGeneratorFunction = function(genFun) {
	    var ctor = typeof genFun === "function" && genFun.constructor;
	    return ctor
	      ? ctor === GeneratorFunction ||
	        // For the native GeneratorFunction constructor, the best we can
	        // do is to check its .name property.
	        (ctor.displayName || ctor.name) === "GeneratorFunction"
	      : false;
	  };

	  exports.mark = function(genFun) {
	    if (Object.setPrototypeOf) {
	      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
	    } else {
	      genFun.__proto__ = GeneratorFunctionPrototype;
	      define(genFun, toStringTagSymbol, "GeneratorFunction");
	    }
	    genFun.prototype = Object.create(Gp);
	    return genFun;
	  };

	  // Within the body of any async function, `await x` is transformed to
	  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
	  // `hasOwn.call(value, "__await")` to determine if the yielded value is
	  // meant to be awaited.
	  exports.awrap = function(arg) {
	    return { __await: arg };
	  };

	  function AsyncIterator(generator, PromiseImpl) {
	    function invoke(method, arg, resolve, reject) {
	      var record = tryCatch(generator[method], generator, arg);
	      if (record.type === "throw") {
	        reject(record.arg);
	      } else {
	        var result = record.arg;
	        var value = result.value;
	        if (value &&
	            typeof value === "object" &&
	            hasOwn.call(value, "__await")) {
	          return PromiseImpl.resolve(value.__await).then(function(value) {
	            invoke("next", value, resolve, reject);
	          }, function(err) {
	            invoke("throw", err, resolve, reject);
	          });
	        }

	        return PromiseImpl.resolve(value).then(function(unwrapped) {
	          // When a yielded Promise is resolved, its final value becomes
	          // the .value of the Promise<{value,done}> result for the
	          // current iteration.
	          result.value = unwrapped;
	          resolve(result);
	        }, function(error) {
	          // If a rejected Promise was yielded, throw the rejection back
	          // into the async generator function so it can be handled there.
	          return invoke("throw", error, resolve, reject);
	        });
	      }
	    }

	    var previousPromise;

	    function enqueue(method, arg) {
	      function callInvokeWithMethodAndArg() {
	        return new PromiseImpl(function(resolve, reject) {
	          invoke(method, arg, resolve, reject);
	        });
	      }

	      return previousPromise =
	        // If enqueue has been called before, then we want to wait until
	        // all previous Promises have been resolved before calling invoke,
	        // so that results are always delivered in the correct order. If
	        // enqueue has not been called before, then it is important to
	        // call invoke immediately, without waiting on a callback to fire,
	        // so that the async generator function has the opportunity to do
	        // any necessary setup in a predictable way. This predictability
	        // is why the Promise constructor synchronously invokes its
	        // executor callback, and why async functions synchronously
	        // execute code before the first await. Since we implement simple
	        // async functions in terms of async generators, it is especially
	        // important to get this right, even though it requires care.
	        previousPromise ? previousPromise.then(
	          callInvokeWithMethodAndArg,
	          // Avoid propagating failures to Promises returned by later
	          // invocations of the iterator.
	          callInvokeWithMethodAndArg
	        ) : callInvokeWithMethodAndArg();
	    }

	    // Define the unified helper method that is used to implement .next,
	    // .throw, and .return (see defineIteratorMethods).
	    this._invoke = enqueue;
	  }

	  defineIteratorMethods(AsyncIterator.prototype);
	  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
	    return this;
	  };
	  exports.AsyncIterator = AsyncIterator;

	  // Note that simple async functions are implemented on top of
	  // AsyncIterator objects; they just return a Promise for the value of
	  // the final result produced by the iterator.
	  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
	    if (PromiseImpl === void 0) PromiseImpl = Promise;

	    var iter = new AsyncIterator(
	      wrap(innerFn, outerFn, self, tryLocsList),
	      PromiseImpl
	    );

	    return exports.isGeneratorFunction(outerFn)
	      ? iter // If outerFn is a generator, return the full iterator.
	      : iter.next().then(function(result) {
	          return result.done ? result.value : iter.next();
	        });
	  };

	  function makeInvokeMethod(innerFn, self, context) {
	    var state = GenStateSuspendedStart;

	    return function invoke(method, arg) {
	      if (state === GenStateExecuting) {
	        throw new Error("Generator is already running");
	      }

	      if (state === GenStateCompleted) {
	        if (method === "throw") {
	          throw arg;
	        }

	        // Be forgiving, per 25.3.3.3.3 of the spec:
	        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
	        return doneResult();
	      }

	      context.method = method;
	      context.arg = arg;

	      while (true) {
	        var delegate = context.delegate;
	        if (delegate) {
	          var delegateResult = maybeInvokeDelegate(delegate, context);
	          if (delegateResult) {
	            if (delegateResult === ContinueSentinel) continue;
	            return delegateResult;
	          }
	        }

	        if (context.method === "next") {
	          // Setting context._sent for legacy support of Babel's
	          // function.sent implementation.
	          context.sent = context._sent = context.arg;

	        } else if (context.method === "throw") {
	          if (state === GenStateSuspendedStart) {
	            state = GenStateCompleted;
	            throw context.arg;
	          }

	          context.dispatchException(context.arg);

	        } else if (context.method === "return") {
	          context.abrupt("return", context.arg);
	        }

	        state = GenStateExecuting;

	        var record = tryCatch(innerFn, self, context);
	        if (record.type === "normal") {
	          // If an exception is thrown from innerFn, we leave state ===
	          // GenStateExecuting and loop back for another invocation.
	          state = context.done
	            ? GenStateCompleted
	            : GenStateSuspendedYield;

	          if (record.arg === ContinueSentinel) {
	            continue;
	          }

	          return {
	            value: record.arg,
	            done: context.done
	          };

	        } else if (record.type === "throw") {
	          state = GenStateCompleted;
	          // Dispatch the exception by looping back around to the
	          // context.dispatchException(context.arg) call above.
	          context.method = "throw";
	          context.arg = record.arg;
	        }
	      }
	    };
	  }

	  // Call delegate.iterator[context.method](context.arg) and handle the
	  // result, either by returning a { value, done } result from the
	  // delegate iterator, or by modifying context.method and context.arg,
	  // setting context.delegate to null, and returning the ContinueSentinel.
	  function maybeInvokeDelegate(delegate, context) {
	    var method = delegate.iterator[context.method];
	    if (method === undefined$1) {
	      // A .throw or .return when the delegate iterator has no .throw
	      // method always terminates the yield* loop.
	      context.delegate = null;

	      if (context.method === "throw") {
	        // Note: ["return"] must be used for ES3 parsing compatibility.
	        if (delegate.iterator["return"]) {
	          // If the delegate iterator has a return method, give it a
	          // chance to clean up.
	          context.method = "return";
	          context.arg = undefined$1;
	          maybeInvokeDelegate(delegate, context);

	          if (context.method === "throw") {
	            // If maybeInvokeDelegate(context) changed context.method from
	            // "return" to "throw", let that override the TypeError below.
	            return ContinueSentinel;
	          }
	        }

	        context.method = "throw";
	        context.arg = new TypeError(
	          "The iterator does not provide a 'throw' method");
	      }

	      return ContinueSentinel;
	    }

	    var record = tryCatch(method, delegate.iterator, context.arg);

	    if (record.type === "throw") {
	      context.method = "throw";
	      context.arg = record.arg;
	      context.delegate = null;
	      return ContinueSentinel;
	    }

	    var info = record.arg;

	    if (! info) {
	      context.method = "throw";
	      context.arg = new TypeError("iterator result is not an object");
	      context.delegate = null;
	      return ContinueSentinel;
	    }

	    if (info.done) {
	      // Assign the result of the finished delegate to the temporary
	      // variable specified by delegate.resultName (see delegateYield).
	      context[delegate.resultName] = info.value;

	      // Resume execution at the desired location (see delegateYield).
	      context.next = delegate.nextLoc;

	      // If context.method was "throw" but the delegate handled the
	      // exception, let the outer generator proceed normally. If
	      // context.method was "next", forget context.arg since it has been
	      // "consumed" by the delegate iterator. If context.method was
	      // "return", allow the original .return call to continue in the
	      // outer generator.
	      if (context.method !== "return") {
	        context.method = "next";
	        context.arg = undefined$1;
	      }

	    } else {
	      // Re-yield the result returned by the delegate method.
	      return info;
	    }

	    // The delegate iterator is finished, so forget it and continue with
	    // the outer generator.
	    context.delegate = null;
	    return ContinueSentinel;
	  }

	  // Define Generator.prototype.{next,throw,return} in terms of the
	  // unified ._invoke helper method.
	  defineIteratorMethods(Gp);

	  define(Gp, toStringTagSymbol, "Generator");

	  // A Generator should always return itself as the iterator object when the
	  // @@iterator function is called on it. Some browsers' implementations of the
	  // iterator prototype chain incorrectly implement this, causing the Generator
	  // object to not be returned from this call. This ensures that doesn't happen.
	  // See https://github.com/facebook/regenerator/issues/274 for more details.
	  Gp[iteratorSymbol] = function() {
	    return this;
	  };

	  Gp.toString = function() {
	    return "[object Generator]";
	  };

	  function pushTryEntry(locs) {
	    var entry = { tryLoc: locs[0] };

	    if (1 in locs) {
	      entry.catchLoc = locs[1];
	    }

	    if (2 in locs) {
	      entry.finallyLoc = locs[2];
	      entry.afterLoc = locs[3];
	    }

	    this.tryEntries.push(entry);
	  }

	  function resetTryEntry(entry) {
	    var record = entry.completion || {};
	    record.type = "normal";
	    delete record.arg;
	    entry.completion = record;
	  }

	  function Context(tryLocsList) {
	    // The root entry object (effectively a try statement without a catch
	    // or a finally block) gives us a place to store values thrown from
	    // locations where there is no enclosing try statement.
	    this.tryEntries = [{ tryLoc: "root" }];
	    tryLocsList.forEach(pushTryEntry, this);
	    this.reset(true);
	  }

	  exports.keys = function(object) {
	    var keys = [];
	    for (var key in object) {
	      keys.push(key);
	    }
	    keys.reverse();

	    // Rather than returning an object with a next method, we keep
	    // things simple and return the next function itself.
	    return function next() {
	      while (keys.length) {
	        var key = keys.pop();
	        if (key in object) {
	          next.value = key;
	          next.done = false;
	          return next;
	        }
	      }

	      // To avoid creating an additional object, we just hang the .value
	      // and .done properties off the next function object itself. This
	      // also ensures that the minifier will not anonymize the function.
	      next.done = true;
	      return next;
	    };
	  };

	  function values(iterable) {
	    if (iterable) {
	      var iteratorMethod = iterable[iteratorSymbol];
	      if (iteratorMethod) {
	        return iteratorMethod.call(iterable);
	      }

	      if (typeof iterable.next === "function") {
	        return iterable;
	      }

	      if (!isNaN(iterable.length)) {
	        var i = -1, next = function next() {
	          while (++i < iterable.length) {
	            if (hasOwn.call(iterable, i)) {
	              next.value = iterable[i];
	              next.done = false;
	              return next;
	            }
	          }

	          next.value = undefined$1;
	          next.done = true;

	          return next;
	        };

	        return next.next = next;
	      }
	    }

	    // Return an iterator with no values.
	    return { next: doneResult };
	  }
	  exports.values = values;

	  function doneResult() {
	    return { value: undefined$1, done: true };
	  }

	  Context.prototype = {
	    constructor: Context,

	    reset: function(skipTempReset) {
	      this.prev = 0;
	      this.next = 0;
	      // Resetting context._sent for legacy support of Babel's
	      // function.sent implementation.
	      this.sent = this._sent = undefined$1;
	      this.done = false;
	      this.delegate = null;

	      this.method = "next";
	      this.arg = undefined$1;

	      this.tryEntries.forEach(resetTryEntry);

	      if (!skipTempReset) {
	        for (var name in this) {
	          // Not sure about the optimal order of these conditions:
	          if (name.charAt(0) === "t" &&
	              hasOwn.call(this, name) &&
	              !isNaN(+name.slice(1))) {
	            this[name] = undefined$1;
	          }
	        }
	      }
	    },

	    stop: function() {
	      this.done = true;

	      var rootEntry = this.tryEntries[0];
	      var rootRecord = rootEntry.completion;
	      if (rootRecord.type === "throw") {
	        throw rootRecord.arg;
	      }

	      return this.rval;
	    },

	    dispatchException: function(exception) {
	      if (this.done) {
	        throw exception;
	      }

	      var context = this;
	      function handle(loc, caught) {
	        record.type = "throw";
	        record.arg = exception;
	        context.next = loc;

	        if (caught) {
	          // If the dispatched exception was caught by a catch block,
	          // then let that catch block handle the exception normally.
	          context.method = "next";
	          context.arg = undefined$1;
	        }

	        return !! caught;
	      }

	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        var record = entry.completion;

	        if (entry.tryLoc === "root") {
	          // Exception thrown outside of any try block that could handle
	          // it, so set the completion value of the entire function to
	          // throw the exception.
	          return handle("end");
	        }

	        if (entry.tryLoc <= this.prev) {
	          var hasCatch = hasOwn.call(entry, "catchLoc");
	          var hasFinally = hasOwn.call(entry, "finallyLoc");

	          if (hasCatch && hasFinally) {
	            if (this.prev < entry.catchLoc) {
	              return handle(entry.catchLoc, true);
	            } else if (this.prev < entry.finallyLoc) {
	              return handle(entry.finallyLoc);
	            }

	          } else if (hasCatch) {
	            if (this.prev < entry.catchLoc) {
	              return handle(entry.catchLoc, true);
	            }

	          } else if (hasFinally) {
	            if (this.prev < entry.finallyLoc) {
	              return handle(entry.finallyLoc);
	            }

	          } else {
	            throw new Error("try statement without catch or finally");
	          }
	        }
	      }
	    },

	    abrupt: function(type, arg) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.tryLoc <= this.prev &&
	            hasOwn.call(entry, "finallyLoc") &&
	            this.prev < entry.finallyLoc) {
	          var finallyEntry = entry;
	          break;
	        }
	      }

	      if (finallyEntry &&
	          (type === "break" ||
	           type === "continue") &&
	          finallyEntry.tryLoc <= arg &&
	          arg <= finallyEntry.finallyLoc) {
	        // Ignore the finally entry if control is not jumping to a
	        // location outside the try/catch block.
	        finallyEntry = null;
	      }

	      var record = finallyEntry ? finallyEntry.completion : {};
	      record.type = type;
	      record.arg = arg;

	      if (finallyEntry) {
	        this.method = "next";
	        this.next = finallyEntry.finallyLoc;
	        return ContinueSentinel;
	      }

	      return this.complete(record);
	    },

	    complete: function(record, afterLoc) {
	      if (record.type === "throw") {
	        throw record.arg;
	      }

	      if (record.type === "break" ||
	          record.type === "continue") {
	        this.next = record.arg;
	      } else if (record.type === "return") {
	        this.rval = this.arg = record.arg;
	        this.method = "return";
	        this.next = "end";
	      } else if (record.type === "normal" && afterLoc) {
	        this.next = afterLoc;
	      }

	      return ContinueSentinel;
	    },

	    finish: function(finallyLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.finallyLoc === finallyLoc) {
	          this.complete(entry.completion, entry.afterLoc);
	          resetTryEntry(entry);
	          return ContinueSentinel;
	        }
	      }
	    },

	    "catch": function(tryLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.tryLoc === tryLoc) {
	          var record = entry.completion;
	          if (record.type === "throw") {
	            var thrown = record.arg;
	            resetTryEntry(entry);
	          }
	          return thrown;
	        }
	      }

	      // The context.catch method must only be called with a location
	      // argument that corresponds to a known catch block.
	      throw new Error("illegal catch attempt");
	    },

	    delegateYield: function(iterable, resultName, nextLoc) {
	      this.delegate = {
	        iterator: values(iterable),
	        resultName: resultName,
	        nextLoc: nextLoc
	      };

	      if (this.method === "next") {
	        // Deliberately forget the last sent value so that we don't
	        // accidentally pass it on to the delegate.
	        this.arg = undefined$1;
	      }

	      return ContinueSentinel;
	    }
	  };

	  // Regardless of whether this script is executing as a CommonJS module
	  // or not, return the runtime object so that we can declare the variable
	  // regeneratorRuntime in the outer scope, which allows this module to be
	  // injected easily by `bin/regenerator --include-runtime script.js`.
	  return exports;

	}(
	  // If this script is executing as a CommonJS module, use module.exports
	  // as the regeneratorRuntime namespace. Otherwise create a new empty
	  // object. Either way, the resulting object will be used to initialize
	  // the regeneratorRuntime variable at the top of this file.
	   module.exports 
	));

	try {
	  regeneratorRuntime = runtime;
	} catch (accidentalStrictMode) {
	  // This module should not be running in strict mode, so the above
	  // assignment should always work unless something is misconfigured. Just
	  // in case runtime.js accidentally runs in strict mode, we can escape
	  // strict mode using a global Function call. This could conceivably fail
	  // if a Content Security Policy forbids using Function, but in that case
	  // the proper solution is to fix the accidental strict mode problem. If
	  // you've misconfigured your bundler to force strict mode and applied a
	  // CSP to forbid Function, and you're not willing to fix either of those
	  // problems, please detail your unique predicament in a GitHub issue.
	  Function("r", "regeneratorRuntime = r")(runtime);
	}
	});

	const {toString: toString$2} = Object.prototype;
	const escapeHtmlRegex = /["&<>]/;
	const _ = {
	  each: function each(obj, cb) {
	    if (obj) {
	      if (Array.isArray(obj)) {
	        obj.forEach(cb);
	      } else {
	        Object.keys(obj).forEach(key => {
	          cb(obj[key], key);
	        });
	      }
	    }
	  },

	  some: function some(obj, cb) {
	    if (obj) {
	      if (Array.isArray(obj)) {
	        return obj.some(cb);
	      }
	      return Object.keys(obj).some(key => cb(obj[key], key));
	    }
	    return false;
	  },

	  every: function every(obj, cb) {
	    if (obj) {
	      if (Array.isArray(obj)) {
	        return obj.every(cb);
	      }
	      return Object.keys(obj).every(key => cb(obj[key], key));
	    }
	    return true;
	  },

	  map: function map(obj, cb) {
	    if (obj) {
	      if (Array.isArray(obj)) {
	        return obj.map(cb);
	      }
	      return Object.keys(obj).map(key => cb(obj[key], key));
	    }
	    return [];
	  },

	  keyBy(a, p) {
	    return a.reduce((o, v) => {
	      o[v[p]] = v;
	      return o;
	    }, {});
	  },

	  isEqual: function isEqual(a, b) {
	    const aType = typeof a;
	    const bType = typeof b;
	    const aArray = Array.isArray(a);
	    const bArray = Array.isArray(b);

	    if (aType !== bType) {
	      return false;
	    }
	    switch (typeof a) {
	      case 'object':
	        if (aArray || bArray) {
	          if (aArray && bArray) {
	            return (
	              a.length === b.length &&
	              a.every((aValue, index) => {
	                const bValue = b[index];
	                return _.isEqual(aValue, bValue);
	              })
	            );
	          }
	          return false;
	        }
	        return _.every(a, (aValue, key) => {
	          const bValue = b[key];
	          return _.isEqual(aValue, bValue);
	        });

	      default:
	        return a === b;
	    }
	  },

	  escapeHtml(html) {
	    const regexResult = escapeHtmlRegex.exec(html);
	    if (!regexResult) return html;

	    let result = '';
	    let escape = '';
	    let lastIndex = 0;
	    let i = regexResult.index;
	    for (; i < html.length; i++) {
	      switch (html.charAt(i)) {
	        case '"':
	          escape = '&quot;';
	          break;
	        case '&':
	          escape = '&amp;';
	          break;
	        case '\'':
	          escape = '&apos;';
	          break;
	        case '<':
	          escape = '&lt;';
	          break;
	        case '>':
	          escape = '&gt;';
	          break;
	        default:
	          continue;
	      }
	      if (lastIndex !== i) result += html.substring(lastIndex, i);
	      lastIndex = i + 1;
	      result += escape;
	    }
	    if (lastIndex !== i) return result + html.substring(lastIndex, i);
	    return result;
	  },

	  strcmp(a, b) {
	    if (a < b) return -1;
	    if (a > b) return 1;
	    return 0;
	  },

	  isUndefined(val) {
	    return toString$2.call(val) === '[object Undefined]';
	  },

	  isObject(val) {
	    return toString$2.call(val) === '[object Object]';
	  },

	  deepMerge() {
	    const target = arguments[0] || {};
	    const {length} = arguments;
	    // eslint-disable-next-line one-var
	    let src, clone, copyIsArray;

	    function assignValue(val, key) {
	      src = target[key];
	      copyIsArray = Array.isArray(val);
	      if (_.isObject(val) || copyIsArray) {
	        if (copyIsArray) {
	          copyIsArray = false;
	          clone = src && Array.isArray(src) ? src : [];
	        } else {
	          clone = src && _.isObject(src) ? src : {};
	        }
	        target[key] = _.deepMerge(clone, val);
	      } else if (!_.isUndefined(val)) {
	        target[key] = val;
	      }
	    }

	    for (let i = 0; i < length; i++) {
	      _.each(arguments[i], assignValue);
	    }
	    return target;
	  },
	};

	var underDash = _;

	const addressRegex = /^[A-Z]+\d+$/;
	// =========================================================================
	// Column Letter to Number conversion
	const colCache = {
	  _dictionary: [
	    'A',
	    'B',
	    'C',
	    'D',
	    'E',
	    'F',
	    'G',
	    'H',
	    'I',
	    'J',
	    'K',
	    'L',
	    'M',
	    'N',
	    'O',
	    'P',
	    'Q',
	    'R',
	    'S',
	    'T',
	    'U',
	    'V',
	    'W',
	    'X',
	    'Y',
	    'Z',
	  ],
	  _l2nFill: 0,
	  _l2n: {},
	  _n2l: [],
	  _level(n) {
	    if (n <= 26) {
	      return 1;
	    }
	    if (n <= 26 * 26) {
	      return 2;
	    }
	    return 3;
	  },
	  _fill(level) {
	    let c;
	    let v;
	    let l1;
	    let l2;
	    let l3;
	    let n = 1;
	    if (level >= 4) {
	      throw new Error('Out of bounds. Excel supports columns from 1 to 16384');
	    }
	    if (this._l2nFill < 1 && level >= 1) {
	      while (n <= 26) {
	        c = this._dictionary[n - 1];
	        this._n2l[n] = c;
	        this._l2n[c] = n;
	        n++;
	      }
	      this._l2nFill = 1;
	    }
	    if (this._l2nFill < 2 && level >= 2) {
	      n = 27;
	      while (n <= 26 + (26 * 26)) {
	        v = n - (26 + 1);
	        l1 = v % 26;
	        l2 = Math.floor(v / 26);
	        c = this._dictionary[l2] + this._dictionary[l1];
	        this._n2l[n] = c;
	        this._l2n[c] = n;
	        n++;
	      }
	      this._l2nFill = 2;
	    }
	    if (this._l2nFill < 3 && level >= 3) {
	      n = 26 + (26 * 26) + 1;
	      while (n <= 16384) {
	        v = n - ((26 * 26) + 26 + 1);
	        l1 = v % 26;
	        l2 = Math.floor(v / 26) % 26;
	        l3 = Math.floor(v / (26 * 26));
	        c = this._dictionary[l3] + this._dictionary[l2] + this._dictionary[l1];
	        this._n2l[n] = c;
	        this._l2n[c] = n;
	        n++;
	      }
	      this._l2nFill = 3;
	    }
	  },
	  l2n(l) {
	    if (!this._l2n[l]) {
	      this._fill(l.length);
	    }
	    if (!this._l2n[l]) {
	      throw new Error(`Out of bounds. Invalid column letter: ${l}`);
	    }
	    return this._l2n[l];
	  },
	  n2l(n) {
	    if (n < 1 || n > 16384) {
	      throw new Error(`${n} is out of bounds. Excel supports columns from 1 to 16384`);
	    }
	    if (!this._n2l[n]) {
	      this._fill(this._level(n));
	    }
	    return this._n2l[n];
	  },

	  // =========================================================================
	  // Address processing
	  _hash: {},

	  // check if value looks like an address
	  validateAddress(value) {
	    if (!addressRegex.test(value)) {
	      throw new Error(`Invalid Address: ${value}`);
	    }
	    return true;
	  },

	  // convert address string into structure
	  decodeAddress(value) {
	    const addr = value.length < 5 && this._hash[value];
	    if (addr) {
	      return addr;
	    }
	    let hasCol = false;
	    let col = '';
	    let colNumber = 0;
	    let hasRow = false;
	    let row = '';
	    let rowNumber = 0;
	    for (let i = 0, char; i < value.length; i++) {
	      char = value.charCodeAt(i);
	      // col should before row
	      if (!hasRow && char >= 65 && char <= 90) {
	        // 65 = 'A'.charCodeAt(0)
	        // 90 = 'Z'.charCodeAt(0)
	        hasCol = true;
	        col += value[i];
	        // colNumber starts from 1
	        colNumber = (colNumber * 26) + char - 64;
	      } else if (char >= 48 && char <= 57) {
	        // 48 = '0'.charCodeAt(0)
	        // 57 = '9'.charCodeAt(0)
	        hasRow = true;
	        row += value[i];
	        // rowNumber starts from 0
	        rowNumber = (rowNumber * 10) + char - 48;
	      } else if (hasRow && hasCol && char !== 36) {
	        // 36 = '$'.charCodeAt(0)
	        break;
	      }
	    }
	    if (!hasCol) {
	      colNumber = undefined;
	    } else if (colNumber > 16384) {
	      throw new Error(`Out of bounds. Invalid column letter: ${col}`);
	    }
	    if (!hasRow) {
	      rowNumber = undefined;
	    }

	    // in case $row$col
	    value = col + row;

	    const address = {
	      address: value,
	      col: colNumber,
	      row: rowNumber,
	      $col$row: `$${col}$${row}`,
	    };

	    // mem fix - cache only the tl 100x100 square
	    if (colNumber <= 100 && rowNumber <= 100) {
	      this._hash[value] = address;
	      this._hash[address.$col$row] = address;
	    }

	    return address;
	  },

	  // convert r,c into structure (if only 1 arg, assume r is address string)
	  getAddress(r, c) {
	    if (c) {
	      const address = this.n2l(c) + r;
	      return this.decodeAddress(address);
	    }
	    return this.decodeAddress(r);
	  },

	  // convert [address], [tl:br] into address structures
	  decode(value) {
	    const parts = value.split(':');
	    if (parts.length === 2) {
	      const tl = this.decodeAddress(parts[0]);
	      const br = this.decodeAddress(parts[1]);
	      const result = {
	        top: Math.min(tl.row, br.row),
	        left: Math.min(tl.col, br.col),
	        bottom: Math.max(tl.row, br.row),
	        right: Math.max(tl.col, br.col),
	      };
	      // reconstruct tl, br and dimensions
	      result.tl = this.n2l(result.left) + result.top;
	      result.br = this.n2l(result.right) + result.bottom;
	      result.dimensions = `${result.tl}:${result.br}`;
	      return result;
	    }
	    return this.decodeAddress(value);
	  },

	  // convert [sheetName!][$]col[$]row[[$]col[$]row] into address or range structures
	  decodeEx(value) {
	    const groups = value.match(/(?:(?:(?:'((?:[^']|'')*)')|([^'^ !]*))!)?(.*)/);

	    const sheetName = groups[1] || groups[2]; // Qouted and unqouted groups
	    const reference = groups[3]; // Remaining address

	    const parts = reference.split(':');
	    if (parts.length > 1) {
	      let tl = this.decodeAddress(parts[0]);
	      let br = this.decodeAddress(parts[1]);
	      const top = Math.min(tl.row, br.row);
	      const left = Math.min(tl.col, br.col);
	      const bottom = Math.max(tl.row, br.row);
	      const right = Math.max(tl.col, br.col);

	      tl = this.n2l(left) + top;
	      br = this.n2l(right) + bottom;

	      return {
	        top,
	        left,
	        bottom,
	        right,
	        sheetName,
	        tl: {address: tl, col: left, row: top, $col$row: `$${this.n2l(left)}$${top}`, sheetName},
	        br: {
	          address: br,
	          col: right,
	          row: bottom,
	          $col$row: `$${this.n2l(right)}$${bottom}`,
	          sheetName,
	        },
	        dimensions: `${tl}:${br}`,
	      };
	    }
	    if (reference.startsWith('#')) {
	      return sheetName ? {sheetName, error: reference} : {error: reference};
	    }

	    const address = this.decodeAddress(reference);
	    return sheetName ? {sheetName, ...address} : address;
	  },

	  // convert row,col into address string
	  encodeAddress(row, col) {
	    return colCache.n2l(col) + row;
	  },

	  // convert row,col into string address or t,l,b,r into range
	  encode() {
	    switch (arguments.length) {
	      case 2:
	        return colCache.encodeAddress(arguments[0], arguments[1]);
	      case 4:
	        return `${colCache.encodeAddress(arguments[0], arguments[1])}:${colCache.encodeAddress(
          arguments[2],
          arguments[3]
        )}`;
	      default:
	        throw new Error('Can only encode with 2 or 4 arguments');
	    }
	  },

	  // return true if address is contained within range
	  inRange(range, address) {
	    const [left, top, , right, bottom] = range;
	    const [col, row] = address;
	    return col >= left && col <= right && row >= top && row <= bottom;
	  },
	};

	var colCache_1 = colCache;

	// used by worksheet to calculate sheet dimensions
	class Range {
	  constructor() {
	    this.decode(arguments);
	  }

	  setTLBR(t, l, b, r, s) {
	    if (arguments.length < 4) {
	      // setTLBR(tl, br, s)
	      const tl = colCache_1.decodeAddress(t);
	      const br = colCache_1.decodeAddress(l);
	      this.model = {
	        top: Math.min(tl.row, br.row),
	        left: Math.min(tl.col, br.col),
	        bottom: Math.max(tl.row, br.row),
	        right: Math.max(tl.col, br.col),
	        sheetName: b,
	      };

	      this.setTLBR(tl.row, tl.col, br.row, br.col, s);
	    } else {
	      // setTLBR(t, l, b, r, s)
	      this.model = {
	        top: Math.min(t, b),
	        left: Math.min(l, r),
	        bottom: Math.max(t, b),
	        right: Math.max(l, r),
	        sheetName: s,
	      };
	    }
	  }

	  decode(argv) {
	    switch (argv.length) {
	      case 5: // [t,l,b,r,s]
	        this.setTLBR(argv[0], argv[1], argv[2], argv[3], argv[4]);
	        break;
	      case 4: // [t,l,b,r]
	        this.setTLBR(argv[0], argv[1], argv[2], argv[3]);
	        break;

	      case 3: // [tl,br,s]
	        this.setTLBR(argv[0], argv[1], argv[2]);
	        break;
	      case 2: // [tl,br]
	        this.setTLBR(argv[0], argv[1]);
	        break;

	      case 1: {
	        const value = argv[0];
	        if (value instanceof Range) {
	          // copy constructor
	          this.model = {
	            top: value.model.top,
	            left: value.model.left,
	            bottom: value.model.bottom,
	            right: value.model.right,
	            sheetName: value.sheetName,
	          };
	        } else if (value instanceof Array) {
	          // an arguments array
	          this.decode(value);
	        } else if (value.top && value.left && value.bottom && value.right) {
	          // a model
	          this.model = {
	            top: value.top,
	            left: value.left,
	            bottom: value.bottom,
	            right: value.right,
	            sheetName: value.sheetName,
	          };
	        } else {
	          // [sheetName!]tl:br
	          const tlbr = colCache_1.decodeEx(value);
	          if (tlbr.top) {
	            this.model = {
	              top: tlbr.top,
	              left: tlbr.left,
	              bottom: tlbr.bottom,
	              right: tlbr.right,
	              sheetName: tlbr.sheetName,
	            };
	          } else {
	            this.model = {
	              top: tlbr.row,
	              left: tlbr.col,
	              bottom: tlbr.row,
	              right: tlbr.col,
	              sheetName: tlbr.sheetName,
	            };
	          }
	        }
	        break;
	      }

	      case 0:
	        this.model = {
	          top: 0,
	          left: 0,
	          bottom: 0,
	          right: 0,
	        };
	        break;

	      default:
	        throw new Error(`Invalid number of arguments to _getDimensions() - ${argv.length}`);
	    }
	  }

	  get top() {
	    return this.model.top || 1;
	  }

	  set top(value) {
	    this.model.top = value;
	  }

	  get left() {
	    return this.model.left || 1;
	  }

	  set left(value) {
	    this.model.left = value;
	  }

	  get bottom() {
	    return this.model.bottom || 1;
	  }

	  set bottom(value) {
	    this.model.bottom = value;
	  }

	  get right() {
	    return this.model.right || 1;
	  }

	  set right(value) {
	    this.model.right = value;
	  }

	  get sheetName() {
	    return this.model.sheetName;
	  }

	  set sheetName(value) {
	    this.model.sheetName = value;
	  }

	  get _serialisedSheetName() {
	    const {sheetName} = this.model;
	    if (sheetName) {
	      if (/^[a-zA-Z0-9]*$/.test(sheetName)) {
	        return `${sheetName}!`;
	      }
	      return `'${sheetName}'!`;
	    }
	    return '';
	  }

	  expand(top, left, bottom, right) {
	    if (!this.model.top || top < this.top) this.top = top;
	    if (!this.model.left || left < this.left) this.left = left;
	    if (!this.model.bottom || bottom > this.bottom) this.bottom = bottom;
	    if (!this.model.right || right > this.right) this.right = right;
	  }

	  expandRow(row) {
	    if (row) {
	      const {dimensions, number} = row;
	      if (dimensions) {
	        this.expand(number, dimensions.min, number, dimensions.max);
	      }
	    }
	  }

	  expandToAddress(addressStr) {
	    const address = colCache_1.decodeEx(addressStr);
	    this.expand(address.row, address.col, address.row, address.col);
	  }

	  get tl() {
	    return colCache_1.n2l(this.left) + this.top;
	  }

	  get $t$l() {
	    return `$${colCache_1.n2l(this.left)}$${this.top}`;
	  }

	  get br() {
	    return colCache_1.n2l(this.right) + this.bottom;
	  }

	  get $b$r() {
	    return `$${colCache_1.n2l(this.right)}$${this.bottom}`;
	  }

	  get range() {
	    return `${this._serialisedSheetName + this.tl}:${this.br}`;
	  }

	  get $range() {
	    return `${this._serialisedSheetName + this.$t$l}:${this.$b$r}`;
	  }

	  get shortRange() {
	    return this.count > 1 ? this.range : this._serialisedSheetName + this.tl;
	  }

	  get $shortRange() {
	    return this.count > 1 ? this.$range : this._serialisedSheetName + this.$t$l;
	  }

	  get count() {
	    return (1 + this.bottom - this.top) * (1 + this.right - this.left);
	  }

	  toString() {
	    return this.range;
	  }

	  intersects(other) {
	    if (other.sheetName && this.sheetName && other.sheetName !== this.sheetName) return false;
	    if (other.bottom < this.top) return false;
	    if (other.top > this.bottom) return false;
	    if (other.right < this.left) return false;
	    if (other.left > this.right) return false;
	    return true;
	  }

	  contains(addressStr) {
	    const address = colCache_1.decodeEx(addressStr);
	    return this.containsEx(address);
	  }

	  containsEx(address) {
	    if (address.sheetName && this.sheetName && address.sheetName !== this.sheetName) return false;
	    return (
	      address.row >= this.top &&
	      address.row <= this.bottom &&
	      address.col >= this.left &&
	      address.col <= this.right
	    );
	  }

	  forEachAddress(cb) {
	    for (let col = this.left; col <= this.right; col++) {
	      for (let row = this.top; row <= this.bottom; row++) {
	        cb(colCache_1.encodeAddress(row, col), row, col);
	      }
	    }
	  }
	}

	var range = Range;

	var enums = {
	  ValueType: {
	    Null: 0,
	    Merge: 1,
	    Number: 2,
	    String: 3,
	    Date: 4,
	    Hyperlink: 5,
	    Formula: 6,
	    SharedString: 7,
	    RichText: 8,
	    Boolean: 9,
	    Error: 10,
	  },
	  FormulaType: {
	    None: 0,
	    Master: 1,
	    Shared: 2,
	  },
	  RelationshipType: {
	    None: 0,
	    OfficeDocument: 1,
	    Worksheet: 2,
	    CalcChain: 3,
	    SharedStrings: 4,
	    Styles: 5,
	    Theme: 6,
	    Hyperlink: 7,
	  },
	  DocumentType: {
	    Xlsx: 1,
	  },
	  ReadingOrder: {
	    LeftToRight: 1,
	    RightToLeft: 2,
	  },
	  ErrorValue: {
	    NotApplicable: '#N/A',
	    Ref: '#REF!',
	    Name: '#NAME?',
	    DivZero: '#DIV/0!',
	    Null: '#NULL!',
	    Value: '#VALUE!',
	    Num: '#NUM!',
	  },
	};

	// const cellRefRegex = /(([a-z_\-0-9]*)!)?[$]?([a-z]+)[$]?([1-9][0-9]*)/i;
	const replacementCandidateRx = /(([a-z_\-0-9]*)!)?([a-z0-9_$]{2,})([(])?/gi;
	const CRrx = /^([$])?([a-z]+)([$])?([1-9][0-9]*)$/i;

	function slideFormula(formula, fromCell, toCell) {
	  const offset = colCache_1.decode(fromCell);
	  const to = colCache_1.decode(toCell);
	  return formula.replace(
	    replacementCandidateRx,
	    (refMatch, sheet, sheetMaybe, addrPart, trailingParen) => {
	      if (trailingParen) {
	        return refMatch;
	      }
	      const match = CRrx.exec(addrPart);
	      if (match) {
	        const colDollar = match[1];
	        const colStr = match[2].toUpperCase();
	        const rowDollar = match[3];
	        const rowStr = match[4];
	        if (colStr.length > 3 || (colStr.length === 3 && colStr > 'XFD')) {
	          // > XFD is the highest col number in excel 2007 and beyond, so this is a named range
	          return refMatch;
	        }
	        let col = colCache_1.l2n(colStr);
	        let row = parseInt(rowStr, 10);
	        if (!colDollar) {
	          col += to.col - offset.col;
	        }
	        if (!rowDollar) {
	          row += to.row - offset.row;
	        }
	        const res = (sheet || '') + (colDollar || '') + colCache_1.n2l(col) + (rowDollar || '') + row;
	        return res;
	      }
	      return refMatch;
	    }
	  );
	}

	var sharedFormula = {
	  slideFormula,
	};

	class Note {
	  constructor(note) {
	    this.note = note;
	  }

	  get model() {
	    let value = null;
	    switch (typeof this.note) {
	      case 'string':
	        value = {
	          type: 'note',
	          note: {
	            texts: [
	              {
	                text: this.note,
	              },
	            ],
	          },
	        };
	        break;
	      default:
	        value = {
	          type: 'note',
	          note: this.note,
	        };
	        break;
	    }
	    // Suitable for all cell comments
	    return underDash.deepMerge({}, Note.DEFAULT_CONFIGS, value);
	  }

	  set model(value) {
	    const {note} = value;
	    const {texts} = note;
	    if (texts.length === 1 && Object.keys(texts[0]).length === 1) {
	      this.note = texts[0].text;
	    } else {
	      this.note = note;
	    }
	  }

	  static fromModel(model) {
	    const note = new Note();
	    note.model = model;
	    return note;
	  }
	}

	Note.DEFAULT_CONFIGS = {
	  note: {
	    margins: {
	      insetmode: 'auto',
	      inset: [0.13, 0.13, 0.25, 0.25],
	    },
	    protection: {
	      locked: 'True',
	      lockText: 'True',
	    },
	    editAs: 'absolute',
	  },
	};

	var note = Note;

	/* eslint-disable max-classes-per-file */



	const {slideFormula: slideFormula$1} = sharedFormula;

	// Cell requirements
	//  Operate inside a worksheet
	//  Store and retrieve a value with a range of types: text, number, date, hyperlink, reference, formula, etc.
	//  Manage/use and manipulate cell format either as local to cell or inherited from column or row.

	class Cell {
	  constructor(row, column, address) {
	    if (!row || !column) {
	      throw new Error('A Cell needs a Row');
	    }

	    this._row = row;
	    this._column = column;

	    colCache_1.validateAddress(address);
	    this._address = address;

	    // TODO: lazy evaluation of this._value
	    this._value = Value.create(Cell.Types.Null, this);

	    this.style = this._mergeStyle(row.style, column.style, {});

	    this._mergeCount = 0;
	  }

	  get worksheet() {
	    return this._row.worksheet;
	  }

	  get workbook() {
	    return this._row.worksheet.workbook;
	  }

	  // help GC by removing cyclic (and other) references
	  destroy() {
	    delete this.style;
	    delete this._value;
	    delete this._row;
	    delete this._column;
	    delete this._address;
	  }

	  // =========================================================================
	  // Styles stuff
	  get numFmt() {
	    return this.style.numFmt;
	  }

	  set numFmt(value) {
	    this.style.numFmt = value;
	  }

	  get font() {
	    return this.style.font;
	  }

	  set font(value) {
	    this.style.font = value;
	  }

	  get alignment() {
	    return this.style.alignment;
	  }

	  set alignment(value) {
	    this.style.alignment = value;
	  }

	  get border() {
	    return this.style.border;
	  }

	  set border(value) {
	    this.style.border = value;
	  }

	  get fill() {
	    return this.style.fill;
	  }

	  set fill(value) {
	    this.style.fill = value;
	  }

	  get protection() {
	    return this.style.protection;
	  }

	  set protection(value) {
	    this.style.protection = value;
	  }

	  _mergeStyle(rowStyle, colStyle, style) {
	    const numFmt = (rowStyle && rowStyle.numFmt) || (colStyle && colStyle.numFmt);
	    if (numFmt) style.numFmt = numFmt;

	    const font = (rowStyle && rowStyle.font) || (colStyle && colStyle.font);
	    if (font) style.font = font;

	    const alignment = (rowStyle && rowStyle.alignment) || (colStyle && colStyle.alignment);
	    if (alignment) style.alignment = alignment;

	    const border = (rowStyle && rowStyle.border) || (colStyle && colStyle.border);
	    if (border) style.border = border;

	    const fill = (rowStyle && rowStyle.fill) || (colStyle && colStyle.fill);
	    if (fill) style.fill = fill;

	    const protection = (rowStyle && rowStyle.protection) || (colStyle && colStyle.protection);
	    if (protection) style.protection = protection;

	    return style;
	  }

	  // =========================================================================
	  // return the address for this cell
	  get address() {
	    return this._address;
	  }

	  get row() {
	    return this._row.number;
	  }

	  get col() {
	    return this._column.number;
	  }

	  get $col$row() {
	    return `$${this._column.letter}$${this.row}`;
	  }

	  // =========================================================================
	  // Value stuff

	  get type() {
	    return this._value.type;
	  }

	  get effectiveType() {
	    return this._value.effectiveType;
	  }

	  toCsvString() {
	    return this._value.toCsvString();
	  }

	  // =========================================================================
	  // Merge stuff

	  addMergeRef() {
	    this._mergeCount++;
	  }

	  releaseMergeRef() {
	    this._mergeCount--;
	  }

	  get isMerged() {
	    return this._mergeCount > 0 || this.type === Cell.Types.Merge;
	  }

	  merge(master, ignoreStyle) {
	    this._value.release();
	    this._value = Value.create(Cell.Types.Merge, this, master);
	    if (!ignoreStyle) {
	      this.style = master.style;
	    }
	  }

	  unmerge() {
	    if (this.type === Cell.Types.Merge) {
	      this._value.release();
	      this._value = Value.create(Cell.Types.Null, this);
	      this.style = this._mergeStyle(this._row.style, this._column.style, {});
	    }
	  }

	  isMergedTo(master) {
	    if (this._value.type !== Cell.Types.Merge) return false;
	    return this._value.isMergedTo(master);
	  }

	  get master() {
	    if (this.type === Cell.Types.Merge) {
	      return this._value.master;
	    }
	    return this; // an unmerged cell is its own master
	  }

	  get isHyperlink() {
	    return this._value.type === Cell.Types.Hyperlink;
	  }

	  get hyperlink() {
	    return this._value.hyperlink;
	  }

	  // return the value
	  get value() {
	    return this._value.value;
	  }

	  // set the value - can be number, string or raw
	  set value(v) {
	    // special case - merge cells set their master's value
	    if (this.type === Cell.Types.Merge) {
	      this._value.master.value = v;
	      return;
	    }

	    this._value.release();

	    // assign value
	    this._value = Value.create(Value.getType(v), this, v);
	  }

	  get note() {
	    return this._comment && this._comment.note;
	  }

	  set note(note$1) {
	    this._comment = new note(note$1);
	  }

	  get text() {
	    return this._value.toString();
	  }

	  get html() {
	    return underDash.escapeHtml(this.text);
	  }

	  toString() {
	    return this.text;
	  }

	  _upgradeToHyperlink(hyperlink) {
	    // if this cell is a string, turn it into a Hyperlink
	    if (this.type === Cell.Types.String) {
	      this._value = Value.create(Cell.Types.Hyperlink, this, {
	        text: this._value.value,
	        hyperlink,
	      });
	    }
	  }

	  // =========================================================================
	  // Formula stuff
	  get formula() {
	    return this._value.formula;
	  }

	  get result() {
	    return this._value.result;
	  }

	  get formulaType() {
	    return this._value.formulaType;
	  }

	  // =========================================================================
	  // Name stuff
	  get fullAddress() {
	    const {worksheet} = this._row;
	    return {
	      sheetName: worksheet.name,
	      address: this.address,
	      row: this.row,
	      col: this.col,
	    };
	  }

	  get name() {
	    return this.names[0];
	  }

	  set name(value) {
	    this.names = [value];
	  }

	  get names() {
	    return this.workbook.definedNames.getNamesEx(this.fullAddress);
	  }

	  set names(value) {
	    const {definedNames} = this.workbook;
	    definedNames.removeAllNames(this.fullAddress);
	    value.forEach(name => {
	      definedNames.addEx(this.fullAddress, name);
	    });
	  }

	  addName(name) {
	    this.workbook.definedNames.addEx(this.fullAddress, name);
	  }

	  removeName(name) {
	    this.workbook.definedNames.removeEx(this.fullAddress, name);
	  }

	  removeAllNames() {
	    this.workbook.definedNames.removeAllNames(this.fullAddress);
	  }

	  // =========================================================================
	  // Data Validation stuff
	  get _dataValidations() {
	    return this.worksheet.dataValidations;
	  }

	  get dataValidation() {
	    return this._dataValidations.find(this.address);
	  }

	  set dataValidation(value) {
	    this._dataValidations.add(this.address, value);
	  }

	  // =========================================================================
	  // Model stuff

	  get model() {
	    const {model} = this._value;
	    model.style = this.style;
	    if (this._comment) {
	      model.comment = this._comment.model;
	    }
	    return model;
	  }

	  set model(value) {
	    this._value.release();
	    this._value = Value.create(value.type, this);
	    this._value.model = value;

	    if (value.comment) {
	      switch (value.comment.type) {
	        case 'note':
	          this._comment = note.fromModel(value.comment);
	          break;
	      }
	    }

	    if (value.style) {
	      this.style = value.style;
	    } else {
	      this.style = {};
	    }
	  }
	}
	Cell.Types = enums.ValueType;

	// =============================================================================
	// Internal Value Types

	class NullValue {
	  constructor(cell) {
	    this.model = {
	      address: cell.address,
	      type: Cell.Types.Null,
	    };
	  }

	  get value() {
	    return null;
	  }

	  set value(value) {
	    // nothing to do
	  }

	  get type() {
	    return Cell.Types.Null;
	  }

	  get effectiveType() {
	    return Cell.Types.Null;
	  }

	  get address() {
	    return this.model.address;
	  }

	  set address(value) {
	    this.model.address = value;
	  }

	  toCsvString() {
	    return '';
	  }

	  release() {}

	  toString() {
	    return '';
	  }
	}

	class NumberValue {
	  constructor(cell, value) {
	    this.model = {
	      address: cell.address,
	      type: Cell.Types.Number,
	      value,
	    };
	  }

	  get value() {
	    return this.model.value;
	  }

	  set value(value) {
	    this.model.value = value;
	  }

	  get type() {
	    return Cell.Types.Number;
	  }

	  get effectiveType() {
	    return Cell.Types.Number;
	  }

	  get address() {
	    return this.model.address;
	  }

	  set address(value) {
	    this.model.address = value;
	  }

	  toCsvString() {
	    return this.model.value.toString();
	  }

	  release() {}

	  toString() {
	    return this.model.value.toString();
	  }
	}

	class StringValue {
	  constructor(cell, value) {
	    this.model = {
	      address: cell.address,
	      type: Cell.Types.String,
	      value,
	    };
	  }

	  get value() {
	    return this.model.value;
	  }

	  set value(value) {
	    this.model.value = value;
	  }

	  get type() {
	    return Cell.Types.String;
	  }

	  get effectiveType() {
	    return Cell.Types.String;
	  }

	  get address() {
	    return this.model.address;
	  }

	  set address(value) {
	    this.model.address = value;
	  }

	  toCsvString() {
	    return `"${this.model.value.replace(/"/g, '""')}"`;
	  }

	  release() {}

	  toString() {
	    return this.model.value;
	  }
	}

	class RichTextValue {
	  constructor(cell, value) {
	    this.model = {
	      address: cell.address,
	      type: Cell.Types.String,
	      value,
	    };
	  }

	  get value() {
	    return this.model.value;
	  }

	  set value(value) {
	    this.model.value = value;
	  }

	  toString() {
	    return this.model.value.richText.map(t => t.text).join('');
	  }

	  get type() {
	    return Cell.Types.RichText;
	  }

	  get effectiveType() {
	    return Cell.Types.RichText;
	  }

	  get address() {
	    return this.model.address;
	  }

	  set address(value) {
	    this.model.address = value;
	  }

	  toCsvString() {
	    return `"${this.text.replace(/"/g, '""')}"`;
	  }

	  release() {}
	}

	class DateValue {
	  constructor(cell, value) {
	    this.model = {
	      address: cell.address,
	      type: Cell.Types.Date,
	      value,
	    };
	  }

	  get value() {
	    return this.model.value;
	  }

	  set value(value) {
	    this.model.value = value;
	  }

	  get type() {
	    return Cell.Types.Date;
	  }

	  get effectiveType() {
	    return Cell.Types.Date;
	  }

	  get address() {
	    return this.model.address;
	  }

	  set address(value) {
	    this.model.address = value;
	  }

	  toCsvString() {
	    return this.model.value.toISOString();
	  }

	  release() {}

	  toString() {
	    return this.model.value.toString();
	  }
	}

	class HyperlinkValue {
	  constructor(cell, value) {
	    this.model = {
	      address: cell.address,
	      type: Cell.Types.Hyperlink,
	      text: value ? value.text : undefined,
	      hyperlink: value ? value.hyperlink : undefined,
	    };
	    if (value && value.tooltip) {
	      this.model.tooltip = value.tooltip;
	    }
	  }

	  get value() {
	    const v = {
	      text: this.model.text,
	      hyperlink: this.model.hyperlink,
	    };
	    if (this.model.tooltip) {
	      v.tooltip = this.model.tooltip;
	    }
	    return v;
	  }

	  set value(value) {
	    this.model = {
	      text: value.text,
	      hyperlink: value.hyperlink,
	    };
	    if (value.tooltip) {
	      this.model.tooltip = value.tooltip;
	    }
	  }

	  get text() {
	    return this.model.text;
	  }

	  set text(value) {
	    this.model.text = value;
	  }

	  /*
	  get tooltip() {
	    return this.model.tooltip;
	  }

	  set tooltip(value) {
	    this.model.tooltip = value;
	  } */

	  get hyperlink() {
	    return this.model.hyperlink;
	  }

	  set hyperlink(value) {
	    this.model.hyperlink = value;
	  }

	  get type() {
	    return Cell.Types.Hyperlink;
	  }

	  get effectiveType() {
	    return Cell.Types.Hyperlink;
	  }

	  get address() {
	    return this.model.address;
	  }

	  set address(value) {
	    this.model.address = value;
	  }

	  toCsvString() {
	    return this.model.hyperlink;
	  }

	  release() {}

	  toString() {
	    return this.model.text;
	  }
	}

	class MergeValue {
	  constructor(cell, master) {
	    this.model = {
	      address: cell.address,
	      type: Cell.Types.Merge,
	      master: master ? master.address : undefined,
	    };
	    this._master = master;
	    if (master) {
	      master.addMergeRef();
	    }
	  }

	  get value() {
	    return this._master.value;
	  }

	  set value(value) {
	    if (value instanceof Cell) {
	      if (this._master) {
	        this._master.releaseMergeRef();
	      }
	      value.addMergeRef();
	      this._master = value;
	    } else {
	      this._master.value = value;
	    }
	  }

	  isMergedTo(master) {
	    return master === this._master;
	  }

	  get master() {
	    return this._master;
	  }

	  get type() {
	    return Cell.Types.Merge;
	  }

	  get effectiveType() {
	    return this._master.effectiveType;
	  }

	  get address() {
	    return this.model.address;
	  }

	  set address(value) {
	    this.model.address = value;
	  }

	  toCsvString() {
	    return '';
	  }

	  release() {
	    this._master.releaseMergeRef();
	  }

	  toString() {
	    return this.value.toString();
	  }
	}

	class FormulaValue {
	  constructor(cell, value) {
	    this.cell = cell;

	    this.model = {
	      address: cell.address,
	      type: Cell.Types.Formula,
	      shareType: value ? value.shareType : undefined,
	      ref: value ? value.ref : undefined,
	      formula: value ? value.formula : undefined,
	      sharedFormula: value ? value.sharedFormula : undefined,
	      result: value ? value.result : undefined,
	    };
	  }

	  _copyModel(model) {
	    const copy = {};
	    const cp = name => {
	      const value = model[name];
	      if (value) {
	        copy[name] = value;
	      }
	    };
	    cp('formula');
	    cp('result');
	    cp('ref');
	    cp('shareType');
	    cp('sharedFormula');
	    return copy;
	  }

	  get value() {
	    return this._copyModel(this.model);
	  }

	  set value(value) {
	    this.model = this._copyModel(value);
	  }

	  validate(value) {
	    switch (Value.getType(value)) {
	      case Cell.Types.Null:
	      case Cell.Types.String:
	      case Cell.Types.Number:
	      case Cell.Types.Date:
	        break;
	      case Cell.Types.Hyperlink:
	      case Cell.Types.Formula:
	      default:
	        throw new Error('Cannot process that type of result value');
	    }
	  }

	  get dependencies() {
	    // find all the ranges and cells mentioned in the formula
	    const ranges = this.formula.match(/([a-zA-Z0-9]+!)?[A-Z]{1,3}\d{1,4}:[A-Z]{1,3}\d{1,4}/g);
	    const cells = this.formula
	      .replace(/([a-zA-Z0-9]+!)?[A-Z]{1,3}\d{1,4}:[A-Z]{1,3}\d{1,4}/g, '')
	      .match(/([a-zA-Z0-9]+!)?[A-Z]{1,3}\d{1,4}/g);
	    return {
	      ranges,
	      cells,
	    };
	  }

	  get formula() {
	    return this.model.formula || this._getTranslatedFormula();
	  }

	  set formula(value) {
	    this.model.formula = value;
	  }

	  get formulaType() {
	    if (this.model.formula) {
	      return enums.FormulaType.Master;
	    }
	    if (this.model.sharedFormula) {
	      return enums.FormulaType.Shared;
	    }
	    return enums.FormulaType.None;
	  }

	  get result() {
	    return this.model.result;
	  }

	  set result(value) {
	    this.model.result = value;
	  }

	  get type() {
	    return Cell.Types.Formula;
	  }

	  get effectiveType() {
	    const v = this.model.result;
	    if (v === null || v === undefined) {
	      return enums.ValueType.Null;
	    }
	    if (v instanceof String || typeof v === 'string') {
	      return enums.ValueType.String;
	    }
	    if (typeof v === 'number') {
	      return enums.ValueType.Number;
	    }
	    if (v instanceof Date) {
	      return enums.ValueType.Date;
	    }
	    if (v.text && v.hyperlink) {
	      return enums.ValueType.Hyperlink;
	    }
	    if (v.formula) {
	      return enums.ValueType.Formula;
	    }

	    return enums.ValueType.Null;
	  }

	  get address() {
	    return this.model.address;
	  }

	  set address(value) {
	    this.model.address = value;
	  }

	  _getTranslatedFormula() {
	    if (!this._translatedFormula && this.model.sharedFormula) {
	      const {worksheet} = this.cell;
	      const master = worksheet.findCell(this.model.sharedFormula);
	      this._translatedFormula =
	        master && slideFormula$1(master.formula, master.address, this.model.address);
	    }
	    return this._translatedFormula;
	  }

	  toCsvString() {
	    return `${this.model.result || ''}`;
	  }

	  release() {}

	  toString() {
	    return this.model.result ? this.model.result.toString() : '';
	  }
	}

	class SharedStringValue {
	  constructor(cell, value) {
	    this.model = {
	      address: cell.address,
	      type: Cell.Types.SharedString,
	      value,
	    };
	  }

	  get value() {
	    return this.model.value;
	  }

	  set value(value) {
	    this.model.value = value;
	  }

	  get type() {
	    return Cell.Types.SharedString;
	  }

	  get effectiveType() {
	    return Cell.Types.SharedString;
	  }

	  get address() {
	    return this.model.address;
	  }

	  set address(value) {
	    this.model.address = value;
	  }

	  toCsvString() {
	    return this.model.value.toString();
	  }

	  release() {}

	  toString() {
	    return this.model.value.toString();
	  }
	}

	class BooleanValue {
	  constructor(cell, value) {
	    this.model = {
	      address: cell.address,
	      type: Cell.Types.Boolean,
	      value,
	    };
	  }

	  get value() {
	    return this.model.value;
	  }

	  set value(value) {
	    this.model.value = value;
	  }

	  get type() {
	    return Cell.Types.Boolean;
	  }

	  get effectiveType() {
	    return Cell.Types.Boolean;
	  }

	  get address() {
	    return this.model.address;
	  }

	  set address(value) {
	    this.model.address = value;
	  }

	  toCsvString() {
	    return this.model.value ? 1 : 0;
	  }

	  release() {}

	  toString() {
	    return this.model.value.toString();
	  }
	}

	class ErrorValue {
	  constructor(cell, value) {
	    this.model = {
	      address: cell.address,
	      type: Cell.Types.Error,
	      value,
	    };
	  }

	  get value() {
	    return this.model.value;
	  }

	  set value(value) {
	    this.model.value = value;
	  }

	  get type() {
	    return Cell.Types.Error;
	  }

	  get effectiveType() {
	    return Cell.Types.Error;
	  }

	  get address() {
	    return this.model.address;
	  }

	  set address(value) {
	    this.model.address = value;
	  }

	  toCsvString() {
	    return this.toString();
	  }

	  release() {}

	  toString() {
	    return this.model.value.error.toString();
	  }
	}

	class JSONValue {
	  constructor(cell, value) {
	    this.model = {
	      address: cell.address,
	      type: Cell.Types.String,
	      value: JSON.stringify(value),
	      rawValue: value,
	    };
	  }

	  get value() {
	    return this.model.rawValue;
	  }

	  set value(value) {
	    this.model.rawValue = value;
	    this.model.value = JSON.stringify(value);
	  }

	  get type() {
	    return Cell.Types.String;
	  }

	  get effectiveType() {
	    return Cell.Types.String;
	  }

	  get address() {
	    return this.model.address;
	  }

	  set address(value) {
	    this.model.address = value;
	  }

	  toCsvString() {
	    return this.model.value;
	  }

	  release() {}

	  toString() {
	    return this.model.value;
	  }
	}

	// Value is a place to hold common static Value type functions
	const Value = {
	  getType(value) {
	    if (value === null || value === undefined) {
	      return Cell.Types.Null;
	    }
	    if (value instanceof String || typeof value === 'string') {
	      return Cell.Types.String;
	    }
	    if (typeof value === 'number') {
	      return Cell.Types.Number;
	    }
	    if (typeof value === 'boolean') {
	      return Cell.Types.Boolean;
	    }
	    if (value instanceof Date) {
	      return Cell.Types.Date;
	    }
	    if (value.text && value.hyperlink) {
	      return Cell.Types.Hyperlink;
	    }
	    if (value.formula || value.sharedFormula) {
	      return Cell.Types.Formula;
	    }
	    if (value.richText) {
	      return Cell.Types.RichText;
	    }
	    if (value.sharedString) {
	      return Cell.Types.SharedString;
	    }
	    if (value.error) {
	      return Cell.Types.Error;
	    }
	    return Cell.Types.JSON;
	  },

	  // map valueType to constructor
	  types: [
	    {t: Cell.Types.Null, f: NullValue},
	    {t: Cell.Types.Number, f: NumberValue},
	    {t: Cell.Types.String, f: StringValue},
	    {t: Cell.Types.Date, f: DateValue},
	    {t: Cell.Types.Hyperlink, f: HyperlinkValue},
	    {t: Cell.Types.Formula, f: FormulaValue},
	    {t: Cell.Types.Merge, f: MergeValue},
	    {t: Cell.Types.JSON, f: JSONValue},
	    {t: Cell.Types.SharedString, f: SharedStringValue},
	    {t: Cell.Types.RichText, f: RichTextValue},
	    {t: Cell.Types.Boolean, f: BooleanValue},
	    {t: Cell.Types.Error, f: ErrorValue},
	  ].reduce((p, t) => {
	    p[t.t] = t.f;
	    return p;
	  }, []),

	  create(type, cell, value) {
	    const T = this.types[type];
	    if (!T) {
	      throw new Error(`Could not create Value of type ${type}`);
	    }
	    return new T(cell, value);
	  },
	};

	var cell = Cell;

	class Row {
	  constructor(worksheet, number) {
	    this._worksheet = worksheet;
	    this._number = number;
	    this._cells = [];
	    this.style = {};
	    this.outlineLevel = 0;
	  }

	  // return the row number
	  get number() {
	    return this._number;
	  }

	  get worksheet() {
	    return this._worksheet;
	  }

	  // Inform Streaming Writer that this row (and all rows before it) are complete
	  // and ready to write. Has no effect on Worksheet document
	  commit() {
	    this._worksheet._commitRow(this); // eslint-disable-line no-underscore-dangle
	  }

	  // helps GC by breaking cyclic references
	  destroy() {
	    delete this._worksheet;
	    delete this._cells;
	    delete this.style;
	  }

	  findCell(colNumber) {
	    return this._cells[colNumber - 1];
	  }

	  // given {address, row, col}, find or create new cell
	  getCellEx(address) {
	    let cell$1 = this._cells[address.col - 1];
	    if (!cell$1) {
	      const column = this._worksheet.getColumn(address.col);
	      cell$1 = new cell(this, column, address.address);
	      this._cells[address.col - 1] = cell$1;
	    }
	    return cell$1;
	  }

	  // get cell by key, letter or column number
	  getCell(col) {
	    if (typeof col === 'string') {
	      // is it a key?
	      const column = this._worksheet.getColumnKey(col);
	      if (column) {
	        col = column.number;
	      } else {
	        col = colCache_1.l2n(col);
	      }
	    }
	    return (
	      this._cells[col - 1] ||
	      this.getCellEx({
	        address: colCache_1.encodeAddress(this._number, col),
	        row: this._number,
	        col,
	      })
	    );
	  }

	  // remove cell(s) and shift all higher cells down by count
	  splice(start, count, ...inserts) {
	    const nKeep = start + count;
	    const nExpand = inserts.length - count;
	    const nEnd = this._cells.length;
	    let i;
	    let cSrc;
	    let cDst;

	    if (nExpand < 0) {
	      // remove cells
	      for (i = start + inserts.length; i <= nEnd; i++) {
	        cDst = this._cells[i - 1];
	        cSrc = this._cells[i - nExpand - 1];
	        if (cSrc) {
	          cDst = this.getCell(i);
	          cDst.value = cSrc.value;
	          cDst.style = cSrc.style;
	          // eslint-disable-next-line no-underscore-dangle
	          cDst._comment = cSrc._comment;
	        } else if (cDst) {
	          cDst.value = null;
	          cDst.style = {};
	          // eslint-disable-next-line no-underscore-dangle
	          cDst._comment = undefined;
	        }
	      }
	    } else if (nExpand > 0) {
	      // insert new cells
	      for (i = nEnd; i >= nKeep; i--) {
	        cSrc = this._cells[i - 1];
	        if (cSrc) {
	          cDst = this.getCell(i + nExpand);
	          cDst.value = cSrc.value;
	          cDst.style = cSrc.style;
	          // eslint-disable-next-line no-underscore-dangle
	          cDst._comment = cSrc._comment;
	        } else {
	          this._cells[i + nExpand - 1] = undefined;
	        }
	      }
	    }

	    // now add the new values
	    for (i = 0; i < inserts.length; i++) {
	      cDst = this.getCell(start + i);
	      cDst.value = inserts[i];
	      cDst.style = {};
	      // eslint-disable-next-line no-underscore-dangle
	      cDst._comment = undefined;
	    }
	  }

	  // Iterate over all non-null cells in this row
	  eachCell(options, iteratee) {
	    if (!iteratee) {
	      iteratee = options;
	      options = null;
	    }
	    if (options && options.includeEmpty) {
	      const n = this._cells.length;
	      for (let i = 1; i <= n; i++) {
	        iteratee(this.getCell(i), i);
	      }
	    } else {
	      this._cells.forEach((cell, index) => {
	        if (cell && cell.type !== enums.ValueType.Null) {
	          iteratee(cell, index + 1);
	        }
	      });
	    }
	  }

	  // ===========================================================================
	  // Page Breaks
	  addPageBreak(lft, rght) {
	    const ws = this._worksheet;
	    const left = Math.max(0, lft - 1) || 0;
	    const right = Math.max(0, rght - 1) || 16838;
	    const pb = {
	      id: this._number,
	      max: right,
	      man: 1,
	    };
	    if (left) pb.min = left;

	    ws.rowBreaks.push(pb);
	  }

	  // return a sparse array of cell values
	  get values() {
	    const values = [];
	    this._cells.forEach(cell => {
	      if (cell && cell.type !== enums.ValueType.Null) {
	        values[cell.col] = cell.value;
	      }
	    });
	    return values;
	  }

	  // set the values by contiguous or sparse array, or by key'd object literal
	  set values(value) {
	    // this operation is not additive - any prior cells are removed
	    this._cells = [];
	    if (!value) ; else if (value instanceof Array) {
	      let offset = 0;
	      if (value.hasOwnProperty('0')) {
	        // contiguous array - start at column 1
	        offset = 1;
	      }
	      value.forEach((item, index) => {
	        if (item !== undefined) {
	          this.getCellEx({
	            address: colCache_1.encodeAddress(this._number, index + offset),
	            row: this._number,
	            col: index + offset,
	          }).value = item;
	        }
	      });
	    } else {
	      // assume object with column keys
	      this._worksheet.eachColumnKey((column, key) => {
	        if (value[key] !== undefined) {
	          this.getCellEx({
	            address: colCache_1.encodeAddress(this._number, column.number),
	            row: this._number,
	            col: column.number,
	          }).value = value[key];
	        }
	      });
	    }
	  }

	  // returns true if the row includes at least one cell with a value
	  get hasValues() {
	    return underDash.some(this._cells, cell => cell && cell.type !== enums.ValueType.Null);
	  }

	  get cellCount() {
	    return this._cells.length;
	  }

	  get actualCellCount() {
	    let count = 0;
	    this.eachCell(() => {
	      count++;
	    });
	    return count;
	  }

	  // get the min and max column number for the non-null cells in this row or null
	  get dimensions() {
	    let min = 0;
	    let max = 0;
	    this._cells.forEach(cell => {
	      if (cell && cell.type !== enums.ValueType.Null) {
	        if (!min || min > cell.col) {
	          min = cell.col;
	        }
	        if (max < cell.col) {
	          max = cell.col;
	        }
	      }
	    });
	    return min > 0
	      ? {
	          min,
	          max,
	        }
	      : null;
	  }

	  // =========================================================================
	  // styles
	  _applyStyle(name, value) {
	    this.style[name] = value;
	    this._cells.forEach(cell => {
	      if (cell) {
	        cell[name] = value;
	      }
	    });
	    return value;
	  }

	  get numFmt() {
	    return this.style.numFmt;
	  }

	  set numFmt(value) {
	    this._applyStyle('numFmt', value);
	  }

	  get font() {
	    return this.style.font;
	  }

	  set font(value) {
	    this._applyStyle('font', value);
	  }

	  get alignment() {
	    return this.style.alignment;
	  }

	  set alignment(value) {
	    this._applyStyle('alignment', value);
	  }

	  get protection() {
	    return this.style.protection;
	  }

	  set protection(value) {
	    this._applyStyle('protection', value);
	  }

	  get border() {
	    return this.style.border;
	  }

	  set border(value) {
	    this._applyStyle('border', value);
	  }

	  get fill() {
	    return this.style.fill;
	  }

	  set fill(value) {
	    this._applyStyle('fill', value);
	  }

	  get hidden() {
	    return !!this._hidden;
	  }

	  set hidden(value) {
	    this._hidden = value;
	  }

	  get outlineLevel() {
	    return this._outlineLevel || 0;
	  }

	  set outlineLevel(value) {
	    this._outlineLevel = value;
	  }

	  get collapsed() {
	    return !!(
	      this._outlineLevel && this._outlineLevel >= this._worksheet.properties.outlineLevelRow
	    );
	  }

	  // =========================================================================
	  get model() {
	    const cells = [];
	    let min = 0;
	    let max = 0;
	    this._cells.forEach(cell => {
	      if (cell) {
	        const cellModel = cell.model;
	        if (cellModel) {
	          if (!min || min > cell.col) {
	            min = cell.col;
	          }
	          if (max < cell.col) {
	            max = cell.col;
	          }
	          cells.push(cellModel);
	        }
	      }
	    });

	    return this.height || cells.length
	      ? {
	          cells,
	          number: this.number,
	          min,
	          max,
	          height: this.height,
	          style: this.style,
	          hidden: this.hidden,
	          outlineLevel: this.outlineLevel,
	          collapsed: this.collapsed,
	        }
	      : null;
	  }

	  set model(value) {
	    if (value.number !== this._number) {
	      throw new Error('Invalid row number in model');
	    }
	    this._cells = [];
	    let previousAddress;
	    value.cells.forEach(cellModel => {
	      switch (cellModel.type) {
	        case cell.Types.Merge:
	          // special case - don't add this types
	          break;
	        default: {
	          let address;
	          if (cellModel.address) {
	            address = colCache_1.decodeAddress(cellModel.address);
	          } else if (previousAddress) {
	            // This is a <c> element without an r attribute
	            // Assume that it's the cell for the next column
	            const {row} = previousAddress;
	            const col = previousAddress.col + 1;
	            address = {
	              row,
	              col,
	              address: colCache_1.encodeAddress(row, col),
	              $col$row: `$${colCache_1.n2l(col)}$${row}`,
	            };
	          }
	          previousAddress = address;
	          const cell = this.getCellEx(address);
	          cell.model = cellModel;
	          break;
	        }
	      }
	    });

	    if (value.height) {
	      this.height = value.height;
	    } else {
	      delete this.height;
	    }

	    this.hidden = value.hidden;
	    this.outlineLevel = value.outlineLevel || 0;

	    this.style = (value.style && JSON.parse(JSON.stringify(value.style))) || {};
	  }
	}

	var row = Row;

	const DEFAULT_COLUMN_WIDTH = 9;

	// Column defines the column properties for 1 column.
	// This includes header rows, widths, key, (style), etc.
	// Worksheet will condense the columns as appropriate during serialization
	class Column {
	  constructor(worksheet, number, defn) {
	    this._worksheet = worksheet;
	    this._number = number;
	    if (defn !== false) {
	      // sometimes defn will follow
	      this.defn = defn;
	    }
	  }

	  get number() {
	    return this._number;
	  }

	  get worksheet() {
	    return this._worksheet;
	  }

	  get letter() {
	    return colCache_1.n2l(this._number);
	  }

	  get isCustomWidth() {
	    return this.width !== undefined && this.width !== DEFAULT_COLUMN_WIDTH;
	  }

	  get defn() {
	    return {
	      header: this._header,
	      key: this.key,
	      width: this.width,
	      style: this.style,
	      hidden: this.hidden,
	      outlineLevel: this.outlineLevel,
	    };
	  }

	  set defn(value) {
	    if (value) {
	      this.key = value.key;
	      this.width = value.width !== undefined ? value.width : DEFAULT_COLUMN_WIDTH;
	      this.outlineLevel = value.outlineLevel;
	      if (value.style) {
	        this.style = value.style;
	      } else {
	        this.style = {};
	      }

	      // headers must be set after style
	      this.header = value.header;
	      this._hidden = !!value.hidden;
	    } else {
	      delete this._header;
	      delete this._key;
	      delete this.width;
	      this.style = {};
	      this.outlineLevel = 0;
	    }
	  }

	  get headers() {
	    return this._header && this._header instanceof Array ? this._header : [this._header];
	  }

	  get header() {
	    return this._header;
	  }

	  set header(value) {
	    if (value !== undefined) {
	      this._header = value;
	      this.headers.forEach((text, index) => {
	        this._worksheet.getCell(index + 1, this.number).value = text;
	      });
	    } else {
	      this._header = undefined;
	    }
	  }

	  get key() {
	    return this._key;
	  }

	  set key(value) {
	    const column = this._key && this._worksheet.getColumnKey(this._key);
	    if (column === this) {
	      this._worksheet.deleteColumnKey(this._key);
	    }

	    this._key = value;
	    if (value) {
	      this._worksheet.setColumnKey(this._key, this);
	    }
	  }

	  get hidden() {
	    return !!this._hidden;
	  }

	  set hidden(value) {
	    this._hidden = value;
	  }

	  get outlineLevel() {
	    return this._outlineLevel || 0;
	  }

	  set outlineLevel(value) {
	    this._outlineLevel = value;
	  }

	  get collapsed() {
	    return !!(
	      this._outlineLevel && this._outlineLevel >= this._worksheet.properties.outlineLevelCol
	    );
	  }

	  toString() {
	    return JSON.stringify({
	      key: this.key,
	      width: this.width,
	      headers: this.headers.length ? this.headers : undefined,
	    });
	  }

	  equivalentTo(other) {
	    return (
	      this.width === other.width &&
	      this.hidden === other.hidden &&
	      this.outlineLevel === other.outlineLevel &&
	      underDash.isEqual(this.style, other.style)
	    );
	  }

	  get isDefault() {
	    if (this.isCustomWidth) {
	      return false;
	    }
	    if (this.hidden) {
	      return false;
	    }
	    if (this.outlineLevel) {
	      return false;
	    }
	    const s = this.style;
	    if (s && (s.font || s.numFmt || s.alignment || s.border || s.fill || s.protection)) {
	      return false;
	    }
	    return true;
	  }

	  get headerCount() {
	    return this.headers.length;
	  }

	  eachCell(options, iteratee) {
	    const colNumber = this.number;
	    if (!iteratee) {
	      iteratee = options;
	      options = null;
	    }
	    this._worksheet.eachRow(options, (row, rowNumber) => {
	      iteratee(row.getCell(colNumber), rowNumber);
	    });
	  }

	  get values() {
	    const v = [];
	    this.eachCell((cell, rowNumber) => {
	      if (cell && cell.type !== enums.ValueType.Null) {
	        v[rowNumber] = cell.value;
	      }
	    });
	    return v;
	  }

	  set values(v) {
	    if (!v) {
	      return;
	    }
	    const colNumber = this.number;
	    let offset = 0;
	    if (v.hasOwnProperty('0')) {
	      // assume contiguous array, start at row 1
	      offset = 1;
	    }
	    v.forEach((value, index) => {
	      this._worksheet.getCell(index + offset, colNumber).value = value;
	    });
	  }

	  // =========================================================================
	  // styles
	  _applyStyle(name, value) {
	    this.style[name] = value;
	    this.eachCell(cell => {
	      cell[name] = value;
	    });
	    return value;
	  }

	  get numFmt() {
	    return this.style.numFmt;
	  }

	  set numFmt(value) {
	    this._applyStyle('numFmt', value);
	  }

	  get font() {
	    return this.style.font;
	  }

	  set font(value) {
	    this._applyStyle('font', value);
	  }

	  get alignment() {
	    return this.style.alignment;
	  }

	  set alignment(value) {
	    this._applyStyle('alignment', value);
	  }

	  get protection() {
	    return this.style.protection;
	  }

	  set protection(value) {
	    this._applyStyle('protection', value);
	  }

	  get border() {
	    return this.style.border;
	  }

	  set border(value) {
	    this._applyStyle('border', value);
	  }

	  get fill() {
	    return this.style.fill;
	  }

	  set fill(value) {
	    this._applyStyle('fill', value);
	  }

	  // =============================================================================
	  // static functions

	  static toModel(columns) {
	    // Convert array of Column into compressed list cols
	    const cols = [];
	    let col = null;
	    if (columns) {
	      columns.forEach((column, index) => {
	        if (column.isDefault) {
	          if (col) {
	            col = null;
	          }
	        } else if (!col || !column.equivalentTo(col)) {
	          col = {
	            min: index + 1,
	            max: index + 1,
	            width: column.width !== undefined ? column.width : DEFAULT_COLUMN_WIDTH,
	            style: column.style,
	            isCustomWidth: column.isCustomWidth,
	            hidden: column.hidden,
	            outlineLevel: column.outlineLevel,
	            collapsed: column.collapsed,
	          };
	          cols.push(col);
	        } else {
	          col.max = index + 1;
	        }
	      });
	    }
	    return cols.length ? cols : undefined;
	  }

	  static fromModel(worksheet, cols) {
	    cols = cols || [];
	    const columns = [];
	    let count = 1;
	    let index = 0;
	    while (index < cols.length) {
	      const col = cols[index++];
	      while (count < col.min) {
	        columns.push(new Column(worksheet, count++));
	      }
	      while (count <= col.max) {
	        columns.push(new Column(worksheet, count++, col));
	      }
	    }
	    return columns.length ? columns : null;
	  }
	}

	var column = Column;

	class Anchor {
	  constructor(worksheet, address, offset = 0) {
	    if (!address) {
	      this.nativeCol = 0;
	      this.nativeColOff = 0;
	      this.nativeRow = 0;
	      this.nativeRowOff = 0;
	    } else if (typeof address === 'string') {
	      const decoded = colCache_1.decodeAddress(address);
	      this.nativeCol = decoded.col + offset;
	      this.nativeColOff = 0;
	      this.nativeRow = decoded.row + offset;
	      this.nativeRowOff = 0;
	    } else if (address.nativeCol !== undefined) {
	      this.nativeCol = address.nativeCol || 0;
	      this.nativeColOff = address.nativeColOff || 0;
	      this.nativeRow = address.nativeRow || 0;
	      this.nativeRowOff = address.nativeRowOff || 0;
	    } else if (address.col !== undefined) {
	      this.col = address.col + offset;
	      this.row = address.row + offset;
	    } else {
	      this.nativeCol = 0;
	      this.nativeColOff = 0;
	      this.nativeRow = 0;
	      this.nativeRowOff = 0;
	    }

	    this.worksheet = worksheet;
	  }

	  static asInstance(model) {
	    return model instanceof Anchor || model == null ? model : new Anchor(model);
	  }

	  get col() {
	    return this.nativeCol + (Math.min(this.colWidth - 1, this.nativeColOff) / this.colWidth);
	  }

	  set col(v) {
	    this.nativeCol = Math.floor(v);
	    this.nativeColOff = Math.floor((v - this.nativeCol) * this.colWidth);
	  }

	  get row() {
	    return this.nativeRow + (Math.min(this.rowHeight - 1, this.nativeRowOff) / this.rowHeight);
	  }

	  set row(v) {
	    this.nativeRow = Math.floor(v);
	    this.nativeRowOff = Math.floor((v - this.nativeRow) * this.rowHeight);
	  }

	  get colWidth() {
	    return this.worksheet &&
	      this.worksheet.getColumn(this.nativeCol + 1) &&
	      this.worksheet.getColumn(this.nativeCol + 1).isCustomWidth
	      ? Math.floor(this.worksheet.getColumn(this.nativeCol + 1).width * 10000)
	      : 640000;
	  }

	  get rowHeight() {
	    return this.worksheet &&
	      this.worksheet.getRow(this.nativeRow + 1) &&
	      this.worksheet.getRow(this.nativeRow + 1).height
	      ? Math.floor(this.worksheet.getRow(this.nativeRow + 1).height * 10000)
	      : 180000;
	  }

	  get model() {
	    return {
	      nativeCol: this.nativeCol,
	      nativeColOff: this.nativeColOff,
	      nativeRow: this.nativeRow,
	      nativeRowOff: this.nativeRowOff,
	    };
	  }

	  set model(value) {
	    this.nativeCol = value.nativeCol;
	    this.nativeColOff = value.nativeColOff;
	    this.nativeRow = value.nativeRow;
	    this.nativeRowOff = value.nativeRowOff;
	  }
	}

	var anchor = Anchor;

	class Image {
	  constructor(worksheet, model) {
	    this.worksheet = worksheet;
	    this.model = model;
	  }

	  get model() {
	    switch (this.type) {
	      case 'background':
	        return {
	          type: this.type,
	          imageId: this.imageId,
	        };
	      case 'image':
	        return {
	          type: this.type,
	          imageId: this.imageId,
	          hyperlinks: this.range.hyperlinks,
	          range: {
	            tl: this.range.tl.model,
	            br: this.range.br && this.range.br.model,
	            ext: this.range.ext,
	            editAs: this.range.editAs,
	          },
	        };
	      default:
	        throw new Error('Invalid Image Type');
	    }
	  }

	  set model({type, imageId, range, hyperlinks}) {
	    this.type = type;
	    this.imageId = imageId;

	    if (type === 'image') {
	      if (typeof range === 'string') {
	        const decoded = colCache_1.decode(range);
	        this.range = {
	          tl: new anchor(this.worksheet, {col: decoded.left, row: decoded.top}, -1),
	          br: new anchor(this.worksheet, {col: decoded.right, row: decoded.bottom}, 0),
	          editAs: 'oneCell',
	        };
	      } else {
	        this.range = {
	          tl: new anchor(this.worksheet, range.tl, 0),
	          br: range.br && new anchor(this.worksheet, range.br, 0),
	          ext: range.ext,
	          editAs: range.editAs,
	          hyperlinks: hyperlinks || range.hyperlinks,
	        };
	      }
	    }
	  }
	}

	var image = Image;

	/* eslint-disable max-classes-per-file */


	class Column$1 {
	  // wrapper around column model, allowing access and manipulation
	  constructor(table, column, index) {
	    this.table = table;
	    this.column = column;
	    this.index = index;
	  }

	  _set(name, value) {
	    this.table.cacheState();
	    this.column[name] = value;
	  }

	  /* eslint-disable lines-between-class-members */
	  get name() {
	    return this.column.name;
	  }
	  set name(value) {
	    this._set('name', value);
	  }

	  get filterButton() {
	    return this.column.filterButton;
	  }
	  set filterButton(value) {
	    this.column.filterButton = value;
	  }

	  get style() {
	    return this.column.style;
	  }
	  set style(value) {
	    this.column.style = value;
	  }

	  get totalsRowLabel() {
	    return this.column.totalsRowLabel;
	  }
	  set totalsRowLabel(value) {
	    this._set('totalsRowLabel', value);
	  }

	  get totalsRowFunction() {
	    return this.column.totalsRowFunction;
	  }
	  set totalsRowFunction(value) {
	    this._set('totalsRowFunction', value);
	  }

	  get totalsRowResult() {
	    return this.column.totalsRowResult;
	  }
	  set totalsRowResult(value) {
	    this._set('totalsRowResult', value);
	  }

	  get totalsRowFormula() {
	    return this.column.totalsRowFormula;
	  }
	  set totalsRowFormula(value) {
	    this._set('totalsRowFormula', value);
	  }
	  /* eslint-enable lines-between-class-members */
	}

	class Table {
	  constructor(worksheet, table) {
	    this.worksheet = worksheet;
	    if (table) {
	      this.table = table;
	      // check things are ok first
	      this.validate();

	      this.store();
	    }
	  }

	  getFormula(column) {
	    // get the correct formula to apply to the totals row
	    switch (column.totalsRowFunction) {
	      case 'none':
	        return null;
	      case 'average':
	        return `SUBTOTAL(101,${this.table.name}[${column.name}])`;
	      case 'countNums':
	        return `SUBTOTAL(102,${this.table.name}[${column.name}])`;
	      case 'count':
	        return `SUBTOTAL(103,${this.table.name}[${column.name}])`;
	      case 'max':
	        return `SUBTOTAL(104,${this.table.name}[${column.name}])`;
	      case 'min':
	        return `SUBTOTAL(105,${this.table.name}[${column.name}])`;
	      case 'stdDev':
	        return `SUBTOTAL(106,${this.table.name}[${column.name}])`;
	      case 'var':
	        return `SUBTOTAL(107,${this.table.name}[${column.name}])`;
	      case 'sum':
	        return `SUBTOTAL(109,${this.table.name}[${column.name}])`;
	      case 'custom':
	        return column.totalsRowFormula;
	      default:
	        throw new Error(`Invalid Totals Row Function: ${column.totalsRowFunction}`);
	    }
	  }

	  get width() {
	    // width of the table
	    return this.table.columns.length;
	  }

	  get height() {
	    // height of the table data
	    return this.table.rows.length;
	  }

	  get filterHeight() {
	    // height of the table data plus optional header row
	    return this.height + (this.table.headerRow ? 1 : 0);
	  }

	  get tableHeight() {
	    // full height of the table on the sheet
	    return this.filterHeight + (this.table.totalsRow ? 1 : 0);
	  }

	  validate() {
	    const {table} = this;
	    // set defaults and check is valid
	    const assign = (o, name, dflt) => {
	      if (o[name] === undefined) {
	        o[name] = dflt;
	      }
	    };
	    assign(table, 'headerRow', true);
	    assign(table, 'totalsRow', false);

	    assign(table, 'style', {});
	    assign(table.style, 'theme', 'TableStyleMedium2');
	    assign(table.style, 'showFirstColumn', false);
	    assign(table.style, 'showLastColumn', false);
	    assign(table.style, 'showRowStripes', false);
	    assign(table.style, 'showColumnStripes', false);

	    const assert = (test, message) => {
	      if (!test) {
	        throw new Error(message);
	      }
	    };
	    assert(table.ref, 'Table must have ref');
	    assert(table.columns, 'Table must have column definitions');
	    assert(table.rows, 'Table must have row definitions');

	    table.tl = colCache_1.decodeAddress(table.ref);
	    const {row, col} = table.tl;
	    assert(row > 0, 'Table must be on valid row');
	    assert(col > 0, 'Table must be on valid col');

	    const {width, filterHeight, tableHeight} = this;

	    // autoFilterRef is a range that includes optional headers only
	    table.autoFilterRef = colCache_1.encode(row, col, row + filterHeight - 1, col + width - 1);

	    // tableRef is a range that includes optional headers and totals
	    table.tableRef = colCache_1.encode(row, col, row + tableHeight - 1, col + width - 1);

	    table.columns.forEach((column, i) => {
	      assert(column.name, `Column ${i} must have a name`);
	      if (i === 0) {
	        assign(column, 'totalsRowLabel', 'Total');
	      } else {
	        assign(column, 'totalsRowFunction', 'none');
	        column.totalsRowFormula = this.getFormula(column);
	      }
	    });
	  }

	  store() {
	    // where the table needs to store table data, headers, footers in
	    // the sheet...
	    const assignStyle = (cell, style) => {
	      if (style) {
	        Object.keys(style).forEach(key => {
	          cell[key] = style[key];
	        });
	      }
	    };

	    const {worksheet, table} = this;
	    const {row, col} = table.tl;
	    let count = 0;
	    if (table.headerRow) {
	      const r = worksheet.getRow(row + count++);
	      table.columns.forEach((column, j) => {
	        const {style, name} = column;
	        const cell = r.getCell(col + j);
	        cell.value = name;
	        assignStyle(cell, style);
	      });
	    }
	    table.rows.forEach(data => {
	      const r = worksheet.getRow(row + count++);
	      data.forEach((value, j) => {
	        const cell = r.getCell(col + j);
	        cell.value = value;

	        assignStyle(cell, table.columns[j].style);
	      });
	    });

	    if (table.totalsRow) {
	      const r = worksheet.getRow(row + count++);
	      table.columns.forEach((column, j) => {
	        const cell = r.getCell(col + j);
	        if (j === 0) {
	          cell.value = column.totalsRowLabel;
	        } else {
	          const formula = this.getFormula(column);
	          if (formula) {
	            cell.value = {
	              formula: column.totalsRowFormula,
	              result: column.totalsRowResult,
	            };
	          } else {
	            cell.value = null;
	          }
	        }

	        assignStyle(cell, column.style);
	      });
	    }
	  }

	  load(worksheet) {
	    // where the table will read necessary features from a loaded sheet
	    const {table} = this;
	    const {row, col} = table.tl;
	    let count = 0;
	    if (table.headerRow) {
	      const r = worksheet.getRow(row + count++);
	      table.columns.forEach((column, j) => {
	        const cell = r.getCell(col + j);
	        cell.value = column.name;
	      });
	    }
	    table.rows.forEach(data => {
	      const r = worksheet.getRow(row + count++);
	      data.forEach((value, j) => {
	        const cell = r.getCell(col + j);
	        cell.value = value;
	      });
	    });

	    if (table.totalsRow) {
	      const r = worksheet.getRow(row + count++);
	      table.columns.forEach((column, j) => {
	        const cell = r.getCell(col + j);
	        if (j === 0) {
	          cell.value = column.totalsRowLabel;
	        } else {
	          const formula = this.getFormula(column);
	          if (formula) {
	            cell.value = {
	              formula: column.totalsRowFormula,
	              result: column.totalsRowResult,
	            };
	          }
	        }
	      });
	    }
	  }

	  get model() {
	    return this.table;
	  }

	  set model(value) {
	    this.table = value;
	  }

	  // ================================================================
	  // TODO: Mutating methods
	  cacheState() {
	    if (!this._cache) {
	      this._cache = {
	        ref: this.ref,
	        width: this.width,
	        tableHeight: this.tableHeight,
	      };
	    }
	  }

	  commit() {
	    // changes may have been made that might have on-sheet effects
	    if (!this._cache) {
	      return;
	    }

	    // check things are ok first
	    this.validate();

	    const ref = colCache_1.decodeAddress(this._cache.ref);
	    if (this.ref !== this._cache.ref) {
	      // wipe out whole table footprint at previous location
	      for (let i = 0; i < this._cache.tableHeight; i++) {
	        const row = this.worksheet.getRow(ref.row + i);
	        for (let j = 0; j < this._cache.width; j++) {
	          const cell = row.getCell(ref.col + j);
	          cell.value = null;
	        }
	      }
	    } else {
	      // clear out below table if it has shrunk
	      for (let i = this.tableHeight; i < this._cache.tableHeight; i++) {
	        const row = this.worksheet.getRow(ref.row + i);
	        for (let j = 0; j < this._cache.width; j++) {
	          const cell = row.getCell(ref.col + j);
	          cell.value = null;
	        }
	      }

	      // clear out to right of table if it has lost columns
	      for (let i = 0; i < this.tableHeight; i++) {
	        const row = this.worksheet.getRow(ref.row + i);
	        for (let j = this.width; j < this._cache.width; j++) {
	          const cell = row.getCell(ref.col + j);
	          cell.value = null;
	        }
	      }
	    }

	    this.store();
	  }

	  addRow(values, rowNumber) {
	    // Add a row of data, either insert at rowNumber or append
	    this.cacheState();

	    if (rowNumber === undefined) {
	      this.table.rows.push(values);
	    } else {
	      this.table.rows.splice(rowNumber, 0, values);
	    }
	  }

	  removeRows(rowIndex, count = 1) {
	    // Remove a rows of data
	    this.cacheState();
	    this.table.rows.splice(rowIndex, count);
	  }

	  getColumn(colIndex) {
	    const column = this.table.columns[colIndex];
	    return new Column$1(this, column, colIndex);
	  }

	  addColumn(column, values, colIndex) {
	    // Add a new column, including column defn and values
	    // Inserts at colNumber or adds to the right
	    this.cacheState();

	    if (colIndex === undefined) {
	      this.table.columns.push(column);
	      this.table.rows.forEach((row, i) => {
	        row.push(values[i]);
	      });
	    } else {
	      this.table.columns.splice(colIndex, 0, column);
	      this.table.rows.forEach((row, i) => {
	        row.splice(colIndex, 0, values[i]);
	      });
	    }
	  }

	  removeColumns(colIndex, count = 1) {
	    // Remove a column with data
	    this.cacheState();

	    this.table.columns.splice(colIndex, count);
	    this.table.rows.forEach(row => {
	      row.splice(colIndex, count);
	    });
	  }

	  _assign(target, prop, value) {
	    this.cacheState();
	    target[prop] = value;
	  }

	  /* eslint-disable lines-between-class-members */
	  get ref() {
	    return this.table.ref;
	  }
	  set ref(value) {
	    this._assign(this.table, 'ref', value);
	  }

	  get name() {
	    return this.table.name;
	  }
	  set name(value) {
	    this.table.name = value;
	  }

	  get displayName() {
	    return this.table.displyName || this.table.name;
	  }
	  set displayNamename(value) {
	    this.table.displayName = value;
	  }

	  get headerRow() {
	    return this.table.headerRow;
	  }
	  set headerRow(value) {
	    this._assign(this.table, 'headerRow', value);
	  }

	  get totalsRow() {
	    return this.table.totalsRow;
	  }
	  set totalsRow(value) {
	    this._assign(this.table, 'totalsRow', value);
	  }

	  get theme() {
	    return this.table.style.name;
	  }
	  set theme(value) {
	    this.table.style.name = value;
	  }

	  get showFirstColumn() {
	    return this.table.style.showFirstColumn;
	  }
	  set showFirstColumn(value) {
	    this.table.style.showFirstColumn = value;
	  }

	  get showLastColumn() {
	    return this.table.style.showLastColumn;
	  }
	  set showLastColumn(value) {
	    this.table.style.showLastColumn = value;
	  }

	  get showRowStripes() {
	    return this.table.style.showRowStripes;
	  }
	  set showRowStripes(value) {
	    this.table.style.showRowStripes = value;
	  }

	  get showColumnStripes() {
	    return this.table.style.showColumnStripes;
	  }
	  set showColumnStripes(value) {
	    this.table.style.showColumnStripes = value;
	  }
	  /* eslint-enable lines-between-class-members */
	}

	var table = Table;

	class DataValidations {
	  constructor(model) {
	    this.model = model || {};
	  }

	  add(address, validation) {
	    return (this.model[address] = validation);
	  }

	  find(address) {
	    return this.model[address];
	  }

	  remove(address) {
	    this.model[address] = undefined;
	  }
	}

	var dataValidations = DataValidations;

	const Encryptor = {
	  /**
	   * Calculate a hash of the concatenated buffers with the given algorithm.
	   * @param {string} algorithm - The hash algorithm.
	   * @returns {Buffer} The hash
	   */
	  hash(algorithm, ...buffers) {
	    const hash = crypto__default['default'].createHash(algorithm);
	    hash.update(Buffer.concat(buffers));
	    return hash.digest();
	  },
	  /**
	   * Convert a password into an encryption key
	   * @param {string} password - The password
	   * @param {string} hashAlgorithm - The hash algoritm
	   * @param {string} saltValue - The salt value
	   * @param {number} spinCount - The spin count
	   * @param {number} keyBits - The length of the key in bits
	   * @param {Buffer} blockKey - The block key
	   * @returns {Buffer} The encryption key
	   */
	  convertPasswordToHash(password, hashAlgorithm, saltValue, spinCount) {
	    hashAlgorithm = hashAlgorithm.toLowerCase();
	    const hashes = crypto__default['default'].getHashes();
	    if (hashes.indexOf(hashAlgorithm) < 0) {
	      throw new Error(`Hash algorithm '${hashAlgorithm}' not supported!`);
	    }

	    // Password must be in unicode buffer
	    const passwordBuffer = Buffer.from(password, 'utf16le');
	    // Generate the initial hash
	    let key = this.hash(hashAlgorithm, Buffer.from(saltValue, 'base64'), passwordBuffer);
	    // Now regenerate until spin count
	    for (let i = 0; i < spinCount; i++) {
	      const iterator = Buffer.alloc(4);
	      // this is the 'special' element of Excel password hashing
	      // that stops us from using crypto.pbkdf2()
	      iterator.writeUInt32LE(i, 0);
	      key = this.hash(hashAlgorithm, key, iterator);
	    }
	    return key.toString('base64');
	  },
	  /**
	   * Generates cryptographically strong pseudo-random data.
	   * @param size The size argument is a number indicating the number of bytes to generate.
	   */
	  randomBytes(size) {
	    return crypto__default['default'].randomBytes(size);
	  },
	};
	var encryptor = Encryptor;

	// Worksheet requirements
	//  Operate as sheet inside workbook or standalone
	//  Load and Save from file and stream
	//  Access/Add/Delete individual cells
	//  Manage column widths and row heights

	class Worksheet {
	  constructor(options) {
	    options = options || {};

	    // in a workbook, each sheet will have a number
	    this.id = options.id;
	    this.orderNo = options.orderNo;

	    // and a name
	    this.name = options.name || `Sheet${this.id}`;

	    // add a state
	    this.state = options.state || 'visible';

	    // rows allows access organised by row. Sparse array of arrays indexed by row-1, col
	    // Note: _rows is zero based. Must subtract 1 to go from cell.row to index
	    this._rows = [];

	    // column definitions
	    this._columns = null;

	    // column keys (addRow convenience): key ==> this._collumns index
	    this._keys = {};

	    // keep record of all merges
	    this._merges = {};

	    // record of all row and column pageBreaks
	    this.rowBreaks = [];

	    this._workbook = options.workbook;

	    // for tabColor, default row height, outline levels, etc
	    this.properties = Object.assign(
	      {},
	      {
	        defaultRowHeight: 15,
	        dyDescent: 55,
	        outlineLevelCol: 0,
	        outlineLevelRow: 0,
	      },
	      options.properties
	    );

	    // for all things printing
	    this.pageSetup = Object.assign(
	      {},
	      {
	        margins: {left: 0.7, right: 0.7, top: 0.75, bottom: 0.75, header: 0.3, footer: 0.3},
	        orientation: 'portrait',
	        horizontalDpi: 4294967295,
	        verticalDpi: 4294967295,
	        fitToPage: !!(
	          options.pageSetup &&
	          (options.pageSetup.fitToWidth || options.pageSetup.fitToHeight) &&
	          !options.pageSetup.scale
	        ),
	        pageOrder: 'downThenOver',
	        blackAndWhite: false,
	        draft: false,
	        cellComments: 'None',
	        errors: 'displayed',
	        scale: 100,
	        fitToWidth: 1,
	        fitToHeight: 1,
	        paperSize: undefined,
	        showRowColHeaders: false,
	        showGridLines: false,
	        firstPageNumber: undefined,
	        horizontalCentered: false,
	        verticalCentered: false,
	        rowBreaks: null,
	        colBreaks: null,
	      },
	      options.pageSetup
	    );

	    this.headerFooter = Object.assign(
	      {},
	      {
	        differentFirst: false,
	        differentOddEven: false,
	        oddHeader: null,
	        oddFooter: null,
	        evenHeader: null,
	        evenFooter: null,
	        firstHeader: null,
	        firstFooter: null,
	      },
	      options.headerFooter
	    );

	    this.dataValidations = new dataValidations();

	    // for freezepanes, split, zoom, gridlines, etc
	    this.views = options.views || [];

	    this.autoFilter = options.autoFilter || null;

	    // for images, etc
	    this._media = [];

	    // worksheet protection
	    this.sheetProtection = null;

	    // for tables
	    this.tables = {};

	    this.conditionalFormattings = [];
	  }

	  get workbook() {
	    return this._workbook;
	  }

	  // when you're done with this worksheet, call this to remove from workbook
	  destroy() {
	    this._workbook.removeWorksheetEx(this);
	  }

	  // Get the bounding range of the cells in this worksheet
	  get dimensions() {
	    const dimensions = new range();
	    this._rows.forEach(row => {
	      if (row) {
	        const rowDims = row.dimensions;
	        if (rowDims) {
	          dimensions.expand(row.number, rowDims.min, row.number, rowDims.max);
	        }
	      }
	    });
	    return dimensions;
	  }

	  // =========================================================================
	  // Columns

	  // get the current columns array.
	  get columns() {
	    return this._columns;
	  }

	  // set the columns from an array of column definitions.
	  // Note: any headers defined will overwrite existing values.
	  set columns(value) {
	    // calculate max header row count
	    this._headerRowCount = value.reduce((pv, cv) => {
	      const headerCount = (cv.header && 1) || (cv.headers && cv.headers.length) || 0;
	      return Math.max(pv, headerCount);
	    }, 0);

	    // construct Column objects
	    let count = 1;
	    const columns = (this._columns = []);
	    value.forEach(defn => {
	      const column$1 = new column(this, count++, false);
	      columns.push(column$1);
	      column$1.defn = defn;
	    });
	  }

	  getColumnKey(key) {
	    return this._keys[key];
	  }

	  setColumnKey(key, value) {
	    this._keys[key] = value;
	  }

	  deleteColumnKey(key) {
	    delete this._keys[key];
	  }

	  eachColumnKey(f) {
	    underDash.each(this._keys, f);
	  }

	  // get a single column by col number. If it doesn't exist, create it and any gaps before it
	  getColumn(c) {
	    if (typeof c === 'string') {
	      // if it matches a key'd column, return that
	      const col = this._keys[c];
	      if (col) return col;

	      // otherwise, assume letter
	      c = colCache_1.l2n(c);
	    }
	    if (!this._columns) {
	      this._columns = [];
	    }
	    if (c > this._columns.length) {
	      let n = this._columns.length + 1;
	      while (n <= c) {
	        this._columns.push(new column(this, n++));
	      }
	    }
	    return this._columns[c - 1];
	  }

	  spliceColumns(start, count, ...inserts) {
	    const rows = this._rows;
	    const nRows = rows.length;
	    if (inserts.length > 0) {
	      // must iterate over all rows whether they exist yet or not
	      for (let i = 0; i < nRows; i++) {
	        const rowArguments = [start, count];
	        // eslint-disable-next-line no-loop-func
	        inserts.forEach(insert => {
	          rowArguments.push(insert[i] || null);
	        });
	        const row = this.getRow(i + 1);
	        // eslint-disable-next-line prefer-spread
	        row.splice.apply(row, rowArguments);
	      }
	    } else {
	      // nothing to insert, so just splice all rows
	      this._rows.forEach(r => {
	        if (r) {
	          r.splice(start, count);
	        }
	      });
	    }

	    // splice column definitions
	    const nExpand = inserts.length - count;
	    const nKeep = start + count;
	    const nEnd = this._columns.length;
	    if (nExpand < 0) {
	      for (let i = start + inserts.length; i <= nEnd; i++) {
	        this.getColumn(i).defn = this.getColumn(i - nExpand).defn;
	      }
	    } else if (nExpand > 0) {
	      for (let i = nEnd; i >= nKeep; i--) {
	        this.getColumn(i + nExpand).defn = this.getColumn(i).defn;
	      }
	    }
	    for (let i = start; i < start + inserts.length; i++) {
	      this.getColumn(i).defn = null;
	    }

	    // account for defined names
	    this.workbook.definedNames.spliceColumns(this.name, start, count, inserts.length);
	  }

	  get lastColumn() {
	    return this.getColumn(this.columnCount);
	  }

	  get columnCount() {
	    let maxCount = 0;
	    this.eachRow(row => {
	      maxCount = Math.max(maxCount, row.cellCount);
	    });
	    return maxCount;
	  }

	  get actualColumnCount() {
	    // performance nightmare - for each row, counts all the columns used
	    const counts = [];
	    let count = 0;
	    this.eachRow(row => {
	      row.eachCell(({col}) => {
	        if (!counts[col]) {
	          counts[col] = true;
	          count++;
	        }
	      });
	    });
	    return count;
	  }

	  // =========================================================================
	  // Rows

	  _commitRow() {
	    // nop - allows streaming reader to fill a document
	  }

	  get _lastRowNumber() {
	    // need to cope with results of splice
	    const rows = this._rows;
	    let n = rows.length;
	    while (n > 0 && rows[n - 1] === undefined) {
	      n--;
	    }
	    return n;
	  }

	  get _nextRow() {
	    return this._lastRowNumber + 1;
	  }

	  get lastRow() {
	    if (this._rows.length) {
	      return this._rows[this._rows.length - 1];
	    }
	    return undefined;
	  }

	  // find a row (if exists) by row number
	  findRow(r) {
	    return this._rows[r - 1];
	  }

	  // find multiple rows (if exists) by row number
	  findRows(start, length) {
	    return this._rows.slice(start - 1, start - 1 + length);
	  }

	  get rowCount() {
	    return this._lastRowNumber;
	  }

	  get actualRowCount() {
	    // counts actual rows that have actual data
	    let count = 0;
	    this.eachRow(() => {
	      count++;
	    });
	    return count;
	  }

	  // get a row by row number.
	  getRow(r) {
	    let row$1 = this._rows[r - 1];
	    if (!row$1) {
	      row$1 = this._rows[r - 1] = new row(this, r);
	    }
	    return row$1;
	  }

	  // get multiple rows by row number.
	  getRows(start, length) {
	    if (length < 1) return undefined;
	    const rows = [];
	    for (let i = start; i < start + length; i++) {
	      rows.push(this.getRow(i));
	    }
	    return rows;
	  }

	  addRow(value, style = 'n') {
	    const rowNo = this._nextRow;
	    const row = this.getRow(rowNo);
	    row.values = value;
	    this._setStyleOption(rowNo, style[0] === 'i' ? style : 'n');
	    return row;
	  }

	  addRows(value, style = 'n') {
	    const rows = [];
	    value.forEach(row => {
	      rows.push(this.addRow(row, style));
	    });
	    return rows;
	  }

	  insertRow(pos, value, style = 'n') {
	    this.spliceRows(pos, 0, value);
	    this._setStyleOption(pos, style);
	    return this.getRow(pos);
	  }

	  insertRows(pos, values, style = 'n') {
	    this.spliceRows(pos, 0, ...values);
	    if (style !== 'n') {
	      // copy over the styles
	      for (let i = 0; i < values.length; i++) {
	        if (style[0] === 'o' && this.findRow(values.length + pos + i) !== undefined) {
	          this._copyStyle(values.length + pos + i, pos + i, style[1] === '+');
	        } else if (style[0] === 'i' && this.findRow(pos - 1) !== undefined) {
	          this._copyStyle(pos - 1, pos + i, style[1] === '+');
	        }
	      }
	    }
	    return this.getRows(pos, values.length);
	  }

	  // set row at position to same style as of either pervious row (option 'i') or next row (option 'o')
	  _setStyleOption(pos, style = 'n') {
	    if (style[0] === 'o' && this.findRow(pos + 1) !== undefined) {
	      this._copyStyle(pos + 1, pos, style[1] === '+');
	    } else if (style[0] === 'i' && this.findRow(pos - 1) !== undefined) {
	      this._copyStyle(pos - 1, pos, style[1] === '+');
	    }
	  }

	  _copyStyle(src, dest, styleEmpty = false) {
	    const rSrc = this.getRow(src);
	    const rDst = this.getRow(dest);
	    rDst.style = Object.freeze({...rSrc.style});
	    // eslint-disable-next-line no-loop-func
	    rSrc.eachCell({includeEmpty: styleEmpty}, (cell, colNumber) => {
	      rDst.getCell(colNumber).style = Object.freeze({...cell.style});
	    });
	    rDst.height = rSrc.height;
	  }

	  duplicateRow(rowNum, count, insert = false) {
	    // create count duplicates of rowNum
	    // either inserting new or overwriting existing rows

	    const rSrc = this._rows[rowNum - 1];
	    const inserts = new Array(count).fill(rSrc.values);
	    this.spliceRows(rowNum + 1, insert ? 0 : count, ...inserts);

	    // now copy styles...
	    for (let i = 0; i < count; i++) {
	      const rDst = this._rows[rowNum + i];
	      rDst.style = rSrc.style;
	      rDst.height = rSrc.height;
	      // eslint-disable-next-line no-loop-func
	      rSrc.eachCell({includeEmpty: true}, (cell, colNumber) => {
	        rDst.getCell(colNumber).style = cell.style;
	      });
	    }
	  }

	  spliceRows(start, count, ...inserts) {
	    // same problem as row.splice, except worse.
	    const nKeep = start + count;
	    const nInserts = inserts.length;
	    const nExpand = nInserts - count;
	    const nEnd = this._rows.length;
	    let i;
	    let rSrc;
	    if (nExpand < 0) {
	      // remove rows
	      for (i = nKeep; i <= nEnd; i++) {
	        rSrc = this._rows[i - 1];
	        if (rSrc) {
	          const rDst = this.getRow(i + nExpand);
	          rDst.values = rSrc.values;
	          rDst.style = rSrc.style;
	          rDst.height = rSrc.height;
	          // eslint-disable-next-line no-loop-func
	          rSrc.eachCell({includeEmpty: true}, (cell, colNumber) => {
	            rDst.getCell(colNumber).style = cell.style;
	          });
	          this._rows[i - 1] = undefined;
	        } else {
	          this._rows[i + nExpand - 1] = undefined;
	        }
	      }
	    } else if (nExpand > 0) {
	      // insert new cells
	      for (i = nEnd; i >= nKeep; i--) {
	        rSrc = this._rows[i - 1];
	        if (rSrc) {
	          const rDst = this.getRow(i + nExpand);
	          rDst.values = rSrc.values;
	          rDst.style = rSrc.style;
	          rDst.height = rSrc.height;
	          // eslint-disable-next-line no-loop-func
	          rSrc.eachCell({includeEmpty: true}, (cell, colNumber) => {
	            rDst.getCell(colNumber).style = cell.style;

	            // remerge cells accounting for insert offset
	            if (cell._value.constructor.name === 'MergeValue') {
	              const cellToBeMerged = this.getRow(cell._row._number + nInserts).getCell(colNumber);
	              const prevMaster = cell._value._master;
	              const newMaster = this.getRow(prevMaster._row._number + nInserts).getCell(prevMaster._column._number);
	              cellToBeMerged.merge(newMaster);
	            }
	          });
	        } else {
	          this._rows[i + nExpand - 1] = undefined;
	        }
	      }
	    }

	    // now copy over the new values
	    for (i = 0; i < nInserts; i++) {
	      const rDst = this.getRow(start + i);
	      rDst.style = {};
	      rDst.values = inserts[i];
	    }

	    // account for defined names
	    this.workbook.definedNames.spliceRows(this.name, start, count, nInserts);
	  }

	  // iterate over every row in the worksheet, including maybe empty rows
	  eachRow(options, iteratee) {
	    if (!iteratee) {
	      iteratee = options;
	      options = undefined;
	    }
	    if (options && options.includeEmpty) {
	      const n = this._rows.length;
	      for (let i = 1; i <= n; i++) {
	        iteratee(this.getRow(i), i);
	      }
	    } else {
	      this._rows.forEach(row => {
	        if (row && row.hasValues) {
	          iteratee(row, row.number);
	        }
	      });
	    }
	  }

	  // return all rows as sparse array
	  getSheetValues() {
	    const rows = [];
	    this._rows.forEach(row => {
	      if (row) {
	        rows[row.number] = row.values;
	      }
	    });
	    return rows;
	  }

	  // =========================================================================
	  // Cells

	  // returns the cell at [r,c] or address given by r. If not found, return undefined
	  findCell(r, c) {
	    const address = colCache_1.getAddress(r, c);
	    const row = this._rows[address.row - 1];
	    return row ? row.findCell(address.col) : undefined;
	  }

	  // return the cell at [r,c] or address given by r. If not found, create a new one.
	  getCell(r, c) {
	    const address = colCache_1.getAddress(r, c);
	    const row = this.getRow(address.row);
	    return row.getCellEx(address);
	  }

	  // =========================================================================
	  // Merge

	  // convert the range defined by ['tl:br'], [tl,br] or [t,l,b,r] into a single 'merged' cell
	  mergeCells(...cells) {
	    const dimensions = new range(cells);
	    this._mergeCellsInternal(dimensions);
	  }

	  mergeCellsWithoutStyle(...cells) {
	    const dimensions = new range(cells);
	    this._mergeCellsInternal(dimensions, true);
	  }

	  _mergeCellsInternal(dimensions, ignoreStyle) {
	    // check cells aren't already merged
	    underDash.each(this._merges, merge => {
	      if (merge.intersects(dimensions)) {
	        throw new Error('Cannot merge already merged cells');
	      }
	    });

	    // apply merge
	    const master = this.getCell(dimensions.top, dimensions.left);
	    for (let i = dimensions.top; i <= dimensions.bottom; i++) {
	      for (let j = dimensions.left; j <= dimensions.right; j++) {
	        // merge all but the master cell
	        if (i > dimensions.top || j > dimensions.left) {
	          this.getCell(i, j).merge(master, ignoreStyle);
	        }
	      }
	    }

	    // index merge
	    this._merges[master.address] = dimensions;
	  }

	  _unMergeMaster(master) {
	    // master is always top left of a rectangle
	    const merge = this._merges[master.address];
	    if (merge) {
	      for (let i = merge.top; i <= merge.bottom; i++) {
	        for (let j = merge.left; j <= merge.right; j++) {
	          this.getCell(i, j).unmerge();
	        }
	      }
	      delete this._merges[master.address];
	    }
	  }

	  get hasMerges() {
	    // return true if this._merges has a merge object
	    return underDash.some(this._merges, Boolean);
	  }

	  // scan the range defined by ['tl:br'], [tl,br] or [t,l,b,r] and if any cell is part of a merge,
	  // un-merge the group. Note this function can affect multiple merges and merge-blocks are
	  // atomic - either they're all merged or all un-merged.
	  unMergeCells(...cells) {
	    const dimensions = new range(cells);

	    // find any cells in that range and unmerge them
	    for (let i = dimensions.top; i <= dimensions.bottom; i++) {
	      for (let j = dimensions.left; j <= dimensions.right; j++) {
	        const cell = this.findCell(i, j);
	        if (cell) {
	          if (cell.type === enums.ValueType.Merge) {
	            // this cell merges to another master
	            this._unMergeMaster(cell.master);
	          } else if (this._merges[cell.address]) {
	            // this cell is a master
	            this._unMergeMaster(cell);
	          }
	        }
	      }
	    }
	  }

	  // ===========================================================================
	  // Shared/Array Formula
	  fillFormula(range, formula, results, shareType = 'shared') {
	    // Define formula for top-left cell and share to rest
	    const decoded = colCache_1.decode(range);
	    const {top, left, bottom, right} = decoded;
	    const width = right - left + 1;
	    const masterAddress = colCache_1.encodeAddress(top, left);
	    const isShared = shareType === 'shared';

	    // work out result accessor
	    let getResult;
	    if (typeof results === 'function') {
	      getResult = results;
	    } else if (Array.isArray(results)) {
	      if (Array.isArray(results[0])) {
	        getResult = (row, col) => results[row - top][col - left];
	      } else {
	        // eslint-disable-next-line no-mixed-operators
	        getResult = (row, col) => results[(row - top) * width + (col - left)];
	      }
	    } else {
	      getResult = () => undefined;
	    }
	    let first = true;
	    for (let r = top; r <= bottom; r++) {
	      for (let c = left; c <= right; c++) {
	        if (first) {
	          this.getCell(r, c).value = {
	            shareType,
	            formula,
	            ref: range,
	            result: getResult(r, c),
	          };
	          first = false;
	        } else {
	          this.getCell(r, c).value = isShared
	            ? {
	                sharedFormula: masterAddress,
	                result: getResult(r, c),
	              }
	            : getResult(r, c);
	        }
	      }
	    }
	  }

	  // =========================================================================
	  // Images
	  addImage(imageId, range) {
	    const model = {
	      type: 'image',
	      imageId,
	      range,
	    };
	    this._media.push(new image(this, model));
	  }

	  getImages() {
	    return this._media.filter(m => m.type === 'image');
	  }

	  addBackgroundImage(imageId) {
	    const model = {
	      type: 'background',
	      imageId,
	    };
	    this._media.push(new image(this, model));
	  }

	  getBackgroundImageId() {
	    const image = this._media.find(m => m.type === 'background');
	    return image && image.imageId;
	  }

	  // =========================================================================
	  // Worksheet Protection
	  protect(password, options) {
	    // TODO: make this function truly async
	    // perhaps marshal to worker thread or something
	    return new Promise(resolve => {
	      this.sheetProtection = {
	        sheet: true,
	      };
	      if (options && 'spinCount' in options) {
	        // force spinCount to be integer >= 0
	        options.spinCount = Number.isFinite(options.spinCount) ? Math.round(Math.max(0, options.spinCount)) : 100000;
	      }
	      if (password) {
	        this.sheetProtection.algorithmName = 'SHA-512';
	        this.sheetProtection.saltValue = encryptor.randomBytes(16).toString('base64');
	        this.sheetProtection.spinCount = options && 'spinCount' in options ? options.spinCount : 100000; // allow user specified spinCount
	        this.sheetProtection.hashValue = encryptor.convertPasswordToHash(
	          password,
	          'SHA512',
	          this.sheetProtection.saltValue,
	          this.sheetProtection.spinCount
	        );
	      }
	      if (options) {
	        this.sheetProtection = Object.assign(this.sheetProtection, options);
	        if (!password && 'spinCount' in options) {
	          delete this.sheetProtection.spinCount;
	        }
	      }
	      resolve();
	    });
	  }

	  unprotect() {
	    this.sheetProtection = null;
	  }

	  // =========================================================================
	  // Tables
	  addTable(model) {
	    const table$1 = new table(this, model);
	    this.tables[model.name] = table$1;
	    return table$1;
	  }

	  getTable(name) {
	    return this.tables[name];
	  }

	  removeTable(name) {
	    delete this.tables[name];
	  }

	  getTables() {
	    return Object.values(this.tables);
	  }

	  // ===========================================================================
	  // Conditional Formatting
	  addConditionalFormatting(cf) {
	    this.conditionalFormattings.push(cf);
	  }

	  removeConditionalFormatting(filter) {
	    if (typeof filter === 'number') {
	      this.conditionalFormattings.splice(filter, 1);
	    } else if (filter instanceof Function) {
	      this.conditionalFormattings = this.conditionalFormattings.filter(filter);
	    } else {
	      this.conditionalFormattings = [];
	    }
	  }

	  // ===========================================================================
	  // Deprecated
	  get tabColor() {
	    // eslint-disable-next-line no-console
	    console.trace('worksheet.tabColor property is now deprecated. Please use worksheet.properties.tabColor');
	    return this.properties.tabColor;
	  }

	  set tabColor(value) {
	    // eslint-disable-next-line no-console
	    console.trace('worksheet.tabColor property is now deprecated. Please use worksheet.properties.tabColor');
	    this.properties.tabColor = value;
	  }

	  // ===========================================================================
	  // Model

	  get model() {
	    const model = {
	      id: this.id,
	      name: this.name,
	      dataValidations: this.dataValidations.model,
	      properties: this.properties,
	      state: this.state,
	      pageSetup: this.pageSetup,
	      headerFooter: this.headerFooter,
	      rowBreaks: this.rowBreaks,
	      views: this.views,
	      autoFilter: this.autoFilter,
	      media: this._media.map(medium => medium.model),
	      sheetProtection: this.sheetProtection,
	      tables: Object.values(this.tables).map(table => table.model),
	      conditionalFormattings: this.conditionalFormattings,
	    };

	    // =================================================
	    // columns
	    model.cols = column.toModel(this.columns);

	    // ==========================================================
	    // Rows
	    const rows = (model.rows = []);
	    const dimensions = (model.dimensions = new range());
	    this._rows.forEach(row => {
	      const rowModel = row && row.model;
	      if (rowModel) {
	        dimensions.expand(rowModel.number, rowModel.min, rowModel.number, rowModel.max);
	        rows.push(rowModel);
	      }
	    });

	    // ==========================================================
	    // Merges
	    model.merges = [];
	    underDash.each(this._merges, merge => {
	      model.merges.push(merge.range);
	    });

	    return model;
	  }

	  _parseRows(model) {
	    this._rows = [];
	    model.rows.forEach(rowModel => {
	      const row$1 = new row(this, rowModel.number);
	      this._rows[row$1.number - 1] = row$1;
	      row$1.model = rowModel;
	    });
	  }

	  _parseMergeCells(model) {
	    underDash.each(model.mergeCells, merge => {
	      // Do not merge styles when importing an Excel file
	      // since each cell may have different styles intentionally.
	      this.mergeCellsWithoutStyle(merge);
	    });
	  }

	  set model(value) {
	    this.name = value.name;
	    this._columns = column.fromModel(this, value.cols);
	    this._parseRows(value);

	    this._parseMergeCells(value);
	    this.dataValidations = new dataValidations(value.dataValidations);
	    this.properties = value.properties;
	    this.pageSetup = value.pageSetup;
	    this.headerFooter = value.headerFooter;
	    this.views = value.views;
	    this.autoFilter = value.autoFilter;
	    this._media = value.media.map(medium => new image(this, medium));
	    this.sheetProtection = value.sheetProtection;
	    this.tables = value.tables.reduce((tables, table$1) => {
	      const t = new table();
	      t.model = table$1;
	      tables[table$1.name] = t;
	      return tables;
	    }, {});
	    this.conditionalFormattings = value.conditionalFormattings;
	  }
	}

	var worksheet = Worksheet;

	class CellMatrix {
	  constructor(template) {
	    this.template = template;
	    this.sheets = {};
	  }

	  addCell(addressStr) {
	    this.addCellEx(colCache_1.decodeEx(addressStr));
	  }

	  getCell(addressStr) {
	    return this.findCellEx(colCache_1.decodeEx(addressStr), true);
	  }

	  findCell(addressStr) {
	    return this.findCellEx(colCache_1.decodeEx(addressStr), false);
	  }

	  findCellAt(sheetName, rowNumber, colNumber) {
	    const sheet = this.sheets[sheetName];
	    const row = sheet && sheet[rowNumber];
	    return row && row[colNumber];
	  }

	  addCellEx(address) {
	    if (address.top) {
	      for (let row = address.top; row <= address.bottom; row++) {
	        for (let col = address.left; col <= address.right; col++) {
	          this.getCellAt(address.sheetName, row, col);
	        }
	      }
	    } else {
	      this.findCellEx(address, true);
	    }
	  }

	  getCellEx(address) {
	    return this.findCellEx(address, true);
	  }

	  findCellEx(address, create) {
	    const sheet = this.findSheet(address, create);
	    const row = this.findSheetRow(sheet, address, create);
	    return this.findRowCell(row, address, create);
	  }

	  getCellAt(sheetName, rowNumber, colNumber) {
	    const sheet = this.sheets[sheetName] || (this.sheets[sheetName] = []);
	    const row = sheet[rowNumber] || (sheet[rowNumber] = []);
	    const cell =
	      row[colNumber] ||
	      (row[colNumber] = {
	        sheetName,
	        address: colCache_1.n2l(colNumber) + rowNumber,
	        row: rowNumber,
	        col: colNumber,
	      });
	    return cell;
	  }

	  removeCellEx(address) {
	    const sheet = this.findSheet(address);
	    if (!sheet) {
	      return;
	    }
	    const row = this.findSheetRow(sheet, address);
	    if (!row) {
	      return;
	    }
	    delete row[address.col];
	  }

	  forEachInSheet(sheetName, callback) {
	    const sheet = this.sheets[sheetName];
	    if (sheet) {
	      sheet.forEach((row, rowNumber) => {
	        if (row) {
	          row.forEach((cell, colNumber) => {
	            if (cell) {
	              callback(cell, rowNumber, colNumber);
	            }
	          });
	        }
	      });
	    }
	  }

	  forEach(callback) {
	    underDash.each(this.sheets, (sheet, sheetName) => {
	      this.forEachInSheet(sheetName, callback);
	    });
	  }

	  map(callback) {
	    const results = [];
	    this.forEach(cell => {
	      results.push(callback(cell));
	    });
	    return results;
	  }

	  findSheet(address, create) {
	    const name = address.sheetName;
	    if (this.sheets[name]) {
	      return this.sheets[name];
	    }
	    if (create) {
	      return (this.sheets[name] = []);
	    }
	    return undefined;
	  }

	  findSheetRow(sheet, address, create) {
	    const {row} = address;
	    if (sheet && sheet[row]) {
	      return sheet[row];
	    }
	    if (create) {
	      return (sheet[row] = []);
	    }
	    return undefined;
	  }

	  findRowCell(row, address, create) {
	    const {col} = address;
	    if (row && row[col]) {
	      return row[col];
	    }
	    if (create) {
	      return (row[col] = this.template
	        ? Object.assign(address, JSON.parse(JSON.stringify(this.template)))
	        : address);
	    }
	    return undefined;
	  }

	  spliceRows(sheetName, start, numDelete, numInsert) {
	    const sheet = this.sheets[sheetName];
	    if (sheet) {
	      const inserts = [];
	      for (let i = 0; i < numInsert; i++) {
	        inserts.push([]);
	      }
	      sheet.splice(start, numDelete, ...inserts);
	    }
	  }

	  spliceColumns(sheetName, start, numDelete, numInsert) {
	    const sheet = this.sheets[sheetName];
	    if (sheet) {
	      const inserts = [];
	      for (let i = 0; i < numInsert; i++) {
	        inserts.push(null);
	      }
	      underDash.each(sheet, row => {
	        row.splice(start, numDelete, ...inserts);
	      });
	    }
	  }
	}

	var cellMatrix = CellMatrix;

	const rangeRegexp = /[$](\w+)[$](\d+)(:[$](\w+)[$](\d+))?/;

	class DefinedNames {
	  constructor() {
	    this.matrixMap = {};
	  }

	  getMatrix(name) {
	    const matrix = this.matrixMap[name] || (this.matrixMap[name] = new cellMatrix());
	    return matrix;
	  }

	  // add a name to a cell. locStr in the form SheetName!$col$row or SheetName!$c1$r1:$c2:$r2
	  add(locStr, name) {
	    const location = colCache_1.decodeEx(locStr);
	    this.addEx(location, name);
	  }

	  addEx(location, name) {
	    const matrix = this.getMatrix(name);
	    if (location.top) {
	      for (let col = location.left; col <= location.right; col++) {
	        for (let row = location.top; row <= location.bottom; row++) {
	          const address = {
	            sheetName: location.sheetName,
	            address: colCache_1.n2l(col) + row,
	            row,
	            col,
	          };

	          matrix.addCellEx(address);
	        }
	      }
	    } else {
	      matrix.addCellEx(location);
	    }
	  }

	  remove(locStr, name) {
	    const location = colCache_1.decodeEx(locStr);
	    this.removeEx(location, name);
	  }

	  removeEx(location, name) {
	    const matrix = this.getMatrix(name);
	    matrix.removeCellEx(location);
	  }

	  removeAllNames(location) {
	    underDash.each(this.matrixMap, matrix => {
	      matrix.removeCellEx(location);
	    });
	  }

	  forEach(callback) {
	    underDash.each(this.matrixMap, (matrix, name) => {
	      matrix.forEach(cell => {
	        callback(name, cell);
	      });
	    });
	  }

	  // get all the names of a cell
	  getNames(addressStr) {
	    return this.getNamesEx(colCache_1.decodeEx(addressStr));
	  }

	  getNamesEx(address) {
	    return underDash.map(this.matrixMap, (matrix, name) => matrix.findCellEx(address) && name).filter(
	      Boolean
	    );
	  }

	  _explore(matrix, cell) {
	    cell.mark = false;
	    const {sheetName} = cell;

	    const range$1 = new range(cell.row, cell.col, cell.row, cell.col, sheetName);
	    let x;
	    let y;

	    // grow vertical - only one col to worry about
	    function vGrow(yy, edge) {
	      const c = matrix.findCellAt(sheetName, yy, cell.col);
	      if (!c || !c.mark) {
	        return false;
	      }
	      range$1[edge] = yy;
	      c.mark = false;
	      return true;
	    }
	    for (y = cell.row - 1; vGrow(y, 'top'); y--);
	    for (y = cell.row + 1; vGrow(y, 'bottom'); y++);

	    // grow horizontal - ensure all rows can grow
	    function hGrow(xx, edge) {
	      const cells = [];
	      for (y = range$1.top; y <= range$1.bottom; y++) {
	        const c = matrix.findCellAt(sheetName, y, xx);
	        if (c && c.mark) {
	          cells.push(c);
	        } else {
	          return false;
	        }
	      }
	      range$1[edge] = xx;
	      for (let i = 0; i < cells.length; i++) {
	        cells[i].mark = false;
	      }
	      return true;
	    }
	    for (x = cell.col - 1; hGrow(x, 'left'); x--);
	    for (x = cell.col + 1; hGrow(x, 'right'); x++);

	    return range$1;
	  }

	  getRanges(name, matrix) {
	    matrix = matrix || this.matrixMap[name];

	    if (!matrix) {
	      return {name, ranges: []};
	    }

	    // mark and sweep!
	    matrix.forEach(cell => {
	      cell.mark = true;
	    });
	    const ranges = matrix
	      .map(cell => cell.mark && this._explore(matrix, cell))
	      .filter(Boolean)
	      .map(range => range.$shortRange);

	    return {
	      name,
	      ranges,
	    };
	  }

	  normaliseMatrix(matrix, sheetName) {
	    // some of the cells might have shifted on specified sheet
	    // need to reassign rows, cols
	    matrix.forEachInSheet(sheetName, (cell, row, col) => {
	      if (cell) {
	        if (cell.row !== row || cell.col !== col) {
	          cell.row = row;
	          cell.col = col;
	          cell.address = colCache_1.n2l(col) + row;
	        }
	      }
	    });
	  }

	  spliceRows(sheetName, start, numDelete, numInsert) {
	    underDash.each(this.matrixMap, matrix => {
	      matrix.spliceRows(sheetName, start, numDelete, numInsert);
	      this.normaliseMatrix(matrix, sheetName);
	    });
	  }

	  spliceColumns(sheetName, start, numDelete, numInsert) {
	    underDash.each(this.matrixMap, matrix => {
	      matrix.spliceColumns(sheetName, start, numDelete, numInsert);
	      this.normaliseMatrix(matrix, sheetName);
	    });
	  }

	  get model() {
	    // To get names per cell - just iterate over all names finding cells if they exist
	    return underDash.map(this.matrixMap, (matrix, name) => this.getRanges(name, matrix)).filter(
	      definedName => definedName.ranges.length
	    );
	  }

	  set model(value) {
	    // value is [ { name, ranges }, ... ]
	    const matrixMap = (this.matrixMap = {});
	    value.forEach(definedName => {
	      const matrix = (matrixMap[definedName.name] = new cellMatrix());
	      definedName.ranges.forEach(rangeStr => {
	        if (rangeRegexp.test(rangeStr.split('!').pop() || '')) {
	          matrix.addCell(rangeStr);
	        }
	      });
	    });
	  }
	}

	var definedNames = DefinedNames;

	var jszip_min = createCommonjsModule(function (module, exports) {
	/*!

	JSZip v3.6.0 - A JavaScript class for generating and reading zip files
	<http://stuartk.com/jszip>

	(c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
	Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/master/LICENSE.markdown.

	JSZip uses the library pako released under the MIT license :
	https://github.com/nodeca/pako/blob/master/LICENSE
	*/

	!function(e){module.exports=e();}(function(){return function s(a,o,u){function h(r,e){if(!o[r]){if(!a[r]){var t="function"==typeof commonjsRequire&&commonjsRequire;if(!e&&t)return t(r,!0);if(f)return f(r,!0);var n=new Error("Cannot find module '"+r+"'");throw n.code="MODULE_NOT_FOUND",n}var i=o[r]={exports:{}};a[r][0].call(i.exports,function(e){var t=a[r][1][e];return h(t||e)},i,i.exports,s,a,o,u);}return o[r].exports}for(var f="function"==typeof commonjsRequire&&commonjsRequire,e=0;e<u.length;e++)h(u[e]);return h}({1:[function(l,t,n){(function(r){!function(e){"object"==typeof n&&void 0!==t?t.exports=e():("undefined"!=typeof window?window:void 0!==r?r:"undefined"!=typeof self?self:this).JSZip=e();}(function(){return function s(a,o,u){function h(t,e){if(!o[t]){if(!a[t]){var r="function"==typeof l&&l;if(!e&&r)return r(t,!0);if(f)return f(t,!0);var n=new Error("Cannot find module '"+t+"'");throw n.code="MODULE_NOT_FOUND",n}var i=o[t]={exports:{}};a[t][0].call(i.exports,function(e){return h(a[t][1][e]||e)},i,i.exports,s,a,o,u);}return o[t].exports}for(var f="function"==typeof l&&l,e=0;e<u.length;e++)h(u[e]);return h}({1:[function(l,t,n){(function(r){!function(e){"object"==typeof n&&void 0!==t?t.exports=e():("undefined"!=typeof window?window:void 0!==r?r:"undefined"!=typeof self?self:this).JSZip=e();}(function(){return function s(a,o,u){function h(t,e){if(!o[t]){if(!a[t]){var r="function"==typeof l&&l;if(!e&&r)return r(t,!0);if(f)return f(t,!0);var n=new Error("Cannot find module '"+t+"'");throw n.code="MODULE_NOT_FOUND",n}var i=o[t]={exports:{}};a[t][0].call(i.exports,function(e){return h(a[t][1][e]||e)},i,i.exports,s,a,o,u);}return o[t].exports}for(var f="function"==typeof l&&l,e=0;e<u.length;e++)h(u[e]);return h}({1:[function(l,t,n){(function(r){!function(e){"object"==typeof n&&void 0!==t?t.exports=e():("undefined"!=typeof window?window:void 0!==r?r:"undefined"!=typeof self?self:this).JSZip=e();}(function(){return function s(a,o,u){function h(t,e){if(!o[t]){if(!a[t]){var r="function"==typeof l&&l;if(!e&&r)return r(t,!0);if(f)return f(t,!0);var n=new Error("Cannot find module '"+t+"'");throw n.code="MODULE_NOT_FOUND",n}var i=o[t]={exports:{}};a[t][0].call(i.exports,function(e){return h(a[t][1][e]||e)},i,i.exports,s,a,o,u);}return o[t].exports}for(var f="function"==typeof l&&l,e=0;e<u.length;e++)h(u[e]);return h}({1:[function(l,t,n){(function(r){!function(e){"object"==typeof n&&void 0!==t?t.exports=e():("undefined"!=typeof window?window:void 0!==r?r:"undefined"!=typeof self?self:this).JSZip=e();}(function(){return function s(a,o,u){function h(t,e){if(!o[t]){if(!a[t]){var r="function"==typeof l&&l;if(!e&&r)return r(t,!0);if(f)return f(t,!0);var n=new Error("Cannot find module '"+t+"'");throw n.code="MODULE_NOT_FOUND",n}var i=o[t]={exports:{}};a[t][0].call(i.exports,function(e){return h(a[t][1][e]||e)},i,i.exports,s,a,o,u);}return o[t].exports}for(var f="function"==typeof l&&l,e=0;e<u.length;e++)h(u[e]);return h}({1:[function(l,t,n){(function(r){!function(e){"object"==typeof n&&void 0!==t?t.exports=e():("undefined"!=typeof window?window:void 0!==r?r:"undefined"!=typeof self?self:this).JSZip=e();}(function(){return function s(a,o,u){function h(t,e){if(!o[t]){if(!a[t]){var r="function"==typeof l&&l;if(!e&&r)return r(t,!0);if(f)return f(t,!0);var n=new Error("Cannot find module '"+t+"'");throw n.code="MODULE_NOT_FOUND",n}var i=o[t]={exports:{}};a[t][0].call(i.exports,function(e){return h(a[t][1][e]||e)},i,i.exports,s,a,o,u);}return o[t].exports}for(var f="function"==typeof l&&l,e=0;e<u.length;e++)h(u[e]);return h}({1:[function(e,t,r){var c=e("./utils"),l=e("./support"),p="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";r.encode=function(e){for(var t,r,n,i,s,a,o,u=[],h=0,f=e.length,l=f,d="string"!==c.getTypeOf(e);h<e.length;)l=f-h,n=d?(t=e[h++],r=h<f?e[h++]:0,h<f?e[h++]:0):(t=e.charCodeAt(h++),r=h<f?e.charCodeAt(h++):0,h<f?e.charCodeAt(h++):0),i=t>>2,s=(3&t)<<4|r>>4,a=1<l?(15&r)<<2|n>>6:64,o=2<l?63&n:64,u.push(p.charAt(i)+p.charAt(s)+p.charAt(a)+p.charAt(o));return u.join("")},r.decode=function(e){var t,r,n,i,s,a,o=0,u=0;if("data:"===e.substr(0,"data:".length))throw new Error("Invalid base64 input, it looks like a data url.");var h,f=3*(e=e.replace(/[^A-Za-z0-9\+\/\=]/g,"")).length/4;if(e.charAt(e.length-1)===p.charAt(64)&&f--,e.charAt(e.length-2)===p.charAt(64)&&f--,f%1!=0)throw new Error("Invalid base64 input, bad content length.");for(h=l.uint8array?new Uint8Array(0|f):new Array(0|f);o<e.length;)t=p.indexOf(e.charAt(o++))<<2|(i=p.indexOf(e.charAt(o++)))>>4,r=(15&i)<<4|(s=p.indexOf(e.charAt(o++)))>>2,n=(3&s)<<6|(a=p.indexOf(e.charAt(o++))),h[u++]=t,64!==s&&(h[u++]=r),64!==a&&(h[u++]=n);return h};},{"./support":30,"./utils":32}],2:[function(e,t,r){var n=e("./external"),i=e("./stream/DataWorker"),s=e("./stream/Crc32Probe"),a=e("./stream/DataLengthProbe");function o(e,t,r,n,i){this.compressedSize=e,this.uncompressedSize=t,this.crc32=r,this.compression=n,this.compressedContent=i;}o.prototype={getContentWorker:function(){var e=new i(n.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new a("data_length")),t=this;return e.on("end",function(){if(this.streamInfo.data_length!==t.uncompressedSize)throw new Error("Bug : uncompressed data size mismatch")}),e},getCompressedWorker:function(){return new i(n.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize",this.compressedSize).withStreamInfo("uncompressedSize",this.uncompressedSize).withStreamInfo("crc32",this.crc32).withStreamInfo("compression",this.compression)}},o.createWorkerFrom=function(e,t,r){return e.pipe(new s).pipe(new a("uncompressedSize")).pipe(t.compressWorker(r)).pipe(new a("compressedSize")).withStreamInfo("compression",t)},t.exports=o;},{"./external":6,"./stream/Crc32Probe":25,"./stream/DataLengthProbe":26,"./stream/DataWorker":27}],3:[function(e,t,r){var n=e("./stream/GenericWorker");r.STORE={magic:"\0\0",compressWorker:function(e){return new n("STORE compression")},uncompressWorker:function(){return new n("STORE decompression")}},r.DEFLATE=e("./flate");},{"./flate":7,"./stream/GenericWorker":28}],4:[function(e,t,r){var n=e("./utils"),a=function(){for(var e,t=[],r=0;r<256;r++){e=r;for(var n=0;n<8;n++)e=1&e?3988292384^e>>>1:e>>>1;t[r]=e;}return t}();t.exports=function(e,t){return void 0!==e&&e.length?"string"!==n.getTypeOf(e)?function(e,t,r){var n=a,i=0+r;e^=-1;for(var s=0;s<i;s++)e=e>>>8^n[255&(e^t[s])];return -1^e}(0|t,e,e.length):function(e,t,r){var n=a,i=0+r;e^=-1;for(var s=0;s<i;s++)e=e>>>8^n[255&(e^t.charCodeAt(s))];return -1^e}(0|t,e,e.length):0};},{"./utils":32}],5:[function(e,t,r){r.base64=!1,r.binary=!1,r.dir=!1,r.createFolders=!0,r.date=null,r.compression=null,r.compressionOptions=null,r.comment=null,r.unixPermissions=null,r.dosPermissions=null;},{}],6:[function(e,t,r){var n;n="undefined"!=typeof Promise?Promise:e("lie"),t.exports={Promise:n};},{lie:37}],7:[function(e,t,r){var n="undefined"!=typeof Uint8Array&&"undefined"!=typeof Uint16Array&&"undefined"!=typeof Uint32Array,i=e("pako"),s=e("./utils"),a=e("./stream/GenericWorker"),o=n?"uint8array":"array";function u(e,t){a.call(this,"FlateWorker/"+e),this._pako=null,this._pakoAction=e,this._pakoOptions=t,this.meta={};}r.magic="\b\0",s.inherits(u,a),u.prototype.processChunk=function(e){this.meta=e.meta,null===this._pako&&this._createPako(),this._pako.push(s.transformTo(o,e.data),!1);},u.prototype.flush=function(){a.prototype.flush.call(this),null===this._pako&&this._createPako(),this._pako.push([],!0);},u.prototype.cleanUp=function(){a.prototype.cleanUp.call(this),this._pako=null;},u.prototype._createPako=function(){this._pako=new i[this._pakoAction]({raw:!0,level:this._pakoOptions.level||-1});var t=this;this._pako.onData=function(e){t.push({data:e,meta:t.meta});};},r.compressWorker=function(e){return new u("Deflate",e)},r.uncompressWorker=function(){return new u("Inflate",{})};},{"./stream/GenericWorker":28,"./utils":32,pako:38}],8:[function(e,t,r){function I(e,t){var r,n="";for(r=0;r<t;r++)n+=String.fromCharCode(255&e),e>>>=8;return n}function i(e,t,r,n,i,s){var a,o,u=e.file,h=e.compression,f=s!==B.utf8encode,l=O.transformTo("string",s(u.name)),d=O.transformTo("string",B.utf8encode(u.name)),c=u.comment,p=O.transformTo("string",s(c)),m=O.transformTo("string",B.utf8encode(c)),_=d.length!==u.name.length,g=m.length!==c.length,v="",b="",w="",y=u.dir,k=u.date,x={crc32:0,compressedSize:0,uncompressedSize:0};t&&!r||(x.crc32=e.crc32,x.compressedSize=e.compressedSize,x.uncompressedSize=e.uncompressedSize);var S=0;t&&(S|=8),f||!_&&!g||(S|=2048);var z,E=0,C=0;y&&(E|=16),"UNIX"===i?(C=798,E|=((z=u.unixPermissions)||(z=y?16893:33204),(65535&z)<<16)):(C=20,E|=63&(u.dosPermissions||0)),a=k.getUTCHours(),a<<=6,a|=k.getUTCMinutes(),a<<=5,a|=k.getUTCSeconds()/2,o=k.getUTCFullYear()-1980,o<<=4,o|=k.getUTCMonth()+1,o<<=5,o|=k.getUTCDate(),_&&(v+="up"+I((b=I(1,1)+I(T(l),4)+d).length,2)+b),g&&(v+="uc"+I((w=I(1,1)+I(T(p),4)+m).length,2)+w);var A="";return A+="\n\0",A+=I(S,2),A+=h.magic,A+=I(a,2),A+=I(o,2),A+=I(x.crc32,4),A+=I(x.compressedSize,4),A+=I(x.uncompressedSize,4),A+=I(l.length,2),A+=I(v.length,2),{fileRecord:R.LOCAL_FILE_HEADER+A+l+v,dirRecord:R.CENTRAL_FILE_HEADER+I(C,2)+A+I(p.length,2)+"\0\0\0\0"+I(E,4)+I(n,4)+l+v+p}}var O=e("../utils"),s=e("../stream/GenericWorker"),B=e("../utf8"),T=e("../crc32"),R=e("../signature");function n(e,t,r,n){s.call(this,"ZipFileWorker"),this.bytesWritten=0,this.zipComment=t,this.zipPlatform=r,this.encodeFileName=n,this.streamFiles=e,this.accumulate=!1,this.contentBuffer=[],this.dirRecords=[],this.currentSourceOffset=0,this.entriesCount=0,this.currentFile=null,this._sources=[];}O.inherits(n,s),n.prototype.push=function(e){var t=e.meta.percent||0,r=this.entriesCount,n=this._sources.length;this.accumulate?this.contentBuffer.push(e):(this.bytesWritten+=e.data.length,s.prototype.push.call(this,{data:e.data,meta:{currentFile:this.currentFile,percent:r?(t+100*(r-n-1))/r:100}}));},n.prototype.openedSource=function(e){this.currentSourceOffset=this.bytesWritten,this.currentFile=e.file.name;var t=this.streamFiles&&!e.file.dir;if(t){var r=i(e,t,!1,this.currentSourceOffset,this.zipPlatform,this.encodeFileName);this.push({data:r.fileRecord,meta:{percent:0}});}else this.accumulate=!0;},n.prototype.closedSource=function(e){this.accumulate=!1;var t,r=this.streamFiles&&!e.file.dir,n=i(e,r,!0,this.currentSourceOffset,this.zipPlatform,this.encodeFileName);if(this.dirRecords.push(n.dirRecord),r)this.push({data:(t=e,R.DATA_DESCRIPTOR+I(t.crc32,4)+I(t.compressedSize,4)+I(t.uncompressedSize,4)),meta:{percent:100}});else for(this.push({data:n.fileRecord,meta:{percent:0}});this.contentBuffer.length;)this.push(this.contentBuffer.shift());this.currentFile=null;},n.prototype.flush=function(){for(var e=this.bytesWritten,t=0;t<this.dirRecords.length;t++)this.push({data:this.dirRecords[t],meta:{percent:100}});var r,n,i,s,a,o,u=this.bytesWritten-e,h=(r=this.dirRecords.length,n=u,i=e,s=this.zipComment,a=this.encodeFileName,o=O.transformTo("string",a(s)),R.CENTRAL_DIRECTORY_END+"\0\0\0\0"+I(r,2)+I(r,2)+I(n,4)+I(i,4)+I(o.length,2)+o);this.push({data:h,meta:{percent:100}});},n.prototype.prepareNextSource=function(){this.previous=this._sources.shift(),this.openedSource(this.previous.streamInfo),this.isPaused?this.previous.pause():this.previous.resume();},n.prototype.registerPrevious=function(e){this._sources.push(e);var t=this;return e.on("data",function(e){t.processChunk(e);}),e.on("end",function(){t.closedSource(t.previous.streamInfo),t._sources.length?t.prepareNextSource():t.end();}),e.on("error",function(e){t.error(e);}),this},n.prototype.resume=function(){return !!s.prototype.resume.call(this)&&(!this.previous&&this._sources.length?(this.prepareNextSource(),!0):this.previous||this._sources.length||this.generatedError?void 0:(this.end(),!0))},n.prototype.error=function(e){var t=this._sources;if(!s.prototype.error.call(this,e))return !1;for(var r=0;r<t.length;r++)try{t[r].error(e);}catch(e){}return !0},n.prototype.lock=function(){s.prototype.lock.call(this);for(var e=this._sources,t=0;t<e.length;t++)e[t].lock();},t.exports=n;},{"../crc32":4,"../signature":23,"../stream/GenericWorker":28,"../utf8":31,"../utils":32}],9:[function(e,t,r){var h=e("../compressions"),n=e("./ZipFileWorker");r.generateWorker=function(e,a,t){var o=new n(a.streamFiles,t,a.platform,a.encodeFileName),u=0;try{e.forEach(function(e,t){u++;var r=function(e,t){var r=e||t,n=h[r];if(!n)throw new Error(r+" is not a valid compression method !");return n}(t.options.compression,a.compression),n=t.options.compressionOptions||a.compressionOptions||{},i=t.dir,s=t.date;t._compressWorker(r,n).withStreamInfo("file",{name:e,dir:i,date:s,comment:t.comment||"",unixPermissions:t.unixPermissions,dosPermissions:t.dosPermissions}).pipe(o);}),o.entriesCount=u;}catch(e){o.error(e);}return o};},{"../compressions":3,"./ZipFileWorker":8}],10:[function(e,t,r){function n(){if(!(this instanceof n))return new n;if(arguments.length)throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");this.files={},this.comment=null,this.root="",this.clone=function(){var e=new n;for(var t in this)"function"!=typeof this[t]&&(e[t]=this[t]);return e};}(n.prototype=e("./object")).loadAsync=e("./load"),n.support=e("./support"),n.defaults=e("./defaults"),n.version="3.5.0",n.loadAsync=function(e,t){return (new n).loadAsync(e,t)},n.external=e("./external"),t.exports=n;},{"./defaults":5,"./external":6,"./load":11,"./object":15,"./support":30}],11:[function(e,t,r){var n=e("./utils"),i=e("./external"),o=e("./utf8"),u=e("./zipEntries"),s=e("./stream/Crc32Probe"),h=e("./nodejsUtils");function f(n){return new i.Promise(function(e,t){var r=n.decompressed.getContentWorker().pipe(new s);r.on("error",function(e){t(e);}).on("end",function(){r.streamInfo.crc32!==n.decompressed.crc32?t(new Error("Corrupted zip : CRC32 mismatch")):e();}).resume();})}t.exports=function(e,s){var a=this;return s=n.extend(s||{},{base64:!1,checkCRC32:!1,optimizedBinaryString:!1,createFolders:!1,decodeFileName:o.utf8decode}),h.isNode&&h.isStream(e)?i.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")):n.prepareContent("the loaded zip file",e,!0,s.optimizedBinaryString,s.base64).then(function(e){var t=new u(s);return t.load(e),t}).then(function(e){var t=[i.Promise.resolve(e)],r=e.files;if(s.checkCRC32)for(var n=0;n<r.length;n++)t.push(f(r[n]));return i.Promise.all(t)}).then(function(e){for(var t=e.shift(),r=t.files,n=0;n<r.length;n++){var i=r[n];a.file(i.fileNameStr,i.decompressed,{binary:!0,optimizedBinaryString:!0,date:i.date,dir:i.dir,comment:i.fileCommentStr.length?i.fileCommentStr:null,unixPermissions:i.unixPermissions,dosPermissions:i.dosPermissions,createFolders:s.createFolders});}return t.zipComment.length&&(a.comment=t.zipComment),a})};},{"./external":6,"./nodejsUtils":14,"./stream/Crc32Probe":25,"./utf8":31,"./utils":32,"./zipEntries":33}],12:[function(e,t,r){var n=e("../utils"),i=e("../stream/GenericWorker");function s(e,t){i.call(this,"Nodejs stream input adapter for "+e),this._upstreamEnded=!1,this._bindStream(t);}n.inherits(s,i),s.prototype._bindStream=function(e){var t=this;(this._stream=e).pause(),e.on("data",function(e){t.push({data:e,meta:{percent:0}});}).on("error",function(e){t.isPaused?this.generatedError=e:t.error(e);}).on("end",function(){t.isPaused?t._upstreamEnded=!0:t.end();});},s.prototype.pause=function(){return !!i.prototype.pause.call(this)&&(this._stream.pause(),!0)},s.prototype.resume=function(){return !!i.prototype.resume.call(this)&&(this._upstreamEnded?this.end():this._stream.resume(),!0)},t.exports=s;},{"../stream/GenericWorker":28,"../utils":32}],13:[function(e,t,r){var i=e("readable-stream").Readable;function n(e,t,r){i.call(this,t),this._helper=e;var n=this;e.on("data",function(e,t){n.push(e)||n._helper.pause(),r&&r(t);}).on("error",function(e){n.emit("error",e);}).on("end",function(){n.push(null);});}e("../utils").inherits(n,i),n.prototype._read=function(){this._helper.resume();},t.exports=n;},{"../utils":32,"readable-stream":16}],14:[function(e,t,r){t.exports={isNode:"undefined"!=typeof Buffer,newBufferFrom:function(e,t){if(Buffer.from&&Buffer.from!==Uint8Array.from)return Buffer.from(e,t);if("number"==typeof e)throw new Error('The "data" argument must not be a number');return new Buffer(e,t)},allocBuffer:function(e){if(Buffer.alloc)return Buffer.alloc(e);var t=new Buffer(e);return t.fill(0),t},isBuffer:function(e){return Buffer.isBuffer(e)},isStream:function(e){return e&&"function"==typeof e.on&&"function"==typeof e.pause&&"function"==typeof e.resume}};},{}],15:[function(e,t,r){function s(e,t,r){var n,i=f.getTypeOf(t),s=f.extend(r||{},d);s.date=s.date||new Date,null!==s.compression&&(s.compression=s.compression.toUpperCase()),"string"==typeof s.unixPermissions&&(s.unixPermissions=parseInt(s.unixPermissions,8)),s.unixPermissions&&16384&s.unixPermissions&&(s.dir=!0),s.dosPermissions&&16&s.dosPermissions&&(s.dir=!0),s.dir&&(e=h(e)),s.createFolders&&(n=function(e){"/"===e.slice(-1)&&(e=e.substring(0,e.length-1));var t=e.lastIndexOf("/");return 0<t?e.substring(0,t):""}(e))&&g.call(this,n,!0);var a,o="string"===i&&!1===s.binary&&!1===s.base64;r&&void 0!==r.binary||(s.binary=!o),(t instanceof c&&0===t.uncompressedSize||s.dir||!t||0===t.length)&&(s.base64=!1,s.binary=!0,t="",s.compression="STORE",i="string"),a=t instanceof c||t instanceof l?t:m.isNode&&m.isStream(t)?new _(e,t):f.prepareContent(e,t,s.binary,s.optimizedBinaryString,s.base64);var u=new p(e,a,s);this.files[e]=u;}function h(e){return "/"!==e.slice(-1)&&(e+="/"),e}var i=e("./utf8"),f=e("./utils"),l=e("./stream/GenericWorker"),a=e("./stream/StreamHelper"),d=e("./defaults"),c=e("./compressedObject"),p=e("./zipObject"),o=e("./generate"),m=e("./nodejsUtils"),_=e("./nodejs/NodejsStreamInputAdapter"),g=function(e,t){return t=void 0!==t?t:d.createFolders,e=h(e),this.files[e]||s.call(this,e,null,{dir:!0,createFolders:t}),this.files[e]};function u(e){return "[object RegExp]"===Object.prototype.toString.call(e)}var n={load:function(){throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.")},forEach:function(e){var t,r,n;for(t in this.files)this.files.hasOwnProperty(t)&&(n=this.files[t],(r=t.slice(this.root.length,t.length))&&t.slice(0,this.root.length)===this.root&&e(r,n));},filter:function(r){var n=[];return this.forEach(function(e,t){r(e,t)&&n.push(t);}),n},file:function(e,t,r){if(1!==arguments.length)return e=this.root+e,s.call(this,e,t,r),this;if(u(e)){var n=e;return this.filter(function(e,t){return !t.dir&&n.test(e)})}var i=this.files[this.root+e];return i&&!i.dir?i:null},folder:function(r){if(!r)return this;if(u(r))return this.filter(function(e,t){return t.dir&&r.test(e)});var e=this.root+r,t=g.call(this,e),n=this.clone();return n.root=t.name,n},remove:function(r){r=this.root+r;var e=this.files[r];if(e||("/"!==r.slice(-1)&&(r+="/"),e=this.files[r]),e&&!e.dir)delete this.files[r];else for(var t=this.filter(function(e,t){return t.name.slice(0,r.length)===r}),n=0;n<t.length;n++)delete this.files[t[n].name];return this},generate:function(e){throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.")},generateInternalStream:function(e){var t,r={};try{if((r=f.extend(e||{},{streamFiles:!1,compression:"STORE",compressionOptions:null,type:"",platform:"DOS",comment:null,mimeType:"application/zip",encodeFileName:i.utf8encode})).type=r.type.toLowerCase(),r.compression=r.compression.toUpperCase(),"binarystring"===r.type&&(r.type="string"),!r.type)throw new Error("No output type specified.");f.checkSupport(r.type),"darwin"!==r.platform&&"freebsd"!==r.platform&&"linux"!==r.platform&&"sunos"!==r.platform||(r.platform="UNIX"),"win32"===r.platform&&(r.platform="DOS");var n=r.comment||this.comment||"";t=o.generateWorker(this,r,n);}catch(e){(t=new l("error")).error(e);}return new a(t,r.type||"string",r.mimeType)},generateAsync:function(e,t){return this.generateInternalStream(e).accumulate(t)},generateNodeStream:function(e,t){return (e=e||{}).type||(e.type="nodebuffer"),this.generateInternalStream(e).toNodejsStream(t)}};t.exports=n;},{"./compressedObject":2,"./defaults":5,"./generate":9,"./nodejs/NodejsStreamInputAdapter":12,"./nodejsUtils":14,"./stream/GenericWorker":28,"./stream/StreamHelper":29,"./utf8":31,"./utils":32,"./zipObject":35}],16:[function(e,t,r){t.exports=e("stream");},{stream:void 0}],17:[function(e,t,r){var n=e("./DataReader");function i(e){n.call(this,e);for(var t=0;t<this.data.length;t++)e[t]=255&e[t];}e("../utils").inherits(i,n),i.prototype.byteAt=function(e){return this.data[this.zero+e]},i.prototype.lastIndexOfSignature=function(e){for(var t=e.charCodeAt(0),r=e.charCodeAt(1),n=e.charCodeAt(2),i=e.charCodeAt(3),s=this.length-4;0<=s;--s)if(this.data[s]===t&&this.data[s+1]===r&&this.data[s+2]===n&&this.data[s+3]===i)return s-this.zero;return -1},i.prototype.readAndCheckSignature=function(e){var t=e.charCodeAt(0),r=e.charCodeAt(1),n=e.charCodeAt(2),i=e.charCodeAt(3),s=this.readData(4);return t===s[0]&&r===s[1]&&n===s[2]&&i===s[3]},i.prototype.readData=function(e){if(this.checkOffset(e),0===e)return [];var t=this.data.slice(this.zero+this.index,this.zero+this.index+e);return this.index+=e,t},t.exports=i;},{"../utils":32,"./DataReader":18}],18:[function(e,t,r){var n=e("../utils");function i(e){this.data=e,this.length=e.length,this.index=0,this.zero=0;}i.prototype={checkOffset:function(e){this.checkIndex(this.index+e);},checkIndex:function(e){if(this.length<this.zero+e||e<0)throw new Error("End of data reached (data length = "+this.length+", asked index = "+e+"). Corrupted zip ?")},setIndex:function(e){this.checkIndex(e),this.index=e;},skip:function(e){this.setIndex(this.index+e);},byteAt:function(e){},readInt:function(e){var t,r=0;for(this.checkOffset(e),t=this.index+e-1;t>=this.index;t--)r=(r<<8)+this.byteAt(t);return this.index+=e,r},readString:function(e){return n.transformTo("string",this.readData(e))},readData:function(e){},lastIndexOfSignature:function(e){},readAndCheckSignature:function(e){},readDate:function(){var e=this.readInt(4);return new Date(Date.UTC(1980+(e>>25&127),(e>>21&15)-1,e>>16&31,e>>11&31,e>>5&63,(31&e)<<1))}},t.exports=i;},{"../utils":32}],19:[function(e,t,r){var n=e("./Uint8ArrayReader");function i(e){n.call(this,e);}e("../utils").inherits(i,n),i.prototype.readData=function(e){this.checkOffset(e);var t=this.data.slice(this.zero+this.index,this.zero+this.index+e);return this.index+=e,t},t.exports=i;},{"../utils":32,"./Uint8ArrayReader":21}],20:[function(e,t,r){var n=e("./DataReader");function i(e){n.call(this,e);}e("../utils").inherits(i,n),i.prototype.byteAt=function(e){return this.data.charCodeAt(this.zero+e)},i.prototype.lastIndexOfSignature=function(e){return this.data.lastIndexOf(e)-this.zero},i.prototype.readAndCheckSignature=function(e){return e===this.readData(4)},i.prototype.readData=function(e){this.checkOffset(e);var t=this.data.slice(this.zero+this.index,this.zero+this.index+e);return this.index+=e,t},t.exports=i;},{"../utils":32,"./DataReader":18}],21:[function(e,t,r){var n=e("./ArrayReader");function i(e){n.call(this,e);}e("../utils").inherits(i,n),i.prototype.readData=function(e){if(this.checkOffset(e),0===e)return new Uint8Array(0);var t=this.data.subarray(this.zero+this.index,this.zero+this.index+e);return this.index+=e,t},t.exports=i;},{"../utils":32,"./ArrayReader":17}],22:[function(e,t,r){var n=e("../utils"),i=e("../support"),s=e("./ArrayReader"),a=e("./StringReader"),o=e("./NodeBufferReader"),u=e("./Uint8ArrayReader");t.exports=function(e){var t=n.getTypeOf(e);return n.checkSupport(t),"string"!==t||i.uint8array?"nodebuffer"===t?new o(e):i.uint8array?new u(n.transformTo("uint8array",e)):new s(n.transformTo("array",e)):new a(e)};},{"../support":30,"../utils":32,"./ArrayReader":17,"./NodeBufferReader":19,"./StringReader":20,"./Uint8ArrayReader":21}],23:[function(e,t,r){r.LOCAL_FILE_HEADER="PK",r.CENTRAL_FILE_HEADER="PK",r.CENTRAL_DIRECTORY_END="PK",r.ZIP64_CENTRAL_DIRECTORY_LOCATOR="PK",r.ZIP64_CENTRAL_DIRECTORY_END="PK",r.DATA_DESCRIPTOR="PK\b";},{}],24:[function(e,t,r){var n=e("./GenericWorker"),i=e("../utils");function s(e){n.call(this,"ConvertWorker to "+e),this.destType=e;}i.inherits(s,n),s.prototype.processChunk=function(e){this.push({data:i.transformTo(this.destType,e.data),meta:e.meta});},t.exports=s;},{"../utils":32,"./GenericWorker":28}],25:[function(e,t,r){var n=e("./GenericWorker"),i=e("../crc32");function s(){n.call(this,"Crc32Probe"),this.withStreamInfo("crc32",0);}e("../utils").inherits(s,n),s.prototype.processChunk=function(e){this.streamInfo.crc32=i(e.data,this.streamInfo.crc32||0),this.push(e);},t.exports=s;},{"../crc32":4,"../utils":32,"./GenericWorker":28}],26:[function(e,t,r){var n=e("../utils"),i=e("./GenericWorker");function s(e){i.call(this,"DataLengthProbe for "+e),this.propName=e,this.withStreamInfo(e,0);}n.inherits(s,i),s.prototype.processChunk=function(e){if(e){var t=this.streamInfo[this.propName]||0;this.streamInfo[this.propName]=t+e.data.length;}i.prototype.processChunk.call(this,e);},t.exports=s;},{"../utils":32,"./GenericWorker":28}],27:[function(e,t,r){var n=e("../utils"),i=e("./GenericWorker");function s(e){i.call(this,"DataWorker");var t=this;this.dataIsReady=!1,this.index=0,this.max=0,this.data=null,this.type="",this._tickScheduled=!1,e.then(function(e){t.dataIsReady=!0,t.data=e,t.max=e&&e.length||0,t.type=n.getTypeOf(e),t.isPaused||t._tickAndRepeat();},function(e){t.error(e);});}n.inherits(s,i),s.prototype.cleanUp=function(){i.prototype.cleanUp.call(this),this.data=null;},s.prototype.resume=function(){return !!i.prototype.resume.call(this)&&(!this._tickScheduled&&this.dataIsReady&&(this._tickScheduled=!0,n.delay(this._tickAndRepeat,[],this)),!0)},s.prototype._tickAndRepeat=function(){this._tickScheduled=!1,this.isPaused||this.isFinished||(this._tick(),this.isFinished||(n.delay(this._tickAndRepeat,[],this),this._tickScheduled=!0));},s.prototype._tick=function(){if(this.isPaused||this.isFinished)return !1;var e=null,t=Math.min(this.max,this.index+16384);if(this.index>=this.max)return this.end();switch(this.type){case"string":e=this.data.substring(this.index,t);break;case"uint8array":e=this.data.subarray(this.index,t);break;case"array":case"nodebuffer":e=this.data.slice(this.index,t);}return this.index=t,this.push({data:e,meta:{percent:this.max?this.index/this.max*100:0}})},t.exports=s;},{"../utils":32,"./GenericWorker":28}],28:[function(e,t,r){function n(e){this.name=e||"default",this.streamInfo={},this.generatedError=null,this.extraStreamInfo={},this.isPaused=!0,this.isFinished=!1,this.isLocked=!1,this._listeners={data:[],end:[],error:[]},this.previous=null;}n.prototype={push:function(e){this.emit("data",e);},end:function(){if(this.isFinished)return !1;this.flush();try{this.emit("end"),this.cleanUp(),this.isFinished=!0;}catch(e){this.emit("error",e);}return !0},error:function(e){return !this.isFinished&&(this.isPaused?this.generatedError=e:(this.isFinished=!0,this.emit("error",e),this.previous&&this.previous.error(e),this.cleanUp()),!0)},on:function(e,t){return this._listeners[e].push(t),this},cleanUp:function(){this.streamInfo=this.generatedError=this.extraStreamInfo=null,this._listeners=[];},emit:function(e,t){if(this._listeners[e])for(var r=0;r<this._listeners[e].length;r++)this._listeners[e][r].call(this,t);},pipe:function(e){return e.registerPrevious(this)},registerPrevious:function(e){if(this.isLocked)throw new Error("The stream '"+this+"' has already been used.");this.streamInfo=e.streamInfo,this.mergeStreamInfo(),this.previous=e;var t=this;return e.on("data",function(e){t.processChunk(e);}),e.on("end",function(){t.end();}),e.on("error",function(e){t.error(e);}),this},pause:function(){return !this.isPaused&&!this.isFinished&&(this.isPaused=!0,this.previous&&this.previous.pause(),!0)},resume:function(){if(!this.isPaused||this.isFinished)return !1;var e=this.isPaused=!1;return this.generatedError&&(this.error(this.generatedError),e=!0),this.previous&&this.previous.resume(),!e},flush:function(){},processChunk:function(e){this.push(e);},withStreamInfo:function(e,t){return this.extraStreamInfo[e]=t,this.mergeStreamInfo(),this},mergeStreamInfo:function(){for(var e in this.extraStreamInfo)this.extraStreamInfo.hasOwnProperty(e)&&(this.streamInfo[e]=this.extraStreamInfo[e]);},lock:function(){if(this.isLocked)throw new Error("The stream '"+this+"' has already been used.");this.isLocked=!0,this.previous&&this.previous.lock();},toString:function(){var e="Worker "+this.name;return this.previous?this.previous+" -> "+e:e}},t.exports=n;},{}],29:[function(e,t,r){var h=e("../utils"),i=e("./ConvertWorker"),s=e("./GenericWorker"),f=e("../base64"),n=e("../support"),a=e("../external"),o=null;if(n.nodestream)try{o=e("../nodejs/NodejsStreamOutputAdapter");}catch(e){}function u(e,t,r){var n=t;switch(t){case"blob":case"arraybuffer":n="uint8array";break;case"base64":n="string";}try{this._internalType=n,this._outputType=t,this._mimeType=r,h.checkSupport(n),this._worker=e.pipe(new i(n)),e.lock();}catch(e){this._worker=new s("error"),this._worker.error(e);}}u.prototype={accumulate:function(e){return o=this,u=e,new a.Promise(function(t,r){var n=[],i=o._internalType,s=o._outputType,a=o._mimeType;o.on("data",function(e,t){n.push(e),u&&u(t);}).on("error",function(e){n=[],r(e);}).on("end",function(){try{var e=function(e,t,r){switch(e){case"blob":return h.newBlob(h.transformTo("arraybuffer",t),r);case"base64":return f.encode(t);default:return h.transformTo(e,t)}}(s,function(e,t){var r,n=0,i=null,s=0;for(r=0;r<t.length;r++)s+=t[r].length;switch(e){case"string":return t.join("");case"array":return Array.prototype.concat.apply([],t);case"uint8array":for(i=new Uint8Array(s),r=0;r<t.length;r++)i.set(t[r],n),n+=t[r].length;return i;case"nodebuffer":return Buffer.concat(t);default:throw new Error("concat : unsupported type '"+e+"'")}}(i,n),a);t(e);}catch(e){r(e);}n=[];}).resume();});var o,u;},on:function(e,t){var r=this;return "data"===e?this._worker.on(e,function(e){t.call(r,e.data,e.meta);}):this._worker.on(e,function(){h.delay(t,arguments,r);}),this},resume:function(){return h.delay(this._worker.resume,[],this._worker),this},pause:function(){return this._worker.pause(),this},toNodejsStream:function(e){if(h.checkSupport("nodestream"),"nodebuffer"!==this._outputType)throw new Error(this._outputType+" is not supported by this method");return new o(this,{objectMode:"nodebuffer"!==this._outputType},e)}},t.exports=u;},{"../base64":1,"../external":6,"../nodejs/NodejsStreamOutputAdapter":13,"../support":30,"../utils":32,"./ConvertWorker":24,"./GenericWorker":28}],30:[function(e,t,r){if(r.base64=!0,r.array=!0,r.string=!0,r.arraybuffer="undefined"!=typeof ArrayBuffer&&"undefined"!=typeof Uint8Array,r.nodebuffer="undefined"!=typeof Buffer,r.uint8array="undefined"!=typeof Uint8Array,"undefined"==typeof ArrayBuffer)r.blob=!1;else {var n=new ArrayBuffer(0);try{r.blob=0===new Blob([n],{type:"application/zip"}).size;}catch(e){try{var i=new(self.BlobBuilder||self.WebKitBlobBuilder||self.MozBlobBuilder||self.MSBlobBuilder);i.append(n),r.blob=0===i.getBlob("application/zip").size;}catch(e){r.blob=!1;}}}try{r.nodestream=!!e("readable-stream").Readable;}catch(e){r.nodestream=!1;}},{"readable-stream":16}],31:[function(e,t,s){for(var o=e("./utils"),u=e("./support"),r=e("./nodejsUtils"),n=e("./stream/GenericWorker"),h=new Array(256),i=0;i<256;i++)h[i]=252<=i?6:248<=i?5:240<=i?4:224<=i?3:192<=i?2:1;function a(){n.call(this,"utf-8 decode"),this.leftOver=null;}function f(){n.call(this,"utf-8 encode");}h[254]=h[254]=1,s.utf8encode=function(e){return u.nodebuffer?r.newBufferFrom(e,"utf-8"):function(e){var t,r,n,i,s,a=e.length,o=0;for(i=0;i<a;i++)55296==(64512&(r=e.charCodeAt(i)))&&i+1<a&&56320==(64512&(n=e.charCodeAt(i+1)))&&(r=65536+(r-55296<<10)+(n-56320),i++),o+=r<128?1:r<2048?2:r<65536?3:4;for(t=u.uint8array?new Uint8Array(o):new Array(o),i=s=0;s<o;i++)55296==(64512&(r=e.charCodeAt(i)))&&i+1<a&&56320==(64512&(n=e.charCodeAt(i+1)))&&(r=65536+(r-55296<<10)+(n-56320),i++),r<128?t[s++]=r:(r<2048?t[s++]=192|r>>>6:(r<65536?t[s++]=224|r>>>12:(t[s++]=240|r>>>18,t[s++]=128|r>>>12&63),t[s++]=128|r>>>6&63),t[s++]=128|63&r);return t}(e)},s.utf8decode=function(e){return u.nodebuffer?o.transformTo("nodebuffer",e).toString("utf-8"):function(e){var t,r,n,i,s=e.length,a=new Array(2*s);for(t=r=0;t<s;)if((n=e[t++])<128)a[r++]=n;else if(4<(i=h[n]))a[r++]=65533,t+=i-1;else {for(n&=2===i?31:3===i?15:7;1<i&&t<s;)n=n<<6|63&e[t++],i--;1<i?a[r++]=65533:n<65536?a[r++]=n:(n-=65536,a[r++]=55296|n>>10&1023,a[r++]=56320|1023&n);}return a.length!==r&&(a.subarray?a=a.subarray(0,r):a.length=r),o.applyFromCharCode(a)}(e=o.transformTo(u.uint8array?"uint8array":"array",e))},o.inherits(a,n),a.prototype.processChunk=function(e){var t=o.transformTo(u.uint8array?"uint8array":"array",e.data);if(this.leftOver&&this.leftOver.length){if(u.uint8array){var r=t;(t=new Uint8Array(r.length+this.leftOver.length)).set(this.leftOver,0),t.set(r,this.leftOver.length);}else t=this.leftOver.concat(t);this.leftOver=null;}var n=function(e,t){var r;for((t=t||e.length)>e.length&&(t=e.length),r=t-1;0<=r&&128==(192&e[r]);)r--;return r<0?t:0===r?t:r+h[e[r]]>t?r:t}(t),i=t;n!==t.length&&(u.uint8array?(i=t.subarray(0,n),this.leftOver=t.subarray(n,t.length)):(i=t.slice(0,n),this.leftOver=t.slice(n,t.length))),this.push({data:s.utf8decode(i),meta:e.meta});},a.prototype.flush=function(){this.leftOver&&this.leftOver.length&&(this.push({data:s.utf8decode(this.leftOver),meta:{}}),this.leftOver=null);},s.Utf8DecodeWorker=a,o.inherits(f,n),f.prototype.processChunk=function(e){this.push({data:s.utf8encode(e.data),meta:e.meta});},s.Utf8EncodeWorker=f;},{"./nodejsUtils":14,"./stream/GenericWorker":28,"./support":30,"./utils":32}],32:[function(e,t,o){var u=e("./support"),h=e("./base64"),r=e("./nodejsUtils"),n=e("set-immediate-shim"),f=e("./external");function i(e){return e}function l(e,t){for(var r=0;r<e.length;++r)t[r]=255&e.charCodeAt(r);return t}o.newBlob=function(t,r){o.checkSupport("blob");try{return new Blob([t],{type:r})}catch(e){try{var n=new(self.BlobBuilder||self.WebKitBlobBuilder||self.MozBlobBuilder||self.MSBlobBuilder);return n.append(t),n.getBlob(r)}catch(e){throw new Error("Bug : can't construct the Blob.")}}};var s={stringifyByChunk:function(e,t,r){var n=[],i=0,s=e.length;if(s<=r)return String.fromCharCode.apply(null,e);for(;i<s;)"array"===t||"nodebuffer"===t?n.push(String.fromCharCode.apply(null,e.slice(i,Math.min(i+r,s)))):n.push(String.fromCharCode.apply(null,e.subarray(i,Math.min(i+r,s)))),i+=r;return n.join("")},stringifyByChar:function(e){for(var t="",r=0;r<e.length;r++)t+=String.fromCharCode(e[r]);return t},applyCanBeUsed:{uint8array:function(){try{return u.uint8array&&1===String.fromCharCode.apply(null,new Uint8Array(1)).length}catch(e){return !1}}(),nodebuffer:function(){try{return u.nodebuffer&&1===String.fromCharCode.apply(null,r.allocBuffer(1)).length}catch(e){return !1}}()}};function a(e){var t=65536,r=o.getTypeOf(e),n=!0;if("uint8array"===r?n=s.applyCanBeUsed.uint8array:"nodebuffer"===r&&(n=s.applyCanBeUsed.nodebuffer),n)for(;1<t;)try{return s.stringifyByChunk(e,r,t)}catch(e){t=Math.floor(t/2);}return s.stringifyByChar(e)}function d(e,t){for(var r=0;r<e.length;r++)t[r]=e[r];return t}o.applyFromCharCode=a;var c={};c.string={string:i,array:function(e){return l(e,new Array(e.length))},arraybuffer:function(e){return c.string.uint8array(e).buffer},uint8array:function(e){return l(e,new Uint8Array(e.length))},nodebuffer:function(e){return l(e,r.allocBuffer(e.length))}},c.array={string:a,array:i,arraybuffer:function(e){return new Uint8Array(e).buffer},uint8array:function(e){return new Uint8Array(e)},nodebuffer:function(e){return r.newBufferFrom(e)}},c.arraybuffer={string:function(e){return a(new Uint8Array(e))},array:function(e){return d(new Uint8Array(e),new Array(e.byteLength))},arraybuffer:i,uint8array:function(e){return new Uint8Array(e)},nodebuffer:function(e){return r.newBufferFrom(new Uint8Array(e))}},c.uint8array={string:a,array:function(e){return d(e,new Array(e.length))},arraybuffer:function(e){return e.buffer},uint8array:i,nodebuffer:function(e){return r.newBufferFrom(e)}},c.nodebuffer={string:a,array:function(e){return d(e,new Array(e.length))},arraybuffer:function(e){return c.nodebuffer.uint8array(e).buffer},uint8array:function(e){return d(e,new Uint8Array(e.length))},nodebuffer:i},o.transformTo=function(e,t){if(t=t||"",!e)return t;o.checkSupport(e);var r=o.getTypeOf(t);return c[r][e](t)},o.getTypeOf=function(e){return "string"==typeof e?"string":"[object Array]"===Object.prototype.toString.call(e)?"array":u.nodebuffer&&r.isBuffer(e)?"nodebuffer":u.uint8array&&e instanceof Uint8Array?"uint8array":u.arraybuffer&&e instanceof ArrayBuffer?"arraybuffer":void 0},o.checkSupport=function(e){if(!u[e.toLowerCase()])throw new Error(e+" is not supported by this platform")},o.MAX_VALUE_16BITS=65535,o.MAX_VALUE_32BITS=-1,o.pretty=function(e){var t,r,n="";for(r=0;r<(e||"").length;r++)n+="\\x"+((t=e.charCodeAt(r))<16?"0":"")+t.toString(16).toUpperCase();return n},o.delay=function(e,t,r){n(function(){e.apply(r||null,t||[]);});},o.inherits=function(e,t){function r(){}r.prototype=t.prototype,e.prototype=new r;},o.extend=function(){var e,t,r={};for(e=0;e<arguments.length;e++)for(t in arguments[e])arguments[e].hasOwnProperty(t)&&void 0===r[t]&&(r[t]=arguments[e][t]);return r},o.prepareContent=function(n,e,i,s,a){return f.Promise.resolve(e).then(function(n){return u.blob&&(n instanceof Blob||-1!==["[object File]","[object Blob]"].indexOf(Object.prototype.toString.call(n)))&&"undefined"!=typeof FileReader?new f.Promise(function(t,r){var e=new FileReader;e.onload=function(e){t(e.target.result);},e.onerror=function(e){r(e.target.error);},e.readAsArrayBuffer(n);}):n}).then(function(e){var t,r=o.getTypeOf(e);return r?("arraybuffer"===r?e=o.transformTo("uint8array",e):"string"===r&&(a?e=h.decode(e):i&&!0!==s&&(e=l(t=e,u.uint8array?new Uint8Array(t.length):new Array(t.length)))),e):f.Promise.reject(new Error("Can't read the data of '"+n+"'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"))})};},{"./base64":1,"./external":6,"./nodejsUtils":14,"./support":30,"set-immediate-shim":54}],33:[function(e,t,r){var n=e("./reader/readerFor"),i=e("./utils"),s=e("./signature"),a=e("./zipEntry"),o=(e("./utf8"),e("./support"));function u(e){this.files=[],this.loadOptions=e;}u.prototype={checkSignature:function(e){if(!this.reader.readAndCheckSignature(e)){this.reader.index-=4;var t=this.reader.readString(4);throw new Error("Corrupted zip or bug: unexpected signature ("+i.pretty(t)+", expected "+i.pretty(e)+")")}},isSignature:function(e,t){var r=this.reader.index;this.reader.setIndex(e);var n=this.reader.readString(4)===t;return this.reader.setIndex(r),n},readBlockEndOfCentral:function(){this.diskNumber=this.reader.readInt(2),this.diskWithCentralDirStart=this.reader.readInt(2),this.centralDirRecordsOnThisDisk=this.reader.readInt(2),this.centralDirRecords=this.reader.readInt(2),this.centralDirSize=this.reader.readInt(4),this.centralDirOffset=this.reader.readInt(4),this.zipCommentLength=this.reader.readInt(2);var e=this.reader.readData(this.zipCommentLength),t=o.uint8array?"uint8array":"array",r=i.transformTo(t,e);this.zipComment=this.loadOptions.decodeFileName(r);},readBlockZip64EndOfCentral:function(){this.zip64EndOfCentralSize=this.reader.readInt(8),this.reader.skip(4),this.diskNumber=this.reader.readInt(4),this.diskWithCentralDirStart=this.reader.readInt(4),this.centralDirRecordsOnThisDisk=this.reader.readInt(8),this.centralDirRecords=this.reader.readInt(8),this.centralDirSize=this.reader.readInt(8),this.centralDirOffset=this.reader.readInt(8),this.zip64ExtensibleData={};for(var e,t,r,n=this.zip64EndOfCentralSize-44;0<n;)e=this.reader.readInt(2),t=this.reader.readInt(4),r=this.reader.readData(t),this.zip64ExtensibleData[e]={id:e,length:t,value:r};},readBlockZip64EndOfCentralLocator:function(){if(this.diskWithZip64CentralDirStart=this.reader.readInt(4),this.relativeOffsetEndOfZip64CentralDir=this.reader.readInt(8),this.disksCount=this.reader.readInt(4),1<this.disksCount)throw new Error("Multi-volumes zip are not supported")},readLocalFiles:function(){var e,t;for(e=0;e<this.files.length;e++)t=this.files[e],this.reader.setIndex(t.localHeaderOffset),this.checkSignature(s.LOCAL_FILE_HEADER),t.readLocalPart(this.reader),t.handleUTF8(),t.processAttributes();},readCentralDir:function(){var e;for(this.reader.setIndex(this.centralDirOffset);this.reader.readAndCheckSignature(s.CENTRAL_FILE_HEADER);)(e=new a({zip64:this.zip64},this.loadOptions)).readCentralPart(this.reader),this.files.push(e);if(this.centralDirRecords!==this.files.length&&0!==this.centralDirRecords&&0===this.files.length)throw new Error("Corrupted zip or bug: expected "+this.centralDirRecords+" records in central dir, got "+this.files.length)},readEndOfCentral:function(){var e=this.reader.lastIndexOfSignature(s.CENTRAL_DIRECTORY_END);if(e<0)throw this.isSignature(0,s.LOCAL_FILE_HEADER)?new Error("Corrupted zip: can't find end of central directory"):new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html");this.reader.setIndex(e);var t=e;if(this.checkSignature(s.CENTRAL_DIRECTORY_END),this.readBlockEndOfCentral(),this.diskNumber===i.MAX_VALUE_16BITS||this.diskWithCentralDirStart===i.MAX_VALUE_16BITS||this.centralDirRecordsOnThisDisk===i.MAX_VALUE_16BITS||this.centralDirRecords===i.MAX_VALUE_16BITS||this.centralDirSize===i.MAX_VALUE_32BITS||this.centralDirOffset===i.MAX_VALUE_32BITS){if(this.zip64=!0,(e=this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR))<0)throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");if(this.reader.setIndex(e),this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR),this.readBlockZip64EndOfCentralLocator(),!this.isSignature(this.relativeOffsetEndOfZip64CentralDir,s.ZIP64_CENTRAL_DIRECTORY_END)&&(this.relativeOffsetEndOfZip64CentralDir=this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_END),this.relativeOffsetEndOfZip64CentralDir<0))throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir),this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_END),this.readBlockZip64EndOfCentral();}var r=this.centralDirOffset+this.centralDirSize;this.zip64&&(r+=20,r+=12+this.zip64EndOfCentralSize);var n=t-r;if(0<n)this.isSignature(t,s.CENTRAL_FILE_HEADER)||(this.reader.zero=n);else if(n<0)throw new Error("Corrupted zip: missing "+Math.abs(n)+" bytes.")},prepareReader:function(e){this.reader=n(e);},load:function(e){this.prepareReader(e),this.readEndOfCentral(),this.readCentralDir(),this.readLocalFiles();}},t.exports=u;},{"./reader/readerFor":22,"./signature":23,"./support":30,"./utf8":31,"./utils":32,"./zipEntry":34}],34:[function(e,t,r){var n=e("./reader/readerFor"),s=e("./utils"),i=e("./compressedObject"),a=e("./crc32"),o=e("./utf8"),u=e("./compressions"),h=e("./support");function f(e,t){this.options=e,this.loadOptions=t;}f.prototype={isEncrypted:function(){return 1==(1&this.bitFlag)},useUTF8:function(){return 2048==(2048&this.bitFlag)},readLocalPart:function(e){var t,r;if(e.skip(22),this.fileNameLength=e.readInt(2),r=e.readInt(2),this.fileName=e.readData(this.fileNameLength),e.skip(r),-1===this.compressedSize||-1===this.uncompressedSize)throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");if(null===(t=function(e){for(var t in u)if(u.hasOwnProperty(t)&&u[t].magic===e)return u[t];return null}(this.compressionMethod)))throw new Error("Corrupted zip : compression "+s.pretty(this.compressionMethod)+" unknown (inner file : "+s.transformTo("string",this.fileName)+")");this.decompressed=new i(this.compressedSize,this.uncompressedSize,this.crc32,t,e.readData(this.compressedSize));},readCentralPart:function(e){this.versionMadeBy=e.readInt(2),e.skip(2),this.bitFlag=e.readInt(2),this.compressionMethod=e.readString(2),this.date=e.readDate(),this.crc32=e.readInt(4),this.compressedSize=e.readInt(4),this.uncompressedSize=e.readInt(4);var t=e.readInt(2);if(this.extraFieldsLength=e.readInt(2),this.fileCommentLength=e.readInt(2),this.diskNumberStart=e.readInt(2),this.internalFileAttributes=e.readInt(2),this.externalFileAttributes=e.readInt(4),this.localHeaderOffset=e.readInt(4),this.isEncrypted())throw new Error("Encrypted zip are not supported");e.skip(t),this.readExtraFields(e),this.parseZIP64ExtraField(e),this.fileComment=e.readData(this.fileCommentLength);},processAttributes:function(){this.unixPermissions=null,this.dosPermissions=null;var e=this.versionMadeBy>>8;this.dir=!!(16&this.externalFileAttributes),0==e&&(this.dosPermissions=63&this.externalFileAttributes),3==e&&(this.unixPermissions=this.externalFileAttributes>>16&65535),this.dir||"/"!==this.fileNameStr.slice(-1)||(this.dir=!0);},parseZIP64ExtraField:function(e){if(this.extraFields[1]){var t=n(this.extraFields[1].value);this.uncompressedSize===s.MAX_VALUE_32BITS&&(this.uncompressedSize=t.readInt(8)),this.compressedSize===s.MAX_VALUE_32BITS&&(this.compressedSize=t.readInt(8)),this.localHeaderOffset===s.MAX_VALUE_32BITS&&(this.localHeaderOffset=t.readInt(8)),this.diskNumberStart===s.MAX_VALUE_32BITS&&(this.diskNumberStart=t.readInt(4));}},readExtraFields:function(e){var t,r,n,i=e.index+this.extraFieldsLength;for(this.extraFields||(this.extraFields={});e.index+4<i;)t=e.readInt(2),r=e.readInt(2),n=e.readData(r),this.extraFields[t]={id:t,length:r,value:n};e.setIndex(i);},handleUTF8:function(){var e=h.uint8array?"uint8array":"array";if(this.useUTF8())this.fileNameStr=o.utf8decode(this.fileName),this.fileCommentStr=o.utf8decode(this.fileComment);else {var t=this.findExtraFieldUnicodePath();if(null!==t)this.fileNameStr=t;else {var r=s.transformTo(e,this.fileName);this.fileNameStr=this.loadOptions.decodeFileName(r);}var n=this.findExtraFieldUnicodeComment();if(null!==n)this.fileCommentStr=n;else {var i=s.transformTo(e,this.fileComment);this.fileCommentStr=this.loadOptions.decodeFileName(i);}}},findExtraFieldUnicodePath:function(){var e=this.extraFields[28789];if(e){var t=n(e.value);return 1!==t.readInt(1)?null:a(this.fileName)!==t.readInt(4)?null:o.utf8decode(t.readData(e.length-5))}return null},findExtraFieldUnicodeComment:function(){var e=this.extraFields[25461];if(e){var t=n(e.value);return 1!==t.readInt(1)?null:a(this.fileComment)!==t.readInt(4)?null:o.utf8decode(t.readData(e.length-5))}return null}},t.exports=f;},{"./compressedObject":2,"./compressions":3,"./crc32":4,"./reader/readerFor":22,"./support":30,"./utf8":31,"./utils":32}],35:[function(e,t,r){function n(e,t,r){this.name=e,this.dir=r.dir,this.date=r.date,this.comment=r.comment,this.unixPermissions=r.unixPermissions,this.dosPermissions=r.dosPermissions,this._data=t,this._dataBinary=r.binary,this.options={compression:r.compression,compressionOptions:r.compressionOptions};}var s=e("./stream/StreamHelper"),i=e("./stream/DataWorker"),a=e("./utf8"),o=e("./compressedObject"),u=e("./stream/GenericWorker");n.prototype={internalStream:function(e){var t=null,r="string";try{if(!e)throw new Error("No output type specified.");var n="string"===(r=e.toLowerCase())||"text"===r;"binarystring"!==r&&"text"!==r||(r="string"),t=this._decompressWorker();var i=!this._dataBinary;i&&!n&&(t=t.pipe(new a.Utf8EncodeWorker)),!i&&n&&(t=t.pipe(new a.Utf8DecodeWorker));}catch(e){(t=new u("error")).error(e);}return new s(t,r,"")},async:function(e,t){return this.internalStream(e).accumulate(t)},nodeStream:function(e,t){return this.internalStream(e||"nodebuffer").toNodejsStream(t)},_compressWorker:function(e,t){if(this._data instanceof o&&this._data.compression.magic===e.magic)return this._data.getCompressedWorker();var r=this._decompressWorker();return this._dataBinary||(r=r.pipe(new a.Utf8EncodeWorker)),o.createWorkerFrom(r,e,t)},_decompressWorker:function(){return this._data instanceof o?this._data.getContentWorker():this._data instanceof u?this._data:new i(this._data)}};for(var h=["asText","asBinary","asNodeBuffer","asUint8Array","asArrayBuffer"],f=function(){throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.")},l=0;l<h.length;l++)n.prototype[h[l]]=f;t.exports=n;},{"./compressedObject":2,"./stream/DataWorker":27,"./stream/GenericWorker":28,"./stream/StreamHelper":29,"./utf8":31}],36:[function(e,f,t){(function(t){var r,n,e=t.MutationObserver||t.WebKitMutationObserver;if(e){var i=0,s=new e(h),a=t.document.createTextNode("");s.observe(a,{characterData:!0}),r=function(){a.data=i=++i%2;};}else if(t.setImmediate||void 0===t.MessageChannel)r="document"in t&&"onreadystatechange"in t.document.createElement("script")?function(){var e=t.document.createElement("script");e.onreadystatechange=function(){h(),e.onreadystatechange=null,e.parentNode.removeChild(e),e=null;},t.document.documentElement.appendChild(e);}:function(){setTimeout(h,0);};else {var o=new t.MessageChannel;o.port1.onmessage=h,r=function(){o.port2.postMessage(0);};}var u=[];function h(){var e,t;n=!0;for(var r=u.length;r;){for(t=u,u=[],e=-1;++e<r;)t[e]();r=u.length;}n=!1;}f.exports=function(e){1!==u.push(e)||n||r();};}).call(this,void 0!==r?r:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{});},{}],37:[function(e,t,r){var i=e("immediate");function h(){}var f={},s=["REJECTED"],a=["FULFILLED"],n=["PENDING"];function o(e){if("function"!=typeof e)throw new TypeError("resolver must be a function");this.state=n,this.queue=[],this.outcome=void 0,e!==h&&c(this,e);}function u(e,t,r){this.promise=e,"function"==typeof t&&(this.onFulfilled=t,this.callFulfilled=this.otherCallFulfilled),"function"==typeof r&&(this.onRejected=r,this.callRejected=this.otherCallRejected);}function l(t,r,n){i(function(){var e;try{e=r(n);}catch(e){return f.reject(t,e)}e===t?f.reject(t,new TypeError("Cannot resolve promise with itself")):f.resolve(t,e);});}function d(e){var t=e&&e.then;if(e&&("object"==typeof e||"function"==typeof e)&&"function"==typeof t)return function(){t.apply(e,arguments);}}function c(t,e){var r=!1;function n(e){r||(r=!0,f.reject(t,e));}function i(e){r||(r=!0,f.resolve(t,e));}var s=p(function(){e(i,n);});"error"===s.status&&n(s.value);}function p(e,t){var r={};try{r.value=e(t),r.status="success";}catch(e){r.status="error",r.value=e;}return r}(t.exports=o).prototype.finally=function(t){if("function"!=typeof t)return this;var r=this.constructor;return this.then(function(e){return r.resolve(t()).then(function(){return e})},function(e){return r.resolve(t()).then(function(){throw e})})},o.prototype.catch=function(e){return this.then(null,e)},o.prototype.then=function(e,t){if("function"!=typeof e&&this.state===a||"function"!=typeof t&&this.state===s)return this;var r=new this.constructor(h);return this.state!==n?l(r,this.state===a?e:t,this.outcome):this.queue.push(new u(r,e,t)),r},u.prototype.callFulfilled=function(e){f.resolve(this.promise,e);},u.prototype.otherCallFulfilled=function(e){l(this.promise,this.onFulfilled,e);},u.prototype.callRejected=function(e){f.reject(this.promise,e);},u.prototype.otherCallRejected=function(e){l(this.promise,this.onRejected,e);},f.resolve=function(e,t){var r=p(d,t);if("error"===r.status)return f.reject(e,r.value);var n=r.value;if(n)c(e,n);else {e.state=a,e.outcome=t;for(var i=-1,s=e.queue.length;++i<s;)e.queue[i].callFulfilled(t);}return e},f.reject=function(e,t){e.state=s,e.outcome=t;for(var r=-1,n=e.queue.length;++r<n;)e.queue[r].callRejected(t);return e},o.resolve=function(e){return e instanceof this?e:f.resolve(new this(h),e)},o.reject=function(e){var t=new this(h);return f.reject(t,e)},o.all=function(e){var r=this;if("[object Array]"!==Object.prototype.toString.call(e))return this.reject(new TypeError("must be an array"));var n=e.length,i=!1;if(!n)return this.resolve([]);for(var s=new Array(n),a=0,t=-1,o=new this(h);++t<n;)u(e[t],t);return o;function u(e,t){r.resolve(e).then(function(e){s[t]=e,++a!==n||i||(i=!0,f.resolve(o,s));},function(e){i||(i=!0,f.reject(o,e));});}},o.race=function(e){if("[object Array]"!==Object.prototype.toString.call(e))return this.reject(new TypeError("must be an array"));var t=e.length,r=!1;if(!t)return this.resolve([]);for(var n,i=-1,s=new this(h);++i<t;)n=e[i],this.resolve(n).then(function(e){r||(r=!0,f.resolve(s,e));},function(e){r||(r=!0,f.reject(s,e));});return s};},{immediate:36}],38:[function(e,t,r){var n={};(0, e("./lib/utils/common").assign)(n,e("./lib/deflate"),e("./lib/inflate"),e("./lib/zlib/constants")),t.exports=n;},{"./lib/deflate":39,"./lib/inflate":40,"./lib/utils/common":41,"./lib/zlib/constants":44}],39:[function(e,t,r){var a=e("./zlib/deflate"),o=e("./utils/common"),u=e("./utils/strings"),i=e("./zlib/messages"),s=e("./zlib/zstream"),h=Object.prototype.toString,f=0,l=-1,d=0,c=8;function p(e){if(!(this instanceof p))return new p(e);this.options=o.assign({level:l,method:c,chunkSize:16384,windowBits:15,memLevel:8,strategy:d,to:""},e||{});var t=this.options;t.raw&&0<t.windowBits?t.windowBits=-t.windowBits:t.gzip&&0<t.windowBits&&t.windowBits<16&&(t.windowBits+=16),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new s,this.strm.avail_out=0;var r=a.deflateInit2(this.strm,t.level,t.method,t.windowBits,t.memLevel,t.strategy);if(r!==f)throw new Error(i[r]);if(t.header&&a.deflateSetHeader(this.strm,t.header),t.dictionary){var n;if(n="string"==typeof t.dictionary?u.string2buf(t.dictionary):"[object ArrayBuffer]"===h.call(t.dictionary)?new Uint8Array(t.dictionary):t.dictionary,(r=a.deflateSetDictionary(this.strm,n))!==f)throw new Error(i[r]);this._dict_set=!0;}}function n(e,t){var r=new p(t);if(r.push(e,!0),r.err)throw r.msg||i[r.err];return r.result}p.prototype.push=function(e,t){var r,n,i=this.strm,s=this.options.chunkSize;if(this.ended)return !1;n=t===~~t?t:!0===t?4:0,"string"==typeof e?i.input=u.string2buf(e):"[object ArrayBuffer]"===h.call(e)?i.input=new Uint8Array(e):i.input=e,i.next_in=0,i.avail_in=i.input.length;do{if(0===i.avail_out&&(i.output=new o.Buf8(s),i.next_out=0,i.avail_out=s),1!==(r=a.deflate(i,n))&&r!==f)return this.onEnd(r),!(this.ended=!0);0!==i.avail_out&&(0!==i.avail_in||4!==n&&2!==n)||("string"===this.options.to?this.onData(u.buf2binstring(o.shrinkBuf(i.output,i.next_out))):this.onData(o.shrinkBuf(i.output,i.next_out)));}while((0<i.avail_in||0===i.avail_out)&&1!==r);return 4===n?(r=a.deflateEnd(this.strm),this.onEnd(r),this.ended=!0,r===f):2!==n||(this.onEnd(f),!(i.avail_out=0))},p.prototype.onData=function(e){this.chunks.push(e);},p.prototype.onEnd=function(e){e===f&&("string"===this.options.to?this.result=this.chunks.join(""):this.result=o.flattenChunks(this.chunks)),this.chunks=[],this.err=e,this.msg=this.strm.msg;},r.Deflate=p,r.deflate=n,r.deflateRaw=function(e,t){return (t=t||{}).raw=!0,n(e,t)},r.gzip=function(e,t){return (t=t||{}).gzip=!0,n(e,t)};},{"./utils/common":41,"./utils/strings":42,"./zlib/deflate":46,"./zlib/messages":51,"./zlib/zstream":53}],40:[function(e,t,r){var d=e("./zlib/inflate"),c=e("./utils/common"),p=e("./utils/strings"),m=e("./zlib/constants"),n=e("./zlib/messages"),i=e("./zlib/zstream"),s=e("./zlib/gzheader"),_=Object.prototype.toString;function a(e){if(!(this instanceof a))return new a(e);this.options=c.assign({chunkSize:16384,windowBits:0,to:""},e||{});var t=this.options;t.raw&&0<=t.windowBits&&t.windowBits<16&&(t.windowBits=-t.windowBits,0===t.windowBits&&(t.windowBits=-15)),!(0<=t.windowBits&&t.windowBits<16)||e&&e.windowBits||(t.windowBits+=32),15<t.windowBits&&t.windowBits<48&&0==(15&t.windowBits)&&(t.windowBits|=15),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new i,this.strm.avail_out=0;var r=d.inflateInit2(this.strm,t.windowBits);if(r!==m.Z_OK)throw new Error(n[r]);this.header=new s,d.inflateGetHeader(this.strm,this.header);}function o(e,t){var r=new a(t);if(r.push(e,!0),r.err)throw r.msg||n[r.err];return r.result}a.prototype.push=function(e,t){var r,n,i,s,a,o,u=this.strm,h=this.options.chunkSize,f=this.options.dictionary,l=!1;if(this.ended)return !1;n=t===~~t?t:!0===t?m.Z_FINISH:m.Z_NO_FLUSH,"string"==typeof e?u.input=p.binstring2buf(e):"[object ArrayBuffer]"===_.call(e)?u.input=new Uint8Array(e):u.input=e,u.next_in=0,u.avail_in=u.input.length;do{if(0===u.avail_out&&(u.output=new c.Buf8(h),u.next_out=0,u.avail_out=h),(r=d.inflate(u,m.Z_NO_FLUSH))===m.Z_NEED_DICT&&f&&(o="string"==typeof f?p.string2buf(f):"[object ArrayBuffer]"===_.call(f)?new Uint8Array(f):f,r=d.inflateSetDictionary(this.strm,o)),r===m.Z_BUF_ERROR&&!0===l&&(r=m.Z_OK,l=!1),r!==m.Z_STREAM_END&&r!==m.Z_OK)return this.onEnd(r),!(this.ended=!0);u.next_out&&(0!==u.avail_out&&r!==m.Z_STREAM_END&&(0!==u.avail_in||n!==m.Z_FINISH&&n!==m.Z_SYNC_FLUSH)||("string"===this.options.to?(i=p.utf8border(u.output,u.next_out),s=u.next_out-i,a=p.buf2string(u.output,i),u.next_out=s,u.avail_out=h-s,s&&c.arraySet(u.output,u.output,i,s,0),this.onData(a)):this.onData(c.shrinkBuf(u.output,u.next_out)))),0===u.avail_in&&0===u.avail_out&&(l=!0);}while((0<u.avail_in||0===u.avail_out)&&r!==m.Z_STREAM_END);return r===m.Z_STREAM_END&&(n=m.Z_FINISH),n===m.Z_FINISH?(r=d.inflateEnd(this.strm),this.onEnd(r),this.ended=!0,r===m.Z_OK):n!==m.Z_SYNC_FLUSH||(this.onEnd(m.Z_OK),!(u.avail_out=0))},a.prototype.onData=function(e){this.chunks.push(e);},a.prototype.onEnd=function(e){e===m.Z_OK&&("string"===this.options.to?this.result=this.chunks.join(""):this.result=c.flattenChunks(this.chunks)),this.chunks=[],this.err=e,this.msg=this.strm.msg;},r.Inflate=a,r.inflate=o,r.inflateRaw=function(e,t){return (t=t||{}).raw=!0,o(e,t)},r.ungzip=o;},{"./utils/common":41,"./utils/strings":42,"./zlib/constants":44,"./zlib/gzheader":47,"./zlib/inflate":49,"./zlib/messages":51,"./zlib/zstream":53}],41:[function(e,t,r){var n="undefined"!=typeof Uint8Array&&"undefined"!=typeof Uint16Array&&"undefined"!=typeof Int32Array;r.assign=function(e){for(var t=Array.prototype.slice.call(arguments,1);t.length;){var r=t.shift();if(r){if("object"!=typeof r)throw new TypeError(r+"must be non-object");for(var n in r)r.hasOwnProperty(n)&&(e[n]=r[n]);}}return e},r.shrinkBuf=function(e,t){return e.length===t?e:e.subarray?e.subarray(0,t):(e.length=t,e)};var i={arraySet:function(e,t,r,n,i){if(t.subarray&&e.subarray)e.set(t.subarray(r,r+n),i);else for(var s=0;s<n;s++)e[i+s]=t[r+s];},flattenChunks:function(e){var t,r,n,i,s,a;for(t=n=0,r=e.length;t<r;t++)n+=e[t].length;for(a=new Uint8Array(n),t=i=0,r=e.length;t<r;t++)s=e[t],a.set(s,i),i+=s.length;return a}},s={arraySet:function(e,t,r,n,i){for(var s=0;s<n;s++)e[i+s]=t[r+s];},flattenChunks:function(e){return [].concat.apply([],e)}};r.setTyped=function(e){e?(r.Buf8=Uint8Array,r.Buf16=Uint16Array,r.Buf32=Int32Array,r.assign(r,i)):(r.Buf8=Array,r.Buf16=Array,r.Buf32=Array,r.assign(r,s));},r.setTyped(n);},{}],42:[function(e,t,r){var u=e("./common"),i=!0,s=!0;try{String.fromCharCode.apply(null,[0]);}catch(e){i=!1;}try{String.fromCharCode.apply(null,new Uint8Array(1));}catch(e){s=!1;}for(var h=new u.Buf8(256),n=0;n<256;n++)h[n]=252<=n?6:248<=n?5:240<=n?4:224<=n?3:192<=n?2:1;function f(e,t){if(t<65537&&(e.subarray&&s||!e.subarray&&i))return String.fromCharCode.apply(null,u.shrinkBuf(e,t));for(var r="",n=0;n<t;n++)r+=String.fromCharCode(e[n]);return r}h[254]=h[254]=1,r.string2buf=function(e){var t,r,n,i,s,a=e.length,o=0;for(i=0;i<a;i++)55296==(64512&(r=e.charCodeAt(i)))&&i+1<a&&56320==(64512&(n=e.charCodeAt(i+1)))&&(r=65536+(r-55296<<10)+(n-56320),i++),o+=r<128?1:r<2048?2:r<65536?3:4;for(t=new u.Buf8(o),i=s=0;s<o;i++)55296==(64512&(r=e.charCodeAt(i)))&&i+1<a&&56320==(64512&(n=e.charCodeAt(i+1)))&&(r=65536+(r-55296<<10)+(n-56320),i++),r<128?t[s++]=r:(r<2048?t[s++]=192|r>>>6:(r<65536?t[s++]=224|r>>>12:(t[s++]=240|r>>>18,t[s++]=128|r>>>12&63),t[s++]=128|r>>>6&63),t[s++]=128|63&r);return t},r.buf2binstring=function(e){return f(e,e.length)},r.binstring2buf=function(e){for(var t=new u.Buf8(e.length),r=0,n=t.length;r<n;r++)t[r]=e.charCodeAt(r);return t},r.buf2string=function(e,t){var r,n,i,s,a=t||e.length,o=new Array(2*a);for(r=n=0;r<a;)if((i=e[r++])<128)o[n++]=i;else if(4<(s=h[i]))o[n++]=65533,r+=s-1;else {for(i&=2===s?31:3===s?15:7;1<s&&r<a;)i=i<<6|63&e[r++],s--;1<s?o[n++]=65533:i<65536?o[n++]=i:(i-=65536,o[n++]=55296|i>>10&1023,o[n++]=56320|1023&i);}return f(o,n)},r.utf8border=function(e,t){var r;for((t=t||e.length)>e.length&&(t=e.length),r=t-1;0<=r&&128==(192&e[r]);)r--;return r<0?t:0===r?t:r+h[e[r]]>t?r:t};},{"./common":41}],43:[function(e,t,r){t.exports=function(e,t,r,n){for(var i=65535&e|0,s=e>>>16&65535|0,a=0;0!==r;){for(r-=a=2e3<r?2e3:r;s=s+(i=i+t[n++]|0)|0,--a;);i%=65521,s%=65521;}return i|s<<16|0};},{}],44:[function(e,t,r){t.exports={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8};},{}],45:[function(e,t,r){var o=function(){for(var e,t=[],r=0;r<256;r++){e=r;for(var n=0;n<8;n++)e=1&e?3988292384^e>>>1:e>>>1;t[r]=e;}return t}();t.exports=function(e,t,r,n){var i=o,s=n+r;e^=-1;for(var a=n;a<s;a++)e=e>>>8^i[255&(e^t[a])];return -1^e};},{}],46:[function(e,t,r){var u,d=e("../utils/common"),h=e("./trees"),c=e("./adler32"),p=e("./crc32"),n=e("./messages"),f=0,l=0,m=-2,i=2,_=8,s=286,a=30,o=19,g=2*s+1,v=15,b=3,w=258,y=w+b+1,k=42,x=113;function S(e,t){return e.msg=n[t],t}function z(e){return (e<<1)-(4<e?9:0)}function E(e){for(var t=e.length;0<=--t;)e[t]=0;}function C(e){var t=e.state,r=t.pending;r>e.avail_out&&(r=e.avail_out),0!==r&&(d.arraySet(e.output,t.pending_buf,t.pending_out,r,e.next_out),e.next_out+=r,t.pending_out+=r,e.total_out+=r,e.avail_out-=r,t.pending-=r,0===t.pending&&(t.pending_out=0));}function A(e,t){h._tr_flush_block(e,0<=e.block_start?e.block_start:-1,e.strstart-e.block_start,t),e.block_start=e.strstart,C(e.strm);}function I(e,t){e.pending_buf[e.pending++]=t;}function O(e,t){e.pending_buf[e.pending++]=t>>>8&255,e.pending_buf[e.pending++]=255&t;}function B(e,t){var r,n,i=e.max_chain_length,s=e.strstart,a=e.prev_length,o=e.nice_match,u=e.strstart>e.w_size-y?e.strstart-(e.w_size-y):0,h=e.window,f=e.w_mask,l=e.prev,d=e.strstart+w,c=h[s+a-1],p=h[s+a];e.prev_length>=e.good_match&&(i>>=2),o>e.lookahead&&(o=e.lookahead);do{if(h[(r=t)+a]===p&&h[r+a-1]===c&&h[r]===h[s]&&h[++r]===h[s+1]){s+=2,r++;do{}while(h[++s]===h[++r]&&h[++s]===h[++r]&&h[++s]===h[++r]&&h[++s]===h[++r]&&h[++s]===h[++r]&&h[++s]===h[++r]&&h[++s]===h[++r]&&h[++s]===h[++r]&&s<d);if(n=w-(d-s),s=d-w,a<n){if(e.match_start=t,o<=(a=n))break;c=h[s+a-1],p=h[s+a];}}}while((t=l[t&f])>u&&0!=--i);return a<=e.lookahead?a:e.lookahead}function T(e){var t,r,n,i,s,a,o,u,h,f,l=e.w_size;do{if(i=e.window_size-e.lookahead-e.strstart,e.strstart>=l+(l-y)){for(d.arraySet(e.window,e.window,l,l,0),e.match_start-=l,e.strstart-=l,e.block_start-=l,t=r=e.hash_size;n=e.head[--t],e.head[t]=l<=n?n-l:0,--r;);for(t=r=l;n=e.prev[--t],e.prev[t]=l<=n?n-l:0,--r;);i+=l;}if(0===e.strm.avail_in)break;if(a=e.strm,o=e.window,u=e.strstart+e.lookahead,f=void 0,(h=i)<(f=a.avail_in)&&(f=h),r=0===f?0:(a.avail_in-=f,d.arraySet(o,a.input,a.next_in,f,u),1===a.state.wrap?a.adler=c(a.adler,o,f,u):2===a.state.wrap&&(a.adler=p(a.adler,o,f,u)),a.next_in+=f,a.total_in+=f,f),e.lookahead+=r,e.lookahead+e.insert>=b)for(s=e.strstart-e.insert,e.ins_h=e.window[s],e.ins_h=(e.ins_h<<e.hash_shift^e.window[s+1])&e.hash_mask;e.insert&&(e.ins_h=(e.ins_h<<e.hash_shift^e.window[s+b-1])&e.hash_mask,e.prev[s&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=s,s++,e.insert--,!(e.lookahead+e.insert<b)););}while(e.lookahead<y&&0!==e.strm.avail_in)}function R(e,t){for(var r,n;;){if(e.lookahead<y){if(T(e),e.lookahead<y&&t===f)return 1;if(0===e.lookahead)break}if(r=0,e.lookahead>=b&&(e.ins_h=(e.ins_h<<e.hash_shift^e.window[e.strstart+b-1])&e.hash_mask,r=e.prev[e.strstart&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=e.strstart),0!==r&&e.strstart-r<=e.w_size-y&&(e.match_length=B(e,r)),e.match_length>=b)if(n=h._tr_tally(e,e.strstart-e.match_start,e.match_length-b),e.lookahead-=e.match_length,e.match_length<=e.max_lazy_match&&e.lookahead>=b){for(e.match_length--;e.strstart++,e.ins_h=(e.ins_h<<e.hash_shift^e.window[e.strstart+b-1])&e.hash_mask,r=e.prev[e.strstart&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=e.strstart,0!=--e.match_length;);e.strstart++;}else e.strstart+=e.match_length,e.match_length=0,e.ins_h=e.window[e.strstart],e.ins_h=(e.ins_h<<e.hash_shift^e.window[e.strstart+1])&e.hash_mask;else n=h._tr_tally(e,0,e.window[e.strstart]),e.lookahead--,e.strstart++;if(n&&(A(e,!1),0===e.strm.avail_out))return 1}return e.insert=e.strstart<b-1?e.strstart:b-1,4===t?(A(e,!0),0===e.strm.avail_out?3:4):e.last_lit&&(A(e,!1),0===e.strm.avail_out)?1:2}function D(e,t){for(var r,n,i;;){if(e.lookahead<y){if(T(e),e.lookahead<y&&t===f)return 1;if(0===e.lookahead)break}if(r=0,e.lookahead>=b&&(e.ins_h=(e.ins_h<<e.hash_shift^e.window[e.strstart+b-1])&e.hash_mask,r=e.prev[e.strstart&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=e.strstart),e.prev_length=e.match_length,e.prev_match=e.match_start,e.match_length=b-1,0!==r&&e.prev_length<e.max_lazy_match&&e.strstart-r<=e.w_size-y&&(e.match_length=B(e,r),e.match_length<=5&&(1===e.strategy||e.match_length===b&&4096<e.strstart-e.match_start)&&(e.match_length=b-1)),e.prev_length>=b&&e.match_length<=e.prev_length){for(i=e.strstart+e.lookahead-b,n=h._tr_tally(e,e.strstart-1-e.prev_match,e.prev_length-b),e.lookahead-=e.prev_length-1,e.prev_length-=2;++e.strstart<=i&&(e.ins_h=(e.ins_h<<e.hash_shift^e.window[e.strstart+b-1])&e.hash_mask,r=e.prev[e.strstart&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=e.strstart),0!=--e.prev_length;);if(e.match_available=0,e.match_length=b-1,e.strstart++,n&&(A(e,!1),0===e.strm.avail_out))return 1}else if(e.match_available){if((n=h._tr_tally(e,0,e.window[e.strstart-1]))&&A(e,!1),e.strstart++,e.lookahead--,0===e.strm.avail_out)return 1}else e.match_available=1,e.strstart++,e.lookahead--;}return e.match_available&&(n=h._tr_tally(e,0,e.window[e.strstart-1]),e.match_available=0),e.insert=e.strstart<b-1?e.strstart:b-1,4===t?(A(e,!0),0===e.strm.avail_out?3:4):e.last_lit&&(A(e,!1),0===e.strm.avail_out)?1:2}function F(e,t,r,n,i){this.good_length=e,this.max_lazy=t,this.nice_length=r,this.max_chain=n,this.func=i;}function N(){this.strm=null,this.status=0,this.pending_buf=null,this.pending_buf_size=0,this.pending_out=0,this.pending=0,this.wrap=0,this.gzhead=null,this.gzindex=0,this.method=_,this.last_flush=-1,this.w_size=0,this.w_bits=0,this.w_mask=0,this.window=null,this.window_size=0,this.prev=null,this.head=null,this.ins_h=0,this.hash_size=0,this.hash_bits=0,this.hash_mask=0,this.hash_shift=0,this.block_start=0,this.match_length=0,this.prev_match=0,this.match_available=0,this.strstart=0,this.match_start=0,this.lookahead=0,this.prev_length=0,this.max_chain_length=0,this.max_lazy_match=0,this.level=0,this.strategy=0,this.good_match=0,this.nice_match=0,this.dyn_ltree=new d.Buf16(2*g),this.dyn_dtree=new d.Buf16(2*(2*a+1)),this.bl_tree=new d.Buf16(2*(2*o+1)),E(this.dyn_ltree),E(this.dyn_dtree),E(this.bl_tree),this.l_desc=null,this.d_desc=null,this.bl_desc=null,this.bl_count=new d.Buf16(v+1),this.heap=new d.Buf16(2*s+1),E(this.heap),this.heap_len=0,this.heap_max=0,this.depth=new d.Buf16(2*s+1),E(this.depth),this.l_buf=0,this.lit_bufsize=0,this.last_lit=0,this.d_buf=0,this.opt_len=0,this.static_len=0,this.matches=0,this.insert=0,this.bi_buf=0,this.bi_valid=0;}function U(e){var t;return e&&e.state?(e.total_in=e.total_out=0,e.data_type=i,(t=e.state).pending=0,t.pending_out=0,t.wrap<0&&(t.wrap=-t.wrap),t.status=t.wrap?k:x,e.adler=2===t.wrap?0:1,t.last_flush=f,h._tr_init(t),l):S(e,m)}function P(e){var t,r=U(e);return r===l&&((t=e.state).window_size=2*t.w_size,E(t.head),t.max_lazy_match=u[t.level].max_lazy,t.good_match=u[t.level].good_length,t.nice_match=u[t.level].nice_length,t.max_chain_length=u[t.level].max_chain,t.strstart=0,t.block_start=0,t.lookahead=0,t.insert=0,t.match_length=t.prev_length=b-1,t.match_available=0,t.ins_h=0),r}function L(e,t,r,n,i,s){if(!e)return m;var a=1;if(-1===t&&(t=6),n<0?(a=0,n=-n):15<n&&(a=2,n-=16),i<1||9<i||r!==_||n<8||15<n||t<0||9<t||s<0||4<s)return S(e,m);8===n&&(n=9);var o=new N;return (e.state=o).strm=e,o.wrap=a,o.gzhead=null,o.w_bits=n,o.w_size=1<<o.w_bits,o.w_mask=o.w_size-1,o.hash_bits=i+7,o.hash_size=1<<o.hash_bits,o.hash_mask=o.hash_size-1,o.hash_shift=~~((o.hash_bits+b-1)/b),o.window=new d.Buf8(2*o.w_size),o.head=new d.Buf16(o.hash_size),o.prev=new d.Buf16(o.w_size),o.lit_bufsize=1<<i+6,o.pending_buf_size=4*o.lit_bufsize,o.pending_buf=new d.Buf8(o.pending_buf_size),o.d_buf=1*o.lit_bufsize,o.l_buf=3*o.lit_bufsize,o.level=t,o.strategy=s,o.method=r,P(e)}u=[new F(0,0,0,0,function(e,t){var r=65535;for(r>e.pending_buf_size-5&&(r=e.pending_buf_size-5);;){if(e.lookahead<=1){if(T(e),0===e.lookahead&&t===f)return 1;if(0===e.lookahead)break}e.strstart+=e.lookahead,e.lookahead=0;var n=e.block_start+r;if((0===e.strstart||e.strstart>=n)&&(e.lookahead=e.strstart-n,e.strstart=n,A(e,!1),0===e.strm.avail_out))return 1;if(e.strstart-e.block_start>=e.w_size-y&&(A(e,!1),0===e.strm.avail_out))return 1}return e.insert=0,4===t?(A(e,!0),0===e.strm.avail_out?3:4):(e.strstart>e.block_start&&(A(e,!1),e.strm.avail_out),1)}),new F(4,4,8,4,R),new F(4,5,16,8,R),new F(4,6,32,32,R),new F(4,4,16,16,D),new F(8,16,32,32,D),new F(8,16,128,128,D),new F(8,32,128,256,D),new F(32,128,258,1024,D),new F(32,258,258,4096,D)],r.deflateInit=function(e,t){return L(e,t,_,15,8,0)},r.deflateInit2=L,r.deflateReset=P,r.deflateResetKeep=U,r.deflateSetHeader=function(e,t){return e&&e.state?2!==e.state.wrap?m:(e.state.gzhead=t,l):m},r.deflate=function(e,t){var r,n,i,s;if(!e||!e.state||5<t||t<0)return e?S(e,m):m;if(n=e.state,!e.output||!e.input&&0!==e.avail_in||666===n.status&&4!==t)return S(e,0===e.avail_out?-5:m);if(n.strm=e,r=n.last_flush,n.last_flush=t,n.status===k)if(2===n.wrap)e.adler=0,I(n,31),I(n,139),I(n,8),n.gzhead?(I(n,(n.gzhead.text?1:0)+(n.gzhead.hcrc?2:0)+(n.gzhead.extra?4:0)+(n.gzhead.name?8:0)+(n.gzhead.comment?16:0)),I(n,255&n.gzhead.time),I(n,n.gzhead.time>>8&255),I(n,n.gzhead.time>>16&255),I(n,n.gzhead.time>>24&255),I(n,9===n.level?2:2<=n.strategy||n.level<2?4:0),I(n,255&n.gzhead.os),n.gzhead.extra&&n.gzhead.extra.length&&(I(n,255&n.gzhead.extra.length),I(n,n.gzhead.extra.length>>8&255)),n.gzhead.hcrc&&(e.adler=p(e.adler,n.pending_buf,n.pending,0)),n.gzindex=0,n.status=69):(I(n,0),I(n,0),I(n,0),I(n,0),I(n,0),I(n,9===n.level?2:2<=n.strategy||n.level<2?4:0),I(n,3),n.status=x);else {var a=_+(n.w_bits-8<<4)<<8;a|=(2<=n.strategy||n.level<2?0:n.level<6?1:6===n.level?2:3)<<6,0!==n.strstart&&(a|=32),a+=31-a%31,n.status=x,O(n,a),0!==n.strstart&&(O(n,e.adler>>>16),O(n,65535&e.adler)),e.adler=1;}if(69===n.status)if(n.gzhead.extra){for(i=n.pending;n.gzindex<(65535&n.gzhead.extra.length)&&(n.pending!==n.pending_buf_size||(n.gzhead.hcrc&&n.pending>i&&(e.adler=p(e.adler,n.pending_buf,n.pending-i,i)),C(e),i=n.pending,n.pending!==n.pending_buf_size));)I(n,255&n.gzhead.extra[n.gzindex]),n.gzindex++;n.gzhead.hcrc&&n.pending>i&&(e.adler=p(e.adler,n.pending_buf,n.pending-i,i)),n.gzindex===n.gzhead.extra.length&&(n.gzindex=0,n.status=73);}else n.status=73;if(73===n.status)if(n.gzhead.name){i=n.pending;do{if(n.pending===n.pending_buf_size&&(n.gzhead.hcrc&&n.pending>i&&(e.adler=p(e.adler,n.pending_buf,n.pending-i,i)),C(e),i=n.pending,n.pending===n.pending_buf_size)){s=1;break}s=n.gzindex<n.gzhead.name.length?255&n.gzhead.name.charCodeAt(n.gzindex++):0,I(n,s);}while(0!==s);n.gzhead.hcrc&&n.pending>i&&(e.adler=p(e.adler,n.pending_buf,n.pending-i,i)),0===s&&(n.gzindex=0,n.status=91);}else n.status=91;if(91===n.status)if(n.gzhead.comment){i=n.pending;do{if(n.pending===n.pending_buf_size&&(n.gzhead.hcrc&&n.pending>i&&(e.adler=p(e.adler,n.pending_buf,n.pending-i,i)),C(e),i=n.pending,n.pending===n.pending_buf_size)){s=1;break}s=n.gzindex<n.gzhead.comment.length?255&n.gzhead.comment.charCodeAt(n.gzindex++):0,I(n,s);}while(0!==s);n.gzhead.hcrc&&n.pending>i&&(e.adler=p(e.adler,n.pending_buf,n.pending-i,i)),0===s&&(n.status=103);}else n.status=103;if(103===n.status&&(n.gzhead.hcrc?(n.pending+2>n.pending_buf_size&&C(e),n.pending+2<=n.pending_buf_size&&(I(n,255&e.adler),I(n,e.adler>>8&255),e.adler=0,n.status=x)):n.status=x),0!==n.pending){if(C(e),0===e.avail_out)return n.last_flush=-1,l}else if(0===e.avail_in&&z(t)<=z(r)&&4!==t)return S(e,-5);if(666===n.status&&0!==e.avail_in)return S(e,-5);if(0!==e.avail_in||0!==n.lookahead||t!==f&&666!==n.status){var o=2===n.strategy?function(e,t){for(var r;;){if(0===e.lookahead&&(T(e),0===e.lookahead)){if(t===f)return 1;break}if(e.match_length=0,r=h._tr_tally(e,0,e.window[e.strstart]),e.lookahead--,e.strstart++,r&&(A(e,!1),0===e.strm.avail_out))return 1}return e.insert=0,4===t?(A(e,!0),0===e.strm.avail_out?3:4):e.last_lit&&(A(e,!1),0===e.strm.avail_out)?1:2}(n,t):3===n.strategy?function(e,t){for(var r,n,i,s,a=e.window;;){if(e.lookahead<=w){if(T(e),e.lookahead<=w&&t===f)return 1;if(0===e.lookahead)break}if(e.match_length=0,e.lookahead>=b&&0<e.strstart&&(n=a[i=e.strstart-1])===a[++i]&&n===a[++i]&&n===a[++i]){s=e.strstart+w;do{}while(n===a[++i]&&n===a[++i]&&n===a[++i]&&n===a[++i]&&n===a[++i]&&n===a[++i]&&n===a[++i]&&n===a[++i]&&i<s);e.match_length=w-(s-i),e.match_length>e.lookahead&&(e.match_length=e.lookahead);}if(e.match_length>=b?(r=h._tr_tally(e,1,e.match_length-b),e.lookahead-=e.match_length,e.strstart+=e.match_length,e.match_length=0):(r=h._tr_tally(e,0,e.window[e.strstart]),e.lookahead--,e.strstart++),r&&(A(e,!1),0===e.strm.avail_out))return 1}return e.insert=0,4===t?(A(e,!0),0===e.strm.avail_out?3:4):e.last_lit&&(A(e,!1),0===e.strm.avail_out)?1:2}(n,t):u[n.level].func(n,t);if(3!==o&&4!==o||(n.status=666),1===o||3===o)return 0===e.avail_out&&(n.last_flush=-1),l;if(2===o&&(1===t?h._tr_align(n):5!==t&&(h._tr_stored_block(n,0,0,!1),3===t&&(E(n.head),0===n.lookahead&&(n.strstart=0,n.block_start=0,n.insert=0))),C(e),0===e.avail_out))return n.last_flush=-1,l}return 4!==t?l:n.wrap<=0?1:(2===n.wrap?(I(n,255&e.adler),I(n,e.adler>>8&255),I(n,e.adler>>16&255),I(n,e.adler>>24&255),I(n,255&e.total_in),I(n,e.total_in>>8&255),I(n,e.total_in>>16&255),I(n,e.total_in>>24&255)):(O(n,e.adler>>>16),O(n,65535&e.adler)),C(e),0<n.wrap&&(n.wrap=-n.wrap),0!==n.pending?l:1)},r.deflateEnd=function(e){var t;return e&&e.state?(t=e.state.status)!==k&&69!==t&&73!==t&&91!==t&&103!==t&&t!==x&&666!==t?S(e,m):(e.state=null,t===x?S(e,-3):l):m},r.deflateSetDictionary=function(e,t){var r,n,i,s,a,o,u,h,f=t.length;if(!e||!e.state)return m;if(2===(s=(r=e.state).wrap)||1===s&&r.status!==k||r.lookahead)return m;for(1===s&&(e.adler=c(e.adler,t,f,0)),r.wrap=0,f>=r.w_size&&(0===s&&(E(r.head),r.strstart=0,r.block_start=0,r.insert=0),h=new d.Buf8(r.w_size),d.arraySet(h,t,f-r.w_size,r.w_size,0),t=h,f=r.w_size),a=e.avail_in,o=e.next_in,u=e.input,e.avail_in=f,e.next_in=0,e.input=t,T(r);r.lookahead>=b;){for(n=r.strstart,i=r.lookahead-(b-1);r.ins_h=(r.ins_h<<r.hash_shift^r.window[n+b-1])&r.hash_mask,r.prev[n&r.w_mask]=r.head[r.ins_h],r.head[r.ins_h]=n,n++,--i;);r.strstart=n,r.lookahead=b-1,T(r);}return r.strstart+=r.lookahead,r.block_start=r.strstart,r.insert=r.lookahead,r.lookahead=0,r.match_length=r.prev_length=b-1,r.match_available=0,e.next_in=o,e.input=u,e.avail_in=a,r.wrap=s,l},r.deflateInfo="pako deflate (from Nodeca project)";},{"../utils/common":41,"./adler32":43,"./crc32":45,"./messages":51,"./trees":52}],47:[function(e,t,r){t.exports=function(){this.text=0,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name="",this.comment="",this.hcrc=0,this.done=!1;};},{}],48:[function(e,t,r){t.exports=function(e,t){var r,n,i,s,a,o,u,h,f,l,d,c,p,m,_,g,v,b,w,y,k,x,S,z,E;r=e.state,n=e.next_in,z=e.input,i=n+(e.avail_in-5),s=e.next_out,E=e.output,a=s-(t-e.avail_out),o=s+(e.avail_out-257),u=r.dmax,h=r.wsize,f=r.whave,l=r.wnext,d=r.window,c=r.hold,p=r.bits,m=r.lencode,_=r.distcode,g=(1<<r.lenbits)-1,v=(1<<r.distbits)-1;e:do{p<15&&(c+=z[n++]<<p,p+=8,c+=z[n++]<<p,p+=8),b=m[c&g];t:for(;;){if(c>>>=w=b>>>24,p-=w,0==(w=b>>>16&255))E[s++]=65535&b;else {if(!(16&w)){if(0==(64&w)){b=m[(65535&b)+(c&(1<<w)-1)];continue t}if(32&w){r.mode=12;break e}e.msg="invalid literal/length code",r.mode=30;break e}y=65535&b,(w&=15)&&(p<w&&(c+=z[n++]<<p,p+=8),y+=c&(1<<w)-1,c>>>=w,p-=w),p<15&&(c+=z[n++]<<p,p+=8,c+=z[n++]<<p,p+=8),b=_[c&v];r:for(;;){if(c>>>=w=b>>>24,p-=w,!(16&(w=b>>>16&255))){if(0==(64&w)){b=_[(65535&b)+(c&(1<<w)-1)];continue r}e.msg="invalid distance code",r.mode=30;break e}if(k=65535&b,p<(w&=15)&&(c+=z[n++]<<p,(p+=8)<w&&(c+=z[n++]<<p,p+=8)),u<(k+=c&(1<<w)-1)){e.msg="invalid distance too far back",r.mode=30;break e}if(c>>>=w,p-=w,(w=s-a)<k){if(f<(w=k-w)&&r.sane){e.msg="invalid distance too far back",r.mode=30;break e}if(S=d,(x=0)===l){if(x+=h-w,w<y){for(y-=w;E[s++]=d[x++],--w;);x=s-k,S=E;}}else if(l<w){if(x+=h+l-w,(w-=l)<y){for(y-=w;E[s++]=d[x++],--w;);if(x=0,l<y){for(y-=w=l;E[s++]=d[x++],--w;);x=s-k,S=E;}}}else if(x+=l-w,w<y){for(y-=w;E[s++]=d[x++],--w;);x=s-k,S=E;}for(;2<y;)E[s++]=S[x++],E[s++]=S[x++],E[s++]=S[x++],y-=3;y&&(E[s++]=S[x++],1<y&&(E[s++]=S[x++]));}else {for(x=s-k;E[s++]=E[x++],E[s++]=E[x++],E[s++]=E[x++],2<(y-=3););y&&(E[s++]=E[x++],1<y&&(E[s++]=E[x++]));}break}}break}}while(n<i&&s<o);n-=y=p>>3,c&=(1<<(p-=y<<3))-1,e.next_in=n,e.next_out=s,e.avail_in=n<i?i-n+5:5-(n-i),e.avail_out=s<o?o-s+257:257-(s-o),r.hold=c,r.bits=p;};},{}],49:[function(e,t,r){var I=e("../utils/common"),O=e("./adler32"),B=e("./crc32"),T=e("./inffast"),R=e("./inftrees"),D=1,F=2,N=0,U=-2,P=1,n=852,i=592;function L(e){return (e>>>24&255)+(e>>>8&65280)+((65280&e)<<8)+((255&e)<<24)}function s(){this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new I.Buf16(320),this.work=new I.Buf16(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0;}function a(e){var t;return e&&e.state?(t=e.state,e.total_in=e.total_out=t.total=0,e.msg="",t.wrap&&(e.adler=1&t.wrap),t.mode=P,t.last=0,t.havedict=0,t.dmax=32768,t.head=null,t.hold=0,t.bits=0,t.lencode=t.lendyn=new I.Buf32(n),t.distcode=t.distdyn=new I.Buf32(i),t.sane=1,t.back=-1,N):U}function o(e){var t;return e&&e.state?((t=e.state).wsize=0,t.whave=0,t.wnext=0,a(e)):U}function u(e,t){var r,n;return e&&e.state?(n=e.state,t<0?(r=0,t=-t):(r=1+(t>>4),t<48&&(t&=15)),t&&(t<8||15<t)?U:(null!==n.window&&n.wbits!==t&&(n.window=null),n.wrap=r,n.wbits=t,o(e))):U}function h(e,t){var r,n;return e?(n=new s,(e.state=n).window=null,(r=u(e,t))!==N&&(e.state=null),r):U}var f,l,d=!0;function j(e){if(d){var t;for(f=new I.Buf32(512),l=new I.Buf32(32),t=0;t<144;)e.lens[t++]=8;for(;t<256;)e.lens[t++]=9;for(;t<280;)e.lens[t++]=7;for(;t<288;)e.lens[t++]=8;for(R(D,e.lens,0,288,f,0,e.work,{bits:9}),t=0;t<32;)e.lens[t++]=5;R(F,e.lens,0,32,l,0,e.work,{bits:5}),d=!1;}e.lencode=f,e.lenbits=9,e.distcode=l,e.distbits=5;}function Z(e,t,r,n){var i,s=e.state;return null===s.window&&(s.wsize=1<<s.wbits,s.wnext=0,s.whave=0,s.window=new I.Buf8(s.wsize)),n>=s.wsize?(I.arraySet(s.window,t,r-s.wsize,s.wsize,0),s.wnext=0,s.whave=s.wsize):(n<(i=s.wsize-s.wnext)&&(i=n),I.arraySet(s.window,t,r-n,i,s.wnext),(n-=i)?(I.arraySet(s.window,t,r-n,n,0),s.wnext=n,s.whave=s.wsize):(s.wnext+=i,s.wnext===s.wsize&&(s.wnext=0),s.whave<s.wsize&&(s.whave+=i))),0}r.inflateReset=o,r.inflateReset2=u,r.inflateResetKeep=a,r.inflateInit=function(e){return h(e,15)},r.inflateInit2=h,r.inflate=function(e,t){var r,n,i,s,a,o,u,h,f,l,d,c,p,m,_,g,v,b,w,y,k,x,S,z,E=0,C=new I.Buf8(4),A=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];if(!e||!e.state||!e.output||!e.input&&0!==e.avail_in)return U;12===(r=e.state).mode&&(r.mode=13),a=e.next_out,i=e.output,u=e.avail_out,s=e.next_in,n=e.input,o=e.avail_in,h=r.hold,f=r.bits,l=o,d=u,x=N;e:for(;;)switch(r.mode){case P:if(0===r.wrap){r.mode=13;break}for(;f<16;){if(0===o)break e;o--,h+=n[s++]<<f,f+=8;}if(2&r.wrap&&35615===h){C[r.check=0]=255&h,C[1]=h>>>8&255,r.check=B(r.check,C,2,0),f=h=0,r.mode=2;break}if(r.flags=0,r.head&&(r.head.done=!1),!(1&r.wrap)||(((255&h)<<8)+(h>>8))%31){e.msg="incorrect header check",r.mode=30;break}if(8!=(15&h)){e.msg="unknown compression method",r.mode=30;break}if(f-=4,k=8+(15&(h>>>=4)),0===r.wbits)r.wbits=k;else if(k>r.wbits){e.msg="invalid window size",r.mode=30;break}r.dmax=1<<k,e.adler=r.check=1,r.mode=512&h?10:12,f=h=0;break;case 2:for(;f<16;){if(0===o)break e;o--,h+=n[s++]<<f,f+=8;}if(r.flags=h,8!=(255&r.flags)){e.msg="unknown compression method",r.mode=30;break}if(57344&r.flags){e.msg="unknown header flags set",r.mode=30;break}r.head&&(r.head.text=h>>8&1),512&r.flags&&(C[0]=255&h,C[1]=h>>>8&255,r.check=B(r.check,C,2,0)),f=h=0,r.mode=3;case 3:for(;f<32;){if(0===o)break e;o--,h+=n[s++]<<f,f+=8;}r.head&&(r.head.time=h),512&r.flags&&(C[0]=255&h,C[1]=h>>>8&255,C[2]=h>>>16&255,C[3]=h>>>24&255,r.check=B(r.check,C,4,0)),f=h=0,r.mode=4;case 4:for(;f<16;){if(0===o)break e;o--,h+=n[s++]<<f,f+=8;}r.head&&(r.head.xflags=255&h,r.head.os=h>>8),512&r.flags&&(C[0]=255&h,C[1]=h>>>8&255,r.check=B(r.check,C,2,0)),f=h=0,r.mode=5;case 5:if(1024&r.flags){for(;f<16;){if(0===o)break e;o--,h+=n[s++]<<f,f+=8;}r.length=h,r.head&&(r.head.extra_len=h),512&r.flags&&(C[0]=255&h,C[1]=h>>>8&255,r.check=B(r.check,C,2,0)),f=h=0;}else r.head&&(r.head.extra=null);r.mode=6;case 6:if(1024&r.flags&&(o<(c=r.length)&&(c=o),c&&(r.head&&(k=r.head.extra_len-r.length,r.head.extra||(r.head.extra=new Array(r.head.extra_len)),I.arraySet(r.head.extra,n,s,c,k)),512&r.flags&&(r.check=B(r.check,n,c,s)),o-=c,s+=c,r.length-=c),r.length))break e;r.length=0,r.mode=7;case 7:if(2048&r.flags){if(0===o)break e;for(c=0;k=n[s+c++],r.head&&k&&r.length<65536&&(r.head.name+=String.fromCharCode(k)),k&&c<o;);if(512&r.flags&&(r.check=B(r.check,n,c,s)),o-=c,s+=c,k)break e}else r.head&&(r.head.name=null);r.length=0,r.mode=8;case 8:if(4096&r.flags){if(0===o)break e;for(c=0;k=n[s+c++],r.head&&k&&r.length<65536&&(r.head.comment+=String.fromCharCode(k)),k&&c<o;);if(512&r.flags&&(r.check=B(r.check,n,c,s)),o-=c,s+=c,k)break e}else r.head&&(r.head.comment=null);r.mode=9;case 9:if(512&r.flags){for(;f<16;){if(0===o)break e;o--,h+=n[s++]<<f,f+=8;}if(h!==(65535&r.check)){e.msg="header crc mismatch",r.mode=30;break}f=h=0;}r.head&&(r.head.hcrc=r.flags>>9&1,r.head.done=!0),e.adler=r.check=0,r.mode=12;break;case 10:for(;f<32;){if(0===o)break e;o--,h+=n[s++]<<f,f+=8;}e.adler=r.check=L(h),f=h=0,r.mode=11;case 11:if(0===r.havedict)return e.next_out=a,e.avail_out=u,e.next_in=s,e.avail_in=o,r.hold=h,r.bits=f,2;e.adler=r.check=1,r.mode=12;case 12:if(5===t||6===t)break e;case 13:if(r.last){h>>>=7&f,f-=7&f,r.mode=27;break}for(;f<3;){if(0===o)break e;o--,h+=n[s++]<<f,f+=8;}switch(r.last=1&h,f-=1,3&(h>>>=1)){case 0:r.mode=14;break;case 1:if(j(r),r.mode=20,6!==t)break;h>>>=2,f-=2;break e;case 2:r.mode=17;break;case 3:e.msg="invalid block type",r.mode=30;}h>>>=2,f-=2;break;case 14:for(h>>>=7&f,f-=7&f;f<32;){if(0===o)break e;o--,h+=n[s++]<<f,f+=8;}if((65535&h)!=(h>>>16^65535)){e.msg="invalid stored block lengths",r.mode=30;break}if(r.length=65535&h,f=h=0,r.mode=15,6===t)break e;case 15:r.mode=16;case 16:if(c=r.length){if(o<c&&(c=o),u<c&&(c=u),0===c)break e;I.arraySet(i,n,s,c,a),o-=c,s+=c,u-=c,a+=c,r.length-=c;break}r.mode=12;break;case 17:for(;f<14;){if(0===o)break e;o--,h+=n[s++]<<f,f+=8;}if(r.nlen=257+(31&h),h>>>=5,f-=5,r.ndist=1+(31&h),h>>>=5,f-=5,r.ncode=4+(15&h),h>>>=4,f-=4,286<r.nlen||30<r.ndist){e.msg="too many length or distance symbols",r.mode=30;break}r.have=0,r.mode=18;case 18:for(;r.have<r.ncode;){for(;f<3;){if(0===o)break e;o--,h+=n[s++]<<f,f+=8;}r.lens[A[r.have++]]=7&h,h>>>=3,f-=3;}for(;r.have<19;)r.lens[A[r.have++]]=0;if(r.lencode=r.lendyn,r.lenbits=7,S={bits:r.lenbits},x=R(0,r.lens,0,19,r.lencode,0,r.work,S),r.lenbits=S.bits,x){e.msg="invalid code lengths set",r.mode=30;break}r.have=0,r.mode=19;case 19:for(;r.have<r.nlen+r.ndist;){for(;g=(E=r.lencode[h&(1<<r.lenbits)-1])>>>16&255,v=65535&E,!((_=E>>>24)<=f);){if(0===o)break e;o--,h+=n[s++]<<f,f+=8;}if(v<16)h>>>=_,f-=_,r.lens[r.have++]=v;else {if(16===v){for(z=_+2;f<z;){if(0===o)break e;o--,h+=n[s++]<<f,f+=8;}if(h>>>=_,f-=_,0===r.have){e.msg="invalid bit length repeat",r.mode=30;break}k=r.lens[r.have-1],c=3+(3&h),h>>>=2,f-=2;}else if(17===v){for(z=_+3;f<z;){if(0===o)break e;o--,h+=n[s++]<<f,f+=8;}f-=_,k=0,c=3+(7&(h>>>=_)),h>>>=3,f-=3;}else {for(z=_+7;f<z;){if(0===o)break e;o--,h+=n[s++]<<f,f+=8;}f-=_,k=0,c=11+(127&(h>>>=_)),h>>>=7,f-=7;}if(r.have+c>r.nlen+r.ndist){e.msg="invalid bit length repeat",r.mode=30;break}for(;c--;)r.lens[r.have++]=k;}}if(30===r.mode)break;if(0===r.lens[256]){e.msg="invalid code -- missing end-of-block",r.mode=30;break}if(r.lenbits=9,S={bits:r.lenbits},x=R(D,r.lens,0,r.nlen,r.lencode,0,r.work,S),r.lenbits=S.bits,x){e.msg="invalid literal/lengths set",r.mode=30;break}if(r.distbits=6,r.distcode=r.distdyn,S={bits:r.distbits},x=R(F,r.lens,r.nlen,r.ndist,r.distcode,0,r.work,S),r.distbits=S.bits,x){e.msg="invalid distances set",r.mode=30;break}if(r.mode=20,6===t)break e;case 20:r.mode=21;case 21:if(6<=o&&258<=u){e.next_out=a,e.avail_out=u,e.next_in=s,e.avail_in=o,r.hold=h,r.bits=f,T(e,d),a=e.next_out,i=e.output,u=e.avail_out,s=e.next_in,n=e.input,o=e.avail_in,h=r.hold,f=r.bits,12===r.mode&&(r.back=-1);break}for(r.back=0;g=(E=r.lencode[h&(1<<r.lenbits)-1])>>>16&255,v=65535&E,!((_=E>>>24)<=f);){if(0===o)break e;o--,h+=n[s++]<<f,f+=8;}if(g&&0==(240&g)){for(b=_,w=g,y=v;g=(E=r.lencode[y+((h&(1<<b+w)-1)>>b)])>>>16&255,v=65535&E,!(b+(_=E>>>24)<=f);){if(0===o)break e;o--,h+=n[s++]<<f,f+=8;}h>>>=b,f-=b,r.back+=b;}if(h>>>=_,f-=_,r.back+=_,r.length=v,0===g){r.mode=26;break}if(32&g){r.back=-1,r.mode=12;break}if(64&g){e.msg="invalid literal/length code",r.mode=30;break}r.extra=15&g,r.mode=22;case 22:if(r.extra){for(z=r.extra;f<z;){if(0===o)break e;o--,h+=n[s++]<<f,f+=8;}r.length+=h&(1<<r.extra)-1,h>>>=r.extra,f-=r.extra,r.back+=r.extra;}r.was=r.length,r.mode=23;case 23:for(;g=(E=r.distcode[h&(1<<r.distbits)-1])>>>16&255,v=65535&E,!((_=E>>>24)<=f);){if(0===o)break e;o--,h+=n[s++]<<f,f+=8;}if(0==(240&g)){for(b=_,w=g,y=v;g=(E=r.distcode[y+((h&(1<<b+w)-1)>>b)])>>>16&255,v=65535&E,!(b+(_=E>>>24)<=f);){if(0===o)break e;o--,h+=n[s++]<<f,f+=8;}h>>>=b,f-=b,r.back+=b;}if(h>>>=_,f-=_,r.back+=_,64&g){e.msg="invalid distance code",r.mode=30;break}r.offset=v,r.extra=15&g,r.mode=24;case 24:if(r.extra){for(z=r.extra;f<z;){if(0===o)break e;o--,h+=n[s++]<<f,f+=8;}r.offset+=h&(1<<r.extra)-1,h>>>=r.extra,f-=r.extra,r.back+=r.extra;}if(r.offset>r.dmax){e.msg="invalid distance too far back",r.mode=30;break}r.mode=25;case 25:if(0===u)break e;if(c=d-u,r.offset>c){if((c=r.offset-c)>r.whave&&r.sane){e.msg="invalid distance too far back",r.mode=30;break}p=c>r.wnext?(c-=r.wnext,r.wsize-c):r.wnext-c,c>r.length&&(c=r.length),m=r.window;}else m=i,p=a-r.offset,c=r.length;for(u<c&&(c=u),u-=c,r.length-=c;i[a++]=m[p++],--c;);0===r.length&&(r.mode=21);break;case 26:if(0===u)break e;i[a++]=r.length,u--,r.mode=21;break;case 27:if(r.wrap){for(;f<32;){if(0===o)break e;o--,h|=n[s++]<<f,f+=8;}if(d-=u,e.total_out+=d,r.total+=d,d&&(e.adler=r.check=r.flags?B(r.check,i,d,a-d):O(r.check,i,d,a-d)),d=u,(r.flags?h:L(h))!==r.check){e.msg="incorrect data check",r.mode=30;break}f=h=0;}r.mode=28;case 28:if(r.wrap&&r.flags){for(;f<32;){if(0===o)break e;o--,h+=n[s++]<<f,f+=8;}if(h!==(4294967295&r.total)){e.msg="incorrect length check",r.mode=30;break}f=h=0;}r.mode=29;case 29:x=1;break e;case 30:x=-3;break e;case 31:return -4;case 32:default:return U}return e.next_out=a,e.avail_out=u,e.next_in=s,e.avail_in=o,r.hold=h,r.bits=f,(r.wsize||d!==e.avail_out&&r.mode<30&&(r.mode<27||4!==t))&&Z(e,e.output,e.next_out,d-e.avail_out)?(r.mode=31,-4):(l-=e.avail_in,d-=e.avail_out,e.total_in+=l,e.total_out+=d,r.total+=d,r.wrap&&d&&(e.adler=r.check=r.flags?B(r.check,i,d,e.next_out-d):O(r.check,i,d,e.next_out-d)),e.data_type=r.bits+(r.last?64:0)+(12===r.mode?128:0)+(20===r.mode||15===r.mode?256:0),(0==l&&0===d||4===t)&&x===N&&(x=-5),x)},r.inflateEnd=function(e){if(!e||!e.state)return U;var t=e.state;return t.window&&(t.window=null),e.state=null,N},r.inflateGetHeader=function(e,t){var r;return e&&e.state?0==(2&(r=e.state).wrap)?U:((r.head=t).done=!1,N):U},r.inflateSetDictionary=function(e,t){var r,n=t.length;return e&&e.state?0!==(r=e.state).wrap&&11!==r.mode?U:11===r.mode&&O(1,t,n,0)!==r.check?-3:Z(e,t,n,n)?(r.mode=31,-4):(r.havedict=1,N):U},r.inflateInfo="pako inflate (from Nodeca project)";},{"../utils/common":41,"./adler32":43,"./crc32":45,"./inffast":48,"./inftrees":50}],50:[function(e,t,r){var D=e("../utils/common"),F=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0],N=[16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78],U=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0],P=[16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64];t.exports=function(e,t,r,n,i,s,a,o){var u,h,f,l,d,c,p,m,_,g=o.bits,v=0,b=0,w=0,y=0,k=0,x=0,S=0,z=0,E=0,C=0,A=null,I=0,O=new D.Buf16(16),B=new D.Buf16(16),T=null,R=0;for(v=0;v<=15;v++)O[v]=0;for(b=0;b<n;b++)O[t[r+b]]++;for(k=g,y=15;1<=y&&0===O[y];y--);if(y<k&&(k=y),0===y)return i[s++]=20971520,i[s++]=20971520,o.bits=1,0;for(w=1;w<y&&0===O[w];w++);for(k<w&&(k=w),v=z=1;v<=15;v++)if(z<<=1,(z-=O[v])<0)return -1;if(0<z&&(0===e||1!==y))return -1;for(B[1]=0,v=1;v<15;v++)B[v+1]=B[v]+O[v];for(b=0;b<n;b++)0!==t[r+b]&&(a[B[t[r+b]]++]=b);if(c=0===e?(A=T=a,19):1===e?(A=F,I-=257,T=N,R-=257,256):(A=U,T=P,-1),v=w,d=s,S=b=C=0,f=-1,l=(E=1<<(x=k))-1,1===e&&852<E||2===e&&592<E)return 1;for(;;){for(p=v-S,_=a[b]<c?(m=0,a[b]):a[b]>c?(m=T[R+a[b]],A[I+a[b]]):(m=96,0),u=1<<v-S,w=h=1<<x;i[d+(C>>S)+(h-=u)]=p<<24|m<<16|_|0,0!==h;);for(u=1<<v-1;C&u;)u>>=1;if(0!==u?(C&=u-1,C+=u):C=0,b++,0==--O[v]){if(v===y)break;v=t[r+a[b]];}if(k<v&&(C&l)!==f){for(0===S&&(S=k),d+=w,z=1<<(x=v-S);x+S<y&&!((z-=O[x+S])<=0);)x++,z<<=1;if(E+=1<<x,1===e&&852<E||2===e&&592<E)return 1;i[f=C&l]=k<<24|x<<16|d-s|0;}}return 0!==C&&(i[d+C]=v-S<<24|64<<16|0),o.bits=k,0};},{"../utils/common":41}],51:[function(e,t,r){t.exports={2:"need dictionary",1:"stream end",0:"","-1":"file error","-2":"stream error","-3":"data error","-4":"insufficient memory","-5":"buffer error","-6":"incompatible version"};},{}],52:[function(e,t,r){var o=e("../utils/common");function n(e){for(var t=e.length;0<=--t;)e[t]=0;}var _=15,i=16,u=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0],h=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13],a=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7],f=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],l=new Array(576);n(l);var d=new Array(60);n(d);var c=new Array(512);n(c);var p=new Array(256);n(p);var m=new Array(29);n(m);var g,v,b,w=new Array(30);function y(e,t,r,n,i){this.static_tree=e,this.extra_bits=t,this.extra_base=r,this.elems=n,this.max_length=i,this.has_stree=e&&e.length;}function s(e,t){this.dyn_tree=e,this.max_code=0,this.stat_desc=t;}function k(e){return e<256?c[e]:c[256+(e>>>7)]}function x(e,t){e.pending_buf[e.pending++]=255&t,e.pending_buf[e.pending++]=t>>>8&255;}function S(e,t,r){e.bi_valid>i-r?(e.bi_buf|=t<<e.bi_valid&65535,x(e,e.bi_buf),e.bi_buf=t>>i-e.bi_valid,e.bi_valid+=r-i):(e.bi_buf|=t<<e.bi_valid&65535,e.bi_valid+=r);}function z(e,t,r){S(e,r[2*t],r[2*t+1]);}function E(e,t){for(var r=0;r|=1&e,e>>>=1,r<<=1,0<--t;);return r>>>1}function C(e,t,r){var n,i,s=new Array(_+1),a=0;for(n=1;n<=_;n++)s[n]=a=a+r[n-1]<<1;for(i=0;i<=t;i++){var o=e[2*i+1];0!==o&&(e[2*i]=E(s[o]++,o));}}function A(e){var t;for(t=0;t<286;t++)e.dyn_ltree[2*t]=0;for(t=0;t<30;t++)e.dyn_dtree[2*t]=0;for(t=0;t<19;t++)e.bl_tree[2*t]=0;e.dyn_ltree[512]=1,e.opt_len=e.static_len=0,e.last_lit=e.matches=0;}function I(e){8<e.bi_valid?x(e,e.bi_buf):0<e.bi_valid&&(e.pending_buf[e.pending++]=e.bi_buf),e.bi_buf=0,e.bi_valid=0;}function O(e,t,r,n){var i=2*t,s=2*r;return e[i]<e[s]||e[i]===e[s]&&n[t]<=n[r]}function B(e,t,r){for(var n=e.heap[r],i=r<<1;i<=e.heap_len&&(i<e.heap_len&&O(t,e.heap[i+1],e.heap[i],e.depth)&&i++,!O(t,n,e.heap[i],e.depth));)e.heap[r]=e.heap[i],r=i,i<<=1;e.heap[r]=n;}function T(e,t,r){var n,i,s,a,o=0;if(0!==e.last_lit)for(;n=e.pending_buf[e.d_buf+2*o]<<8|e.pending_buf[e.d_buf+2*o+1],i=e.pending_buf[e.l_buf+o],o++,0===n?z(e,i,t):(z(e,(s=p[i])+256+1,t),0!==(a=u[s])&&S(e,i-=m[s],a),z(e,s=k(--n),r),0!==(a=h[s])&&S(e,n-=w[s],a)),o<e.last_lit;);z(e,256,t);}function R(e,t){var r,n,i,s=t.dyn_tree,a=t.stat_desc.static_tree,o=t.stat_desc.has_stree,u=t.stat_desc.elems,h=-1;for(e.heap_len=0,e.heap_max=573,r=0;r<u;r++)0!==s[2*r]?(e.heap[++e.heap_len]=h=r,e.depth[r]=0):s[2*r+1]=0;for(;e.heap_len<2;)s[2*(i=e.heap[++e.heap_len]=h<2?++h:0)]=1,e.depth[i]=0,e.opt_len--,o&&(e.static_len-=a[2*i+1]);for(t.max_code=h,r=e.heap_len>>1;1<=r;r--)B(e,s,r);for(i=u;r=e.heap[1],e.heap[1]=e.heap[e.heap_len--],B(e,s,1),n=e.heap[1],e.heap[--e.heap_max]=r,e.heap[--e.heap_max]=n,s[2*i]=s[2*r]+s[2*n],e.depth[i]=(e.depth[r]>=e.depth[n]?e.depth[r]:e.depth[n])+1,s[2*r+1]=s[2*n+1]=i,e.heap[1]=i++,B(e,s,1),2<=e.heap_len;);e.heap[--e.heap_max]=e.heap[1],function(e,t){var r,n,i,s,a,o,u=t.dyn_tree,h=t.max_code,f=t.stat_desc.static_tree,l=t.stat_desc.has_stree,d=t.stat_desc.extra_bits,c=t.stat_desc.extra_base,p=t.stat_desc.max_length,m=0;for(s=0;s<=_;s++)e.bl_count[s]=0;for(u[2*e.heap[e.heap_max]+1]=0,r=e.heap_max+1;r<573;r++)p<(s=u[2*u[2*(n=e.heap[r])+1]+1]+1)&&(s=p,m++),u[2*n+1]=s,h<n||(e.bl_count[s]++,a=0,c<=n&&(a=d[n-c]),o=u[2*n],e.opt_len+=o*(s+a),l&&(e.static_len+=o*(f[2*n+1]+a)));if(0!==m){do{for(s=p-1;0===e.bl_count[s];)s--;e.bl_count[s]--,e.bl_count[s+1]+=2,e.bl_count[p]--,m-=2;}while(0<m);for(s=p;0!==s;s--)for(n=e.bl_count[s];0!==n;)h<(i=e.heap[--r])||(u[2*i+1]!==s&&(e.opt_len+=(s-u[2*i+1])*u[2*i],u[2*i+1]=s),n--);}}(e,t),C(s,h,e.bl_count);}function D(e,t,r){var n,i,s=-1,a=t[1],o=0,u=7,h=4;for(0===a&&(u=138,h=3),t[2*(r+1)+1]=65535,n=0;n<=r;n++)i=a,a=t[2*(n+1)+1],++o<u&&i===a||(o<h?e.bl_tree[2*i]+=o:0!==i?(i!==s&&e.bl_tree[2*i]++,e.bl_tree[32]++):o<=10?e.bl_tree[34]++:e.bl_tree[36]++,s=i,h=(o=0)===a?(u=138,3):i===a?(u=6,3):(u=7,4));}function F(e,t,r){var n,i,s=-1,a=t[1],o=0,u=7,h=4;for(0===a&&(u=138,h=3),n=0;n<=r;n++)if(i=a,a=t[2*(n+1)+1],!(++o<u&&i===a)){if(o<h)for(;z(e,i,e.bl_tree),0!=--o;);else 0!==i?(i!==s&&(z(e,i,e.bl_tree),o--),z(e,16,e.bl_tree),S(e,o-3,2)):o<=10?(z(e,17,e.bl_tree),S(e,o-3,3)):(z(e,18,e.bl_tree),S(e,o-11,7));s=i,h=(o=0)===a?(u=138,3):i===a?(u=6,3):(u=7,4);}}n(w);var N=!1;function U(e,t,r,n){var i,s,a;S(e,0+(n?1:0),3),s=t,a=r,I(i=e),x(i,a),x(i,~a),o.arraySet(i.pending_buf,i.window,s,a,i.pending),i.pending+=a;}r._tr_init=function(e){N||(function(){var e,t,r,n,i,s=new Array(_+1);for(n=r=0;n<28;n++)for(m[n]=r,e=0;e<1<<u[n];e++)p[r++]=n;for(p[r-1]=n,n=i=0;n<16;n++)for(w[n]=i,e=0;e<1<<h[n];e++)c[i++]=n;for(i>>=7;n<30;n++)for(w[n]=i<<7,e=0;e<1<<h[n]-7;e++)c[256+i++]=n;for(t=0;t<=_;t++)s[t]=0;for(e=0;e<=143;)l[2*e+1]=8,e++,s[8]++;for(;e<=255;)l[2*e+1]=9,e++,s[9]++;for(;e<=279;)l[2*e+1]=7,e++,s[7]++;for(;e<=287;)l[2*e+1]=8,e++,s[8]++;for(C(l,287,s),e=0;e<30;e++)d[2*e+1]=5,d[2*e]=E(e,5);g=new y(l,u,257,286,_),v=new y(d,h,0,30,_),b=new y(new Array(0),a,0,19,7);}(),N=!0),e.l_desc=new s(e.dyn_ltree,g),e.d_desc=new s(e.dyn_dtree,v),e.bl_desc=new s(e.bl_tree,b),e.bi_buf=0,e.bi_valid=0,A(e);},r._tr_stored_block=U,r._tr_flush_block=function(e,t,r,n){var i,s,a=0;0<e.level?(2===e.strm.data_type&&(e.strm.data_type=function(e){var t,r=4093624447;for(t=0;t<=31;t++,r>>>=1)if(1&r&&0!==e.dyn_ltree[2*t])return 0;if(0!==e.dyn_ltree[18]||0!==e.dyn_ltree[20]||0!==e.dyn_ltree[26])return 1;for(t=32;t<256;t++)if(0!==e.dyn_ltree[2*t])return 1;return 0}(e)),R(e,e.l_desc),R(e,e.d_desc),a=function(e){var t;for(D(e,e.dyn_ltree,e.l_desc.max_code),D(e,e.dyn_dtree,e.d_desc.max_code),R(e,e.bl_desc),t=18;3<=t&&0===e.bl_tree[2*f[t]+1];t--);return e.opt_len+=3*(t+1)+5+5+4,t}(e),i=e.opt_len+3+7>>>3,(s=e.static_len+3+7>>>3)<=i&&(i=s)):i=s=r+5,r+4<=i&&-1!==t?U(e,t,r,n):4===e.strategy||s===i?(S(e,2+(n?1:0),3),T(e,l,d)):(S(e,4+(n?1:0),3),function(e,t,r,n){var i;for(S(e,t-257,5),S(e,r-1,5),S(e,n-4,4),i=0;i<n;i++)S(e,e.bl_tree[2*f[i]+1],3);F(e,e.dyn_ltree,t-1),F(e,e.dyn_dtree,r-1);}(e,e.l_desc.max_code+1,e.d_desc.max_code+1,a+1),T(e,e.dyn_ltree,e.dyn_dtree)),A(e),n&&I(e);},r._tr_tally=function(e,t,r){return e.pending_buf[e.d_buf+2*e.last_lit]=t>>>8&255,e.pending_buf[e.d_buf+2*e.last_lit+1]=255&t,e.pending_buf[e.l_buf+e.last_lit]=255&r,e.last_lit++,0===t?e.dyn_ltree[2*r]++:(e.matches++,t--,e.dyn_ltree[2*(p[r]+256+1)]++,e.dyn_dtree[2*k(t)]++),e.last_lit===e.lit_bufsize-1},r._tr_align=function(e){var t;S(e,2,3),z(e,256,l),16===(t=e).bi_valid?(x(t,t.bi_buf),t.bi_buf=0,t.bi_valid=0):8<=t.bi_valid&&(t.pending_buf[t.pending++]=255&t.bi_buf,t.bi_buf>>=8,t.bi_valid-=8);};},{"../utils/common":41}],53:[function(e,t,r){t.exports=function(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg="",this.state=null,this.data_type=2,this.adler=0;};},{}],54:[function(e,t,r){t.exports="function"==typeof setImmediate?setImmediate:function(){var e=[].slice.apply(arguments);e.splice(1,0,0),setTimeout.apply(null,e);};},{}]},{},[10])(10)});}).call(this,void 0!==r?r:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{});},{}]},{},[1])(1)});}).call(this,void 0!==r?r:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{});},{}]},{},[1])(1)});}).call(this,void 0!==r?r:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{});},{}]},{},[1])(1)});}).call(this,void 0!==r?r:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{});},{}]},{},[1])(1)});}).call(this,"undefined"!=typeof commonjsGlobal?commonjsGlobal:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{});},{}]},{},[1])(1)});
	});

	var streamBrowser = events__default['default'].EventEmitter;

	var debugUtil = {};

	function ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$1(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	var Buffer$1 = buffer__default['default'].Buffer;

	var inspect = debugUtil.inspect;

	var custom = inspect && inspect.custom || 'inspect';

	function copyBuffer(src, target, offset) {
	  Buffer$1.prototype.copy.call(src, target, offset);
	}

	var buffer_list =
	/*#__PURE__*/
	function () {
	  function BufferList() {
	    _classCallCheck(this, BufferList);

	    this.head = null;
	    this.tail = null;
	    this.length = 0;
	  }

	  _createClass(BufferList, [{
	    key: "push",
	    value: function push(v) {
	      var entry = {
	        data: v,
	        next: null
	      };
	      if (this.length > 0) this.tail.next = entry;else this.head = entry;
	      this.tail = entry;
	      ++this.length;
	    }
	  }, {
	    key: "unshift",
	    value: function unshift(v) {
	      var entry = {
	        data: v,
	        next: this.head
	      };
	      if (this.length === 0) this.tail = entry;
	      this.head = entry;
	      ++this.length;
	    }
	  }, {
	    key: "shift",
	    value: function shift() {
	      if (this.length === 0) return;
	      var ret = this.head.data;
	      if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
	      --this.length;
	      return ret;
	    }
	  }, {
	    key: "clear",
	    value: function clear() {
	      this.head = this.tail = null;
	      this.length = 0;
	    }
	  }, {
	    key: "join",
	    value: function join(s) {
	      if (this.length === 0) return '';
	      var p = this.head;
	      var ret = '' + p.data;

	      while (p = p.next) {
	        ret += s + p.data;
	      }

	      return ret;
	    }
	  }, {
	    key: "concat",
	    value: function concat(n) {
	      if (this.length === 0) return Buffer$1.alloc(0);
	      var ret = Buffer$1.allocUnsafe(n >>> 0);
	      var p = this.head;
	      var i = 0;

	      while (p) {
	        copyBuffer(p.data, ret, i);
	        i += p.data.length;
	        p = p.next;
	      }

	      return ret;
	    } // Consumes a specified amount of bytes or characters from the buffered data.

	  }, {
	    key: "consume",
	    value: function consume(n, hasStrings) {
	      var ret;

	      if (n < this.head.data.length) {
	        // `slice` is the same for buffers and strings.
	        ret = this.head.data.slice(0, n);
	        this.head.data = this.head.data.slice(n);
	      } else if (n === this.head.data.length) {
	        // First chunk is a perfect match.
	        ret = this.shift();
	      } else {
	        // Result spans more than one buffer.
	        ret = hasStrings ? this._getString(n) : this._getBuffer(n);
	      }

	      return ret;
	    }
	  }, {
	    key: "first",
	    value: function first() {
	      return this.head.data;
	    } // Consumes a specified amount of characters from the buffered data.

	  }, {
	    key: "_getString",
	    value: function _getString(n) {
	      var p = this.head;
	      var c = 1;
	      var ret = p.data;
	      n -= ret.length;

	      while (p = p.next) {
	        var str = p.data;
	        var nb = n > str.length ? str.length : n;
	        if (nb === str.length) ret += str;else ret += str.slice(0, n);
	        n -= nb;

	        if (n === 0) {
	          if (nb === str.length) {
	            ++c;
	            if (p.next) this.head = p.next;else this.head = this.tail = null;
	          } else {
	            this.head = p;
	            p.data = str.slice(nb);
	          }

	          break;
	        }

	        ++c;
	      }

	      this.length -= c;
	      return ret;
	    } // Consumes a specified amount of bytes from the buffered data.

	  }, {
	    key: "_getBuffer",
	    value: function _getBuffer(n) {
	      var ret = Buffer$1.allocUnsafe(n);
	      var p = this.head;
	      var c = 1;
	      p.data.copy(ret);
	      n -= p.data.length;

	      while (p = p.next) {
	        var buf = p.data;
	        var nb = n > buf.length ? buf.length : n;
	        buf.copy(ret, ret.length - n, 0, nb);
	        n -= nb;

	        if (n === 0) {
	          if (nb === buf.length) {
	            ++c;
	            if (p.next) this.head = p.next;else this.head = this.tail = null;
	          } else {
	            this.head = p;
	            p.data = buf.slice(nb);
	          }

	          break;
	        }

	        ++c;
	      }

	      this.length -= c;
	      return ret;
	    } // Make sure the linked list only shows the minimal necessary information.

	  }, {
	    key: custom,
	    value: function value(_, options) {
	      return inspect(this, _objectSpread({}, options, {
	        // Only inspect one level.
	        depth: 0,
	        // It should not recurse.
	        customInspect: false
	      }));
	    }
	  }]);

	  return BufferList;
	}();

	function destroy(err, cb) {
	  var _this = this;

	  var readableDestroyed = this._readableState && this._readableState.destroyed;
	  var writableDestroyed = this._writableState && this._writableState.destroyed;

	  if (readableDestroyed || writableDestroyed) {
	    if (cb) {
	      cb(err);
	    } else if (err) {
	      if (!this._writableState) {
	        process.nextTick(emitErrorNT, this, err);
	      } else if (!this._writableState.errorEmitted) {
	        this._writableState.errorEmitted = true;
	        process.nextTick(emitErrorNT, this, err);
	      }
	    }

	    return this;
	  } // we set destroyed to true before firing error callbacks in order
	  // to make it re-entrance safe in case destroy() is called within callbacks


	  if (this._readableState) {
	    this._readableState.destroyed = true;
	  } // if this is a duplex stream mark the writable part as destroyed as well


	  if (this._writableState) {
	    this._writableState.destroyed = true;
	  }

	  this._destroy(err || null, function (err) {
	    if (!cb && err) {
	      if (!_this._writableState) {
	        process.nextTick(emitErrorAndCloseNT, _this, err);
	      } else if (!_this._writableState.errorEmitted) {
	        _this._writableState.errorEmitted = true;
	        process.nextTick(emitErrorAndCloseNT, _this, err);
	      } else {
	        process.nextTick(emitCloseNT, _this);
	      }
	    } else if (cb) {
	      process.nextTick(emitCloseNT, _this);
	      cb(err);
	    } else {
	      process.nextTick(emitCloseNT, _this);
	    }
	  });

	  return this;
	}

	function emitErrorAndCloseNT(self, err) {
	  emitErrorNT(self, err);
	  emitCloseNT(self);
	}

	function emitCloseNT(self) {
	  if (self._writableState && !self._writableState.emitClose) return;
	  if (self._readableState && !self._readableState.emitClose) return;
	  self.emit('close');
	}

	function undestroy() {
	  if (this._readableState) {
	    this._readableState.destroyed = false;
	    this._readableState.reading = false;
	    this._readableState.ended = false;
	    this._readableState.endEmitted = false;
	  }

	  if (this._writableState) {
	    this._writableState.destroyed = false;
	    this._writableState.ended = false;
	    this._writableState.ending = false;
	    this._writableState.finalCalled = false;
	    this._writableState.prefinished = false;
	    this._writableState.finished = false;
	    this._writableState.errorEmitted = false;
	  }
	}

	function emitErrorNT(self, err) {
	  self.emit('error', err);
	}

	function errorOrDestroy(stream, err) {
	  // We have tests that rely on errors being emitted
	  // in the same tick, so changing this is semver major.
	  // For now when you opt-in to autoDestroy we allow
	  // the error to be emitted nextTick. In a future
	  // semver major update we should change the default to this.
	  var rState = stream._readableState;
	  var wState = stream._writableState;
	  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);
	}

	var destroy_1 = {
	  destroy: destroy,
	  undestroy: undestroy,
	  errorOrDestroy: errorOrDestroy
	};

	function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

	var codes = {};

	function createErrorType(code, message, Base) {
	  if (!Base) {
	    Base = Error;
	  }

	  function getMessage(arg1, arg2, arg3) {
	    if (typeof message === 'string') {
	      return message;
	    } else {
	      return message(arg1, arg2, arg3);
	    }
	  }

	  var NodeError =
	  /*#__PURE__*/
	  function (_Base) {
	    _inheritsLoose(NodeError, _Base);

	    function NodeError(arg1, arg2, arg3) {
	      return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
	    }

	    return NodeError;
	  }(Base);

	  NodeError.prototype.name = Base.name;
	  NodeError.prototype.code = code;
	  codes[code] = NodeError;
	} // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js


	function oneOf(expected, thing) {
	  if (Array.isArray(expected)) {
	    var len = expected.length;
	    expected = expected.map(function (i) {
	      return String(i);
	    });

	    if (len > 2) {
	      return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(', '), ", or ") + expected[len - 1];
	    } else if (len === 2) {
	      return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
	    } else {
	      return "of ".concat(thing, " ").concat(expected[0]);
	    }
	  } else {
	    return "of ".concat(thing, " ").concat(String(expected));
	  }
	} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith


	function startsWith(str, search, pos) {
	  return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
	} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith


	function endsWith(str, search, this_len) {
	  if (this_len === undefined || this_len > str.length) {
	    this_len = str.length;
	  }

	  return str.substring(this_len - search.length, this_len) === search;
	} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes


	function includes(str, search, start) {
	  if (typeof start !== 'number') {
	    start = 0;
	  }

	  if (start + search.length > str.length) {
	    return false;
	  } else {
	    return str.indexOf(search, start) !== -1;
	  }
	}

	createErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {
	  return 'The value "' + value + '" is invalid for option "' + name + '"';
	}, TypeError);
	createErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {
	  // determiner: 'must be' or 'must not be'
	  var determiner;

	  if (typeof expected === 'string' && startsWith(expected, 'not ')) {
	    determiner = 'must not be';
	    expected = expected.replace(/^not /, '');
	  } else {
	    determiner = 'must be';
	  }

	  var msg;

	  if (endsWith(name, ' argument')) {
	    // For cases like 'first argument'
	    msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
	  } else {
	    var type = includes(name, '.') ? 'property' : 'argument';
	    msg = "The \"".concat(name, "\" ").concat(type, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
	  }

	  msg += ". Received type ".concat(typeof actual);
	  return msg;
	}, TypeError);
	createErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');
	createErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {
	  return 'The ' + name + ' method is not implemented';
	});
	createErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');
	createErrorType('ERR_STREAM_DESTROYED', function (name) {
	  return 'Cannot call ' + name + ' after a stream was destroyed';
	});
	createErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');
	createErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');
	createErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');
	createErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);
	createErrorType('ERR_UNKNOWN_ENCODING', function (arg) {
	  return 'Unknown encoding: ' + arg;
	}, TypeError);
	createErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');
	var codes_1 = codes;

	var errorsBrowser = {
		codes: codes_1
	};

	var ERR_INVALID_OPT_VALUE = errorsBrowser.codes.ERR_INVALID_OPT_VALUE;

	function highWaterMarkFrom(options, isDuplex, duplexKey) {
	  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
	}

	function getHighWaterMark(state, options, duplexKey, isDuplex) {
	  var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);

	  if (hwm != null) {
	    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
	      var name = isDuplex ? duplexKey : 'highWaterMark';
	      throw new ERR_INVALID_OPT_VALUE(name, hwm);
	    }

	    return Math.floor(hwm);
	  } // Default value


	  return state.objectMode ? 16 : 16 * 1024;
	}

	var state = {
	  getHighWaterMark: getHighWaterMark
	};

	var inherits_browser = createCommonjsModule(function (module) {
	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  module.exports = function inherits(ctor, superCtor) {
	    if (superCtor) {
	      ctor.super_ = superCtor;
	      ctor.prototype = Object.create(superCtor.prototype, {
	        constructor: {
	          value: ctor,
	          enumerable: false,
	          writable: true,
	          configurable: true
	        }
	      });
	    }
	  };
	} else {
	  // old school shim for old browsers
	  module.exports = function inherits(ctor, superCtor) {
	    if (superCtor) {
	      ctor.super_ = superCtor;
	      var TempCtor = function () {};
	      TempCtor.prototype = superCtor.prototype;
	      ctor.prototype = new TempCtor();
	      ctor.prototype.constructor = ctor;
	    }
	  };
	}
	});

	/**
	 * Module exports.
	 */

	var browser = deprecate;

	/**
	 * Mark that a method should not be used.
	 * Returns a modified function which warns once by default.
	 *
	 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
	 *
	 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
	 * will throw an Error when invoked.
	 *
	 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
	 * will invoke `console.trace()` instead of `console.error()`.
	 *
	 * @param {Function} fn - the function to deprecate
	 * @param {String} msg - the string to print to the console when `fn` is invoked
	 * @returns {Function} a new "deprecated" version of `fn`
	 * @api public
	 */

	function deprecate (fn, msg) {
	  if (config('noDeprecation')) {
	    return fn;
	  }

	  var warned = false;
	  function deprecated() {
	    if (!warned) {
	      if (config('throwDeprecation')) {
	        throw new Error(msg);
	      } else if (config('traceDeprecation')) {
	        console.trace(msg);
	      } else {
	        console.warn(msg);
	      }
	      warned = true;
	    }
	    return fn.apply(this, arguments);
	  }

	  return deprecated;
	}

	/**
	 * Checks `localStorage` for boolean values for the given `name`.
	 *
	 * @param {String} name
	 * @returns {Boolean}
	 * @api private
	 */

	function config (name) {
	  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
	  try {
	    if (!commonjsGlobal.localStorage) return false;
	  } catch (_) {
	    return false;
	  }
	  var val = commonjsGlobal.localStorage[name];
	  if (null == val) return false;
	  return String(val).toLowerCase() === 'true';
	}

	var _stream_writable = Writable;
	// there will be only 2 of these for each stream


	function CorkedRequest(state) {
	  var _this = this;

	  this.next = null;
	  this.entry = null;

	  this.finish = function () {
	    onCorkedFinish(_this, state);
	  };
	}
	/* </replacement> */

	/*<replacement>*/


	var Duplex;
	/*</replacement>*/

	Writable.WritableState = WritableState;
	/*<replacement>*/

	var internalUtil = {
	  deprecate: browser
	};
	/*</replacement>*/

	/*<replacement>*/


	/*</replacement>*/


	var Buffer$2 = buffer__default['default'].Buffer;

	var OurUint8Array = commonjsGlobal.Uint8Array || function () {};

	function _uint8ArrayToBuffer(chunk) {
	  return Buffer$2.from(chunk);
	}

	function _isUint8Array(obj) {
	  return Buffer$2.isBuffer(obj) || obj instanceof OurUint8Array;
	}



	var getHighWaterMark$1 = state.getHighWaterMark;

	var _require$codes = errorsBrowser.codes,
	    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
	    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
	    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
	    ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,
	    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,
	    ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,
	    ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,
	    ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;

	var errorOrDestroy$1 = destroy_1.errorOrDestroy;

	inherits_browser(Writable, streamBrowser);

	function nop() {}

	function WritableState(options, stream, isDuplex) {
	  Duplex = Duplex || _stream_duplex;
	  options = options || {}; // Duplex streams are both readable and writable, but share
	  // the same options object.
	  // However, some cases require setting options to different
	  // values for the readable and the writable sides of the duplex stream,
	  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.

	  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag to indicate whether or not this stream
	  // contains buffers or objects.

	  this.objectMode = !!options.objectMode;
	  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false
	  // Note: 0 is a valid value, means that we always return false if
	  // the entire buffer is not flushed immediately on write()

	  this.highWaterMark = getHighWaterMark$1(this, options, 'writableHighWaterMark', isDuplex); // if _final has been called

	  this.finalCalled = false; // drain event flag.

	  this.needDrain = false; // at the start of calling end()

	  this.ending = false; // when end() has been called, and returned

	  this.ended = false; // when 'finish' is emitted

	  this.finished = false; // has it been destroyed

	  this.destroyed = false; // should we decode strings into buffers before passing to _write?
	  // this is here so that some node-core streams can optimize string
	  // handling at a lower level.

	  var noDecode = options.decodeStrings === false;
	  this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.

	  this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement
	  // of how much we're waiting to get pushed to some underlying
	  // socket or file.

	  this.length = 0; // a flag to see when we're in the middle of a write.

	  this.writing = false; // when true all writes will be buffered until .uncork() call

	  this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, because any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.

	  this.sync = true; // a flag to know if we're processing previously buffered items, which
	  // may call the _write() callback in the same tick, so that we don't
	  // end up in an overlapped onwrite situation.

	  this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)

	  this.onwrite = function (er) {
	    onwrite(stream, er);
	  }; // the callback that the user supplies to write(chunk,encoding,cb)


	  this.writecb = null; // the amount that is being written when _write is called.

	  this.writelen = 0;
	  this.bufferedRequest = null;
	  this.lastBufferedRequest = null; // number of pending user-supplied write callbacks
	  // this must be 0 before 'finish' can be emitted

	  this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs
	  // This is relevant for synchronous Transform streams

	  this.prefinished = false; // True if the error was already emitted and should not be thrown again

	  this.errorEmitted = false; // Should close be emitted on destroy. Defaults to true.

	  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'finish' (and potentially 'end')

	  this.autoDestroy = !!options.autoDestroy; // count buffered requests

	  this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always
	  // one allocated and free to use, and we maintain at most two

	  this.corkedRequestsFree = new CorkedRequest(this);
	}

	WritableState.prototype.getBuffer = function getBuffer() {
	  var current = this.bufferedRequest;
	  var out = [];

	  while (current) {
	    out.push(current);
	    current = current.next;
	  }

	  return out;
	};

	(function () {
	  try {
	    Object.defineProperty(WritableState.prototype, 'buffer', {
	      get: internalUtil.deprecate(function writableStateBufferGetter() {
	        return this.getBuffer();
	      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
	    });
	  } catch (_) {}
	})(); // Test _writableState for inheritance to account for Duplex streams,
	// whose prototype chain only points to Readable.


	var realHasInstance;

	if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
	  realHasInstance = Function.prototype[Symbol.hasInstance];
	  Object.defineProperty(Writable, Symbol.hasInstance, {
	    value: function value(object) {
	      if (realHasInstance.call(this, object)) return true;
	      if (this !== Writable) return false;
	      return object && object._writableState instanceof WritableState;
	    }
	  });
	} else {
	  realHasInstance = function realHasInstance(object) {
	    return object instanceof this;
	  };
	}

	function Writable(options) {
	  Duplex = Duplex || _stream_duplex; // Writable ctor is applied to Duplexes, too.
	  // `realHasInstance` is necessary because using plain `instanceof`
	  // would return false, as no `_writableState` property is attached.
	  // Trying to use the custom `instanceof` for Writable here will also break the
	  // Node.js LazyTransform implementation, which has a non-trivial getter for
	  // `_writableState` that would lead to infinite recursion.
	  // Checking for a Stream.Duplex instance is faster here instead of inside
	  // the WritableState constructor, at least with V8 6.5

	  var isDuplex = this instanceof Duplex;
	  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
	  this._writableState = new WritableState(options, this, isDuplex); // legacy.

	  this.writable = true;

	  if (options) {
	    if (typeof options.write === 'function') this._write = options.write;
	    if (typeof options.writev === 'function') this._writev = options.writev;
	    if (typeof options.destroy === 'function') this._destroy = options.destroy;
	    if (typeof options.final === 'function') this._final = options.final;
	  }

	  streamBrowser.call(this);
	} // Otherwise people can pipe Writable streams, which is just wrong.


	Writable.prototype.pipe = function () {
	  errorOrDestroy$1(this, new ERR_STREAM_CANNOT_PIPE());
	};

	function writeAfterEnd(stream, cb) {
	  var er = new ERR_STREAM_WRITE_AFTER_END(); // TODO: defer error events consistently everywhere, not just the cb

	  errorOrDestroy$1(stream, er);
	  process.nextTick(cb, er);
	} // Checks that a user-supplied chunk is valid, especially for the particular
	// mode the stream is in. Currently this means that `null` is never accepted
	// and undefined/non-string values are only allowed in object mode.


	function validChunk(stream, state, chunk, cb) {
	  var er;

	  if (chunk === null) {
	    er = new ERR_STREAM_NULL_VALUES();
	  } else if (typeof chunk !== 'string' && !state.objectMode) {
	    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);
	  }

	  if (er) {
	    errorOrDestroy$1(stream, er);
	    process.nextTick(cb, er);
	    return false;
	  }

	  return true;
	}

	Writable.prototype.write = function (chunk, encoding, cb) {
	  var state = this._writableState;
	  var ret = false;

	  var isBuf = !state.objectMode && _isUint8Array(chunk);

	  if (isBuf && !Buffer$2.isBuffer(chunk)) {
	    chunk = _uint8ArrayToBuffer(chunk);
	  }

	  if (typeof encoding === 'function') {
	    cb = encoding;
	    encoding = null;
	  }

	  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
	  if (typeof cb !== 'function') cb = nop;
	  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
	    state.pendingcb++;
	    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
	  }
	  return ret;
	};

	Writable.prototype.cork = function () {
	  this._writableState.corked++;
	};

	Writable.prototype.uncork = function () {
	  var state = this._writableState;

	  if (state.corked) {
	    state.corked--;
	    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
	  }
	};

	Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
	  // node::ParseEncoding() requires lower case.
	  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
	  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
	  this._writableState.defaultEncoding = encoding;
	  return this;
	};

	Object.defineProperty(Writable.prototype, 'writableBuffer', {
	  // making it explicit this property is not enumerable
	  // because otherwise some prototype manipulation in
	  // userland will fail
	  enumerable: false,
	  get: function get() {
	    return this._writableState && this._writableState.getBuffer();
	  }
	});

	function decodeChunk(state, chunk, encoding) {
	  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
	    chunk = Buffer$2.from(chunk, encoding);
	  }

	  return chunk;
	}

	Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
	  // making it explicit this property is not enumerable
	  // because otherwise some prototype manipulation in
	  // userland will fail
	  enumerable: false,
	  get: function get() {
	    return this._writableState.highWaterMark;
	  }
	}); // if we're already writing something, then just put this
	// in the queue, and wait our turn.  Otherwise, call _write
	// If we return false, then we need a drain event, so set that flag.

	function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
	  if (!isBuf) {
	    var newChunk = decodeChunk(state, chunk, encoding);

	    if (chunk !== newChunk) {
	      isBuf = true;
	      encoding = 'buffer';
	      chunk = newChunk;
	    }
	  }

	  var len = state.objectMode ? 1 : chunk.length;
	  state.length += len;
	  var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.

	  if (!ret) state.needDrain = true;

	  if (state.writing || state.corked) {
	    var last = state.lastBufferedRequest;
	    state.lastBufferedRequest = {
	      chunk: chunk,
	      encoding: encoding,
	      isBuf: isBuf,
	      callback: cb,
	      next: null
	    };

	    if (last) {
	      last.next = state.lastBufferedRequest;
	    } else {
	      state.bufferedRequest = state.lastBufferedRequest;
	    }

	    state.bufferedRequestCount += 1;
	  } else {
	    doWrite(stream, state, false, len, chunk, encoding, cb);
	  }

	  return ret;
	}

	function doWrite(stream, state, writev, len, chunk, encoding, cb) {
	  state.writelen = len;
	  state.writecb = cb;
	  state.writing = true;
	  state.sync = true;
	  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
	  state.sync = false;
	}

	function onwriteError(stream, state, sync, er, cb) {
	  --state.pendingcb;

	  if (sync) {
	    // defer the callback if we are being called synchronously
	    // to avoid piling up things on the stack
	    process.nextTick(cb, er); // this can emit finish, and it will always happen
	    // after error

	    process.nextTick(finishMaybe, stream, state);
	    stream._writableState.errorEmitted = true;
	    errorOrDestroy$1(stream, er);
	  } else {
	    // the caller expect this to happen before if
	    // it is async
	    cb(er);
	    stream._writableState.errorEmitted = true;
	    errorOrDestroy$1(stream, er); // this can emit finish, but finish must
	    // always follow error

	    finishMaybe(stream, state);
	  }
	}

	function onwriteStateUpdate(state) {
	  state.writing = false;
	  state.writecb = null;
	  state.length -= state.writelen;
	  state.writelen = 0;
	}

	function onwrite(stream, er) {
	  var state = stream._writableState;
	  var sync = state.sync;
	  var cb = state.writecb;
	  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();
	  onwriteStateUpdate(state);
	  if (er) onwriteError(stream, state, sync, er, cb);else {
	    // Check if we're actually ready to finish, but don't emit yet
	    var finished = needFinish(state) || stream.destroyed;

	    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
	      clearBuffer(stream, state);
	    }

	    if (sync) {
	      process.nextTick(afterWrite, stream, state, finished, cb);
	    } else {
	      afterWrite(stream, state, finished, cb);
	    }
	  }
	}

	function afterWrite(stream, state, finished, cb) {
	  if (!finished) onwriteDrain(stream, state);
	  state.pendingcb--;
	  cb();
	  finishMaybe(stream, state);
	} // Must force callback to be called on nextTick, so that we don't
	// emit 'drain' before the write() consumer gets the 'false' return
	// value, and has a chance to attach a 'drain' listener.


	function onwriteDrain(stream, state) {
	  if (state.length === 0 && state.needDrain) {
	    state.needDrain = false;
	    stream.emit('drain');
	  }
	} // if there's something in the buffer waiting, then process it


	function clearBuffer(stream, state) {
	  state.bufferProcessing = true;
	  var entry = state.bufferedRequest;

	  if (stream._writev && entry && entry.next) {
	    // Fast case, write everything using _writev()
	    var l = state.bufferedRequestCount;
	    var buffer = new Array(l);
	    var holder = state.corkedRequestsFree;
	    holder.entry = entry;
	    var count = 0;
	    var allBuffers = true;

	    while (entry) {
	      buffer[count] = entry;
	      if (!entry.isBuf) allBuffers = false;
	      entry = entry.next;
	      count += 1;
	    }

	    buffer.allBuffers = allBuffers;
	    doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time
	    // as the hot path ends with doWrite

	    state.pendingcb++;
	    state.lastBufferedRequest = null;

	    if (holder.next) {
	      state.corkedRequestsFree = holder.next;
	      holder.next = null;
	    } else {
	      state.corkedRequestsFree = new CorkedRequest(state);
	    }

	    state.bufferedRequestCount = 0;
	  } else {
	    // Slow case, write chunks one-by-one
	    while (entry) {
	      var chunk = entry.chunk;
	      var encoding = entry.encoding;
	      var cb = entry.callback;
	      var len = state.objectMode ? 1 : chunk.length;
	      doWrite(stream, state, false, len, chunk, encoding, cb);
	      entry = entry.next;
	      state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then
	      // it means that we need to wait until it does.
	      // also, that means that the chunk and cb are currently
	      // being processed, so move the buffer counter past them.

	      if (state.writing) {
	        break;
	      }
	    }

	    if (entry === null) state.lastBufferedRequest = null;
	  }

	  state.bufferedRequest = entry;
	  state.bufferProcessing = false;
	}

	Writable.prototype._write = function (chunk, encoding, cb) {
	  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));
	};

	Writable.prototype._writev = null;

	Writable.prototype.end = function (chunk, encoding, cb) {
	  var state = this._writableState;

	  if (typeof chunk === 'function') {
	    cb = chunk;
	    chunk = null;
	    encoding = null;
	  } else if (typeof encoding === 'function') {
	    cb = encoding;
	    encoding = null;
	  }

	  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks

	  if (state.corked) {
	    state.corked = 1;
	    this.uncork();
	  } // ignore unnecessary end() calls.


	  if (!state.ending) endWritable(this, state, cb);
	  return this;
	};

	Object.defineProperty(Writable.prototype, 'writableLength', {
	  // making it explicit this property is not enumerable
	  // because otherwise some prototype manipulation in
	  // userland will fail
	  enumerable: false,
	  get: function get() {
	    return this._writableState.length;
	  }
	});

	function needFinish(state) {
	  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
	}

	function callFinal(stream, state) {
	  stream._final(function (err) {
	    state.pendingcb--;

	    if (err) {
	      errorOrDestroy$1(stream, err);
	    }

	    state.prefinished = true;
	    stream.emit('prefinish');
	    finishMaybe(stream, state);
	  });
	}

	function prefinish(stream, state) {
	  if (!state.prefinished && !state.finalCalled) {
	    if (typeof stream._final === 'function' && !state.destroyed) {
	      state.pendingcb++;
	      state.finalCalled = true;
	      process.nextTick(callFinal, stream, state);
	    } else {
	      state.prefinished = true;
	      stream.emit('prefinish');
	    }
	  }
	}

	function finishMaybe(stream, state) {
	  var need = needFinish(state);

	  if (need) {
	    prefinish(stream, state);

	    if (state.pendingcb === 0) {
	      state.finished = true;
	      stream.emit('finish');

	      if (state.autoDestroy) {
	        // In case of duplex streams we need a way to detect
	        // if the readable side is ready for autoDestroy as well
	        var rState = stream._readableState;

	        if (!rState || rState.autoDestroy && rState.endEmitted) {
	          stream.destroy();
	        }
	      }
	    }
	  }

	  return need;
	}

	function endWritable(stream, state, cb) {
	  state.ending = true;
	  finishMaybe(stream, state);

	  if (cb) {
	    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);
	  }

	  state.ended = true;
	  stream.writable = false;
	}

	function onCorkedFinish(corkReq, state, err) {
	  var entry = corkReq.entry;
	  corkReq.entry = null;

	  while (entry) {
	    var cb = entry.callback;
	    state.pendingcb--;
	    cb(err);
	    entry = entry.next;
	  } // reuse the free corkReq.


	  state.corkedRequestsFree.next = corkReq;
	}

	Object.defineProperty(Writable.prototype, 'destroyed', {
	  // making it explicit this property is not enumerable
	  // because otherwise some prototype manipulation in
	  // userland will fail
	  enumerable: false,
	  get: function get() {
	    if (this._writableState === undefined) {
	      return false;
	    }

	    return this._writableState.destroyed;
	  },
	  set: function set(value) {
	    // we ignore the value if the stream
	    // has not been initialized yet
	    if (!this._writableState) {
	      return;
	    } // backward compatibility, the user is explicitly
	    // managing destroyed


	    this._writableState.destroyed = value;
	  }
	});
	Writable.prototype.destroy = destroy_1.destroy;
	Writable.prototype._undestroy = destroy_1.undestroy;

	Writable.prototype._destroy = function (err, cb) {
	  cb(err);
	};

	/*<replacement>*/

	var objectKeys$1 = Object.keys || function (obj) {
	  var keys = [];

	  for (var key in obj) {
	    keys.push(key);
	  }

	  return keys;
	};
	/*</replacement>*/


	var _stream_duplex = Duplex$1;





	inherits_browser(Duplex$1, _stream_readable);

	{
	  // Allow the keys array to be GC'ed.
	  var keys$1 = objectKeys$1(_stream_writable.prototype);

	  for (var v = 0; v < keys$1.length; v++) {
	    var method = keys$1[v];
	    if (!Duplex$1.prototype[method]) Duplex$1.prototype[method] = _stream_writable.prototype[method];
	  }
	}

	function Duplex$1(options) {
	  if (!(this instanceof Duplex$1)) return new Duplex$1(options);
	  _stream_readable.call(this, options);
	  _stream_writable.call(this, options);
	  this.allowHalfOpen = true;

	  if (options) {
	    if (options.readable === false) this.readable = false;
	    if (options.writable === false) this.writable = false;

	    if (options.allowHalfOpen === false) {
	      this.allowHalfOpen = false;
	      this.once('end', onend);
	    }
	  }
	}

	Object.defineProperty(Duplex$1.prototype, 'writableHighWaterMark', {
	  // making it explicit this property is not enumerable
	  // because otherwise some prototype manipulation in
	  // userland will fail
	  enumerable: false,
	  get: function get() {
	    return this._writableState.highWaterMark;
	  }
	});
	Object.defineProperty(Duplex$1.prototype, 'writableBuffer', {
	  // making it explicit this property is not enumerable
	  // because otherwise some prototype manipulation in
	  // userland will fail
	  enumerable: false,
	  get: function get() {
	    return this._writableState && this._writableState.getBuffer();
	  }
	});
	Object.defineProperty(Duplex$1.prototype, 'writableLength', {
	  // making it explicit this property is not enumerable
	  // because otherwise some prototype manipulation in
	  // userland will fail
	  enumerable: false,
	  get: function get() {
	    return this._writableState.length;
	  }
	}); // the no-half-open enforcer

	function onend() {
	  // If the writable side ended, then we're ok.
	  if (this._writableState.ended) return; // no more data can be written.
	  // But allow more writes to happen in this tick.

	  process.nextTick(onEndNT, this);
	}

	function onEndNT(self) {
	  self.end();
	}

	Object.defineProperty(Duplex$1.prototype, 'destroyed', {
	  // making it explicit this property is not enumerable
	  // because otherwise some prototype manipulation in
	  // userland will fail
	  enumerable: false,
	  get: function get() {
	    if (this._readableState === undefined || this._writableState === undefined) {
	      return false;
	    }

	    return this._readableState.destroyed && this._writableState.destroyed;
	  },
	  set: function set(value) {
	    // we ignore the value if the stream
	    // has not been initialized yet
	    if (this._readableState === undefined || this._writableState === undefined) {
	      return;
	    } // backward compatibility, the user is explicitly
	    // managing destroyed


	    this._readableState.destroyed = value;
	    this._writableState.destroyed = value;
	  }
	});

	var safeBuffer = createCommonjsModule(function (module, exports) {
	/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
	/* eslint-disable node/no-deprecated-api */

	var Buffer = buffer__default['default'].Buffer;

	// alternative to using Object.keys for old browsers
	function copyProps (src, dst) {
	  for (var key in src) {
	    dst[key] = src[key];
	  }
	}
	if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
	  module.exports = buffer__default['default'];
	} else {
	  // Copy properties from require('buffer')
	  copyProps(buffer__default['default'], exports);
	  exports.Buffer = SafeBuffer;
	}

	function SafeBuffer (arg, encodingOrOffset, length) {
	  return Buffer(arg, encodingOrOffset, length)
	}

	SafeBuffer.prototype = Object.create(Buffer.prototype);

	// Copy static methods from Buffer
	copyProps(Buffer, SafeBuffer);

	SafeBuffer.from = function (arg, encodingOrOffset, length) {
	  if (typeof arg === 'number') {
	    throw new TypeError('Argument must not be a number')
	  }
	  return Buffer(arg, encodingOrOffset, length)
	};

	SafeBuffer.alloc = function (size, fill, encoding) {
	  if (typeof size !== 'number') {
	    throw new TypeError('Argument must be a number')
	  }
	  var buf = Buffer(size);
	  if (fill !== undefined) {
	    if (typeof encoding === 'string') {
	      buf.fill(fill, encoding);
	    } else {
	      buf.fill(fill);
	    }
	  } else {
	    buf.fill(0);
	  }
	  return buf
	};

	SafeBuffer.allocUnsafe = function (size) {
	  if (typeof size !== 'number') {
	    throw new TypeError('Argument must be a number')
	  }
	  return Buffer(size)
	};

	SafeBuffer.allocUnsafeSlow = function (size) {
	  if (typeof size !== 'number') {
	    throw new TypeError('Argument must be a number')
	  }
	  return buffer__default['default'].SlowBuffer(size)
	};
	});
	var safeBuffer_1 = safeBuffer.Buffer;

	/*<replacement>*/

	var Buffer$3 = safeBuffer.Buffer;
	/*</replacement>*/

	var isEncoding = Buffer$3.isEncoding || function (encoding) {
	  encoding = '' + encoding;
	  switch (encoding && encoding.toLowerCase()) {
	    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
	      return true;
	    default:
	      return false;
	  }
	};

	function _normalizeEncoding(enc) {
	  if (!enc) return 'utf8';
	  var retried;
	  while (true) {
	    switch (enc) {
	      case 'utf8':
	      case 'utf-8':
	        return 'utf8';
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return 'utf16le';
	      case 'latin1':
	      case 'binary':
	        return 'latin1';
	      case 'base64':
	      case 'ascii':
	      case 'hex':
	        return enc;
	      default:
	        if (retried) return; // undefined
	        enc = ('' + enc).toLowerCase();
	        retried = true;
	    }
	  }
	}
	// Do not cache `Buffer.isEncoding` when checking encoding names as some
	// modules monkey-patch it to support additional encodings
	function normalizeEncoding(enc) {
	  var nenc = _normalizeEncoding(enc);
	  if (typeof nenc !== 'string' && (Buffer$3.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
	  return nenc || enc;
	}

	// StringDecoder provides an interface for efficiently splitting a series of
	// buffers into a series of JS strings without breaking apart multi-byte
	// characters.
	var StringDecoder_1 = StringDecoder;
	function StringDecoder(encoding) {
	  this.encoding = normalizeEncoding(encoding);
	  var nb;
	  switch (this.encoding) {
	    case 'utf16le':
	      this.text = utf16Text;
	      this.end = utf16End;
	      nb = 4;
	      break;
	    case 'utf8':
	      this.fillLast = utf8FillLast;
	      nb = 4;
	      break;
	    case 'base64':
	      this.text = base64Text;
	      this.end = base64End;
	      nb = 3;
	      break;
	    default:
	      this.write = simpleWrite;
	      this.end = simpleEnd;
	      return;
	  }
	  this.lastNeed = 0;
	  this.lastTotal = 0;
	  this.lastChar = Buffer$3.allocUnsafe(nb);
	}

	StringDecoder.prototype.write = function (buf) {
	  if (buf.length === 0) return '';
	  var r;
	  var i;
	  if (this.lastNeed) {
	    r = this.fillLast(buf);
	    if (r === undefined) return '';
	    i = this.lastNeed;
	    this.lastNeed = 0;
	  } else {
	    i = 0;
	  }
	  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
	  return r || '';
	};

	StringDecoder.prototype.end = utf8End;

	// Returns only complete characters in a Buffer
	StringDecoder.prototype.text = utf8Text;

	// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
	StringDecoder.prototype.fillLast = function (buf) {
	  if (this.lastNeed <= buf.length) {
	    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
	    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
	  }
	  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
	  this.lastNeed -= buf.length;
	};

	// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
	// continuation byte. If an invalid byte is detected, -2 is returned.
	function utf8CheckByte(byte) {
	  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
	  return byte >> 6 === 0x02 ? -1 : -2;
	}

	// Checks at most 3 bytes at the end of a Buffer in order to detect an
	// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
	// needed to complete the UTF-8 character (if applicable) are returned.
	function utf8CheckIncomplete(self, buf, i) {
	  var j = buf.length - 1;
	  if (j < i) return 0;
	  var nb = utf8CheckByte(buf[j]);
	  if (nb >= 0) {
	    if (nb > 0) self.lastNeed = nb - 1;
	    return nb;
	  }
	  if (--j < i || nb === -2) return 0;
	  nb = utf8CheckByte(buf[j]);
	  if (nb >= 0) {
	    if (nb > 0) self.lastNeed = nb - 2;
	    return nb;
	  }
	  if (--j < i || nb === -2) return 0;
	  nb = utf8CheckByte(buf[j]);
	  if (nb >= 0) {
	    if (nb > 0) {
	      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
	    }
	    return nb;
	  }
	  return 0;
	}

	// Validates as many continuation bytes for a multi-byte UTF-8 character as
	// needed or are available. If we see a non-continuation byte where we expect
	// one, we "replace" the validated continuation bytes we've seen so far with
	// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
	// behavior. The continuation byte check is included three times in the case
	// where all of the continuation bytes for a character exist in the same buffer.
	// It is also done this way as a slight performance increase instead of using a
	// loop.
	function utf8CheckExtraBytes(self, buf, p) {
	  if ((buf[0] & 0xC0) !== 0x80) {
	    self.lastNeed = 0;
	    return '\ufffd';
	  }
	  if (self.lastNeed > 1 && buf.length > 1) {
	    if ((buf[1] & 0xC0) !== 0x80) {
	      self.lastNeed = 1;
	      return '\ufffd';
	    }
	    if (self.lastNeed > 2 && buf.length > 2) {
	      if ((buf[2] & 0xC0) !== 0x80) {
	        self.lastNeed = 2;
	        return '\ufffd';
	      }
	    }
	  }
	}

	// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
	function utf8FillLast(buf) {
	  var p = this.lastTotal - this.lastNeed;
	  var r = utf8CheckExtraBytes(this, buf);
	  if (r !== undefined) return r;
	  if (this.lastNeed <= buf.length) {
	    buf.copy(this.lastChar, p, 0, this.lastNeed);
	    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
	  }
	  buf.copy(this.lastChar, p, 0, buf.length);
	  this.lastNeed -= buf.length;
	}

	// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
	// partial character, the character's bytes are buffered until the required
	// number of bytes are available.
	function utf8Text(buf, i) {
	  var total = utf8CheckIncomplete(this, buf, i);
	  if (!this.lastNeed) return buf.toString('utf8', i);
	  this.lastTotal = total;
	  var end = buf.length - (total - this.lastNeed);
	  buf.copy(this.lastChar, 0, end);
	  return buf.toString('utf8', i, end);
	}

	// For UTF-8, a replacement character is added when ending on a partial
	// character.
	function utf8End(buf) {
	  var r = buf && buf.length ? this.write(buf) : '';
	  if (this.lastNeed) return r + '\ufffd';
	  return r;
	}

	// UTF-16LE typically needs two bytes per character, but even if we have an even
	// number of bytes available, we need to check if we end on a leading/high
	// surrogate. In that case, we need to wait for the next two bytes in order to
	// decode the last character properly.
	function utf16Text(buf, i) {
	  if ((buf.length - i) % 2 === 0) {
	    var r = buf.toString('utf16le', i);
	    if (r) {
	      var c = r.charCodeAt(r.length - 1);
	      if (c >= 0xD800 && c <= 0xDBFF) {
	        this.lastNeed = 2;
	        this.lastTotal = 4;
	        this.lastChar[0] = buf[buf.length - 2];
	        this.lastChar[1] = buf[buf.length - 1];
	        return r.slice(0, -1);
	      }
	    }
	    return r;
	  }
	  this.lastNeed = 1;
	  this.lastTotal = 2;
	  this.lastChar[0] = buf[buf.length - 1];
	  return buf.toString('utf16le', i, buf.length - 1);
	}

	// For UTF-16LE we do not explicitly append special replacement characters if we
	// end on a partial character, we simply let v8 handle that.
	function utf16End(buf) {
	  var r = buf && buf.length ? this.write(buf) : '';
	  if (this.lastNeed) {
	    var end = this.lastTotal - this.lastNeed;
	    return r + this.lastChar.toString('utf16le', 0, end);
	  }
	  return r;
	}

	function base64Text(buf, i) {
	  var n = (buf.length - i) % 3;
	  if (n === 0) return buf.toString('base64', i);
	  this.lastNeed = 3 - n;
	  this.lastTotal = 3;
	  if (n === 1) {
	    this.lastChar[0] = buf[buf.length - 1];
	  } else {
	    this.lastChar[0] = buf[buf.length - 2];
	    this.lastChar[1] = buf[buf.length - 1];
	  }
	  return buf.toString('base64', i, buf.length - n);
	}

	function base64End(buf) {
	  var r = buf && buf.length ? this.write(buf) : '';
	  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
	  return r;
	}

	// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
	function simpleWrite(buf) {
	  return buf.toString(this.encoding);
	}

	function simpleEnd(buf) {
	  return buf && buf.length ? this.write(buf) : '';
	}

	var string_decoder = {
		StringDecoder: StringDecoder_1
	};

	var ERR_STREAM_PREMATURE_CLOSE = errorsBrowser.codes.ERR_STREAM_PREMATURE_CLOSE;

	function once(callback) {
	  var called = false;
	  return function () {
	    if (called) return;
	    called = true;

	    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }

	    callback.apply(this, args);
	  };
	}

	function noop() {}

	function isRequest(stream) {
	  return stream.setHeader && typeof stream.abort === 'function';
	}

	function eos(stream, opts, callback) {
	  if (typeof opts === 'function') return eos(stream, null, opts);
	  if (!opts) opts = {};
	  callback = once(callback || noop);
	  var readable = opts.readable || opts.readable !== false && stream.readable;
	  var writable = opts.writable || opts.writable !== false && stream.writable;

	  var onlegacyfinish = function onlegacyfinish() {
	    if (!stream.writable) onfinish();
	  };

	  var writableEnded = stream._writableState && stream._writableState.finished;

	  var onfinish = function onfinish() {
	    writable = false;
	    writableEnded = true;
	    if (!readable) callback.call(stream);
	  };

	  var readableEnded = stream._readableState && stream._readableState.endEmitted;

	  var onend = function onend() {
	    readable = false;
	    readableEnded = true;
	    if (!writable) callback.call(stream);
	  };

	  var onerror = function onerror(err) {
	    callback.call(stream, err);
	  };

	  var onclose = function onclose() {
	    var err;

	    if (readable && !readableEnded) {
	      if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
	      return callback.call(stream, err);
	    }

	    if (writable && !writableEnded) {
	      if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
	      return callback.call(stream, err);
	    }
	  };

	  var onrequest = function onrequest() {
	    stream.req.on('finish', onfinish);
	  };

	  if (isRequest(stream)) {
	    stream.on('complete', onfinish);
	    stream.on('abort', onclose);
	    if (stream.req) onrequest();else stream.on('request', onrequest);
	  } else if (writable && !stream._writableState) {
	    // legacy streams
	    stream.on('end', onlegacyfinish);
	    stream.on('close', onlegacyfinish);
	  }

	  stream.on('end', onend);
	  stream.on('finish', onfinish);
	  if (opts.error !== false) stream.on('error', onerror);
	  stream.on('close', onclose);
	  return function () {
	    stream.removeListener('complete', onfinish);
	    stream.removeListener('abort', onclose);
	    stream.removeListener('request', onrequest);
	    if (stream.req) stream.req.removeListener('finish', onfinish);
	    stream.removeListener('end', onlegacyfinish);
	    stream.removeListener('close', onlegacyfinish);
	    stream.removeListener('finish', onfinish);
	    stream.removeListener('end', onend);
	    stream.removeListener('error', onerror);
	    stream.removeListener('close', onclose);
	  };
	}

	var endOfStream = eos;

	var _Object$setPrototypeO;

	function _defineProperty$1(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



	var kLastResolve = Symbol('lastResolve');
	var kLastReject = Symbol('lastReject');
	var kError = Symbol('error');
	var kEnded = Symbol('ended');
	var kLastPromise = Symbol('lastPromise');
	var kHandlePromise = Symbol('handlePromise');
	var kStream = Symbol('stream');

	function createIterResult(value, done) {
	  return {
	    value: value,
	    done: done
	  };
	}

	function readAndResolve(iter) {
	  var resolve = iter[kLastResolve];

	  if (resolve !== null) {
	    var data = iter[kStream].read(); // we defer if data is null
	    // we can be expecting either 'end' or
	    // 'error'

	    if (data !== null) {
	      iter[kLastPromise] = null;
	      iter[kLastResolve] = null;
	      iter[kLastReject] = null;
	      resolve(createIterResult(data, false));
	    }
	  }
	}

	function onReadable(iter) {
	  // we wait for the next tick, because it might
	  // emit an error with process.nextTick
	  process.nextTick(readAndResolve, iter);
	}

	function wrapForNext(lastPromise, iter) {
	  return function (resolve, reject) {
	    lastPromise.then(function () {
	      if (iter[kEnded]) {
	        resolve(createIterResult(undefined, true));
	        return;
	      }

	      iter[kHandlePromise](resolve, reject);
	    }, reject);
	  };
	}

	var AsyncIteratorPrototype = Object.getPrototypeOf(function () {});
	var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
	  get stream() {
	    return this[kStream];
	  },

	  next: function next() {
	    var _this = this;

	    // if we have detected an error in the meanwhile
	    // reject straight away
	    var error = this[kError];

	    if (error !== null) {
	      return Promise.reject(error);
	    }

	    if (this[kEnded]) {
	      return Promise.resolve(createIterResult(undefined, true));
	    }

	    if (this[kStream].destroyed) {
	      // We need to defer via nextTick because if .destroy(err) is
	      // called, the error will be emitted via nextTick, and
	      // we cannot guarantee that there is no error lingering around
	      // waiting to be emitted.
	      return new Promise(function (resolve, reject) {
	        process.nextTick(function () {
	          if (_this[kError]) {
	            reject(_this[kError]);
	          } else {
	            resolve(createIterResult(undefined, true));
	          }
	        });
	      });
	    } // if we have multiple next() calls
	    // we will wait for the previous Promise to finish
	    // this logic is optimized to support for await loops,
	    // where next() is only called once at a time


	    var lastPromise = this[kLastPromise];
	    var promise;

	    if (lastPromise) {
	      promise = new Promise(wrapForNext(lastPromise, this));
	    } else {
	      // fast path needed to support multiple this.push()
	      // without triggering the next() queue
	      var data = this[kStream].read();

	      if (data !== null) {
	        return Promise.resolve(createIterResult(data, false));
	      }

	      promise = new Promise(this[kHandlePromise]);
	    }

	    this[kLastPromise] = promise;
	    return promise;
	  }
	}, _defineProperty$1(_Object$setPrototypeO, Symbol.asyncIterator, function () {
	  return this;
	}), _defineProperty$1(_Object$setPrototypeO, "return", function _return() {
	  var _this2 = this;

	  // destroy(err, cb) is a private API
	  // we can guarantee we have that here, because we control the
	  // Readable class this is attached to
	  return new Promise(function (resolve, reject) {
	    _this2[kStream].destroy(null, function (err) {
	      if (err) {
	        reject(err);
	        return;
	      }

	      resolve(createIterResult(undefined, true));
	    });
	  });
	}), _Object$setPrototypeO), AsyncIteratorPrototype);

	var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {
	  var _Object$create;

	  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty$1(_Object$create, kStream, {
	    value: stream,
	    writable: true
	  }), _defineProperty$1(_Object$create, kLastResolve, {
	    value: null,
	    writable: true
	  }), _defineProperty$1(_Object$create, kLastReject, {
	    value: null,
	    writable: true
	  }), _defineProperty$1(_Object$create, kError, {
	    value: null,
	    writable: true
	  }), _defineProperty$1(_Object$create, kEnded, {
	    value: stream._readableState.endEmitted,
	    writable: true
	  }), _defineProperty$1(_Object$create, kHandlePromise, {
	    value: function value(resolve, reject) {
	      var data = iterator[kStream].read();

	      if (data) {
	        iterator[kLastPromise] = null;
	        iterator[kLastResolve] = null;
	        iterator[kLastReject] = null;
	        resolve(createIterResult(data, false));
	      } else {
	        iterator[kLastResolve] = resolve;
	        iterator[kLastReject] = reject;
	      }
	    },
	    writable: true
	  }), _Object$create));
	  iterator[kLastPromise] = null;
	  endOfStream(stream, function (err) {
	    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {
	      var reject = iterator[kLastReject]; // reject if we are waiting for data in the Promise
	      // returned by next() and store the error

	      if (reject !== null) {
	        iterator[kLastPromise] = null;
	        iterator[kLastResolve] = null;
	        iterator[kLastReject] = null;
	        reject(err);
	      }

	      iterator[kError] = err;
	      return;
	    }

	    var resolve = iterator[kLastResolve];

	    if (resolve !== null) {
	      iterator[kLastPromise] = null;
	      iterator[kLastResolve] = null;
	      iterator[kLastReject] = null;
	      resolve(createIterResult(undefined, true));
	    }

	    iterator[kEnded] = true;
	  });
	  stream.on('readable', onReadable.bind(null, iterator));
	  return iterator;
	};

	var async_iterator = createReadableStreamAsyncIterator;

	var fromBrowser = function () {
	  throw new Error('Readable.from is not available in the browser')
	};

	var _stream_readable = Readable;
	/*<replacement>*/

	var Duplex$2;
	/*</replacement>*/

	Readable.ReadableState = ReadableState;
	/*<replacement>*/

	var EE = events__default['default'].EventEmitter;

	var EElistenerCount = function EElistenerCount(emitter, type) {
	  return emitter.listeners(type).length;
	};
	/*</replacement>*/

	/*<replacement>*/



	/*</replacement>*/


	var Buffer$4 = buffer__default['default'].Buffer;

	var OurUint8Array$1 = commonjsGlobal.Uint8Array || function () {};

	function _uint8ArrayToBuffer$1(chunk) {
	  return Buffer$4.from(chunk);
	}

	function _isUint8Array$1(obj) {
	  return Buffer$4.isBuffer(obj) || obj instanceof OurUint8Array$1;
	}
	/*<replacement>*/




	var debug;

	if (debugUtil && debugUtil.debuglog) {
	  debug = debugUtil.debuglog('stream');
	} else {
	  debug = function debug() {};
	}
	/*</replacement>*/






	var getHighWaterMark$2 = state.getHighWaterMark;

	var _require$codes$1 = errorsBrowser.codes,
	    ERR_INVALID_ARG_TYPE$1 = _require$codes$1.ERR_INVALID_ARG_TYPE,
	    ERR_STREAM_PUSH_AFTER_EOF = _require$codes$1.ERR_STREAM_PUSH_AFTER_EOF,
	    ERR_METHOD_NOT_IMPLEMENTED$1 = _require$codes$1.ERR_METHOD_NOT_IMPLEMENTED,
	    ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes$1.ERR_STREAM_UNSHIFT_AFTER_END_EVENT; // Lazy loaded to improve the startup performance.


	var StringDecoder$1;
	var createReadableStreamAsyncIterator$1;
	var from;

	inherits_browser(Readable, streamBrowser);

	var errorOrDestroy$2 = destroy_1.errorOrDestroy;
	var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

	function prependListener(emitter, event, fn) {
	  // Sadly this is not cacheable as some libraries bundle their own
	  // event emitter implementation with them.
	  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any
	  // userland ones.  NEVER DO THIS. This is here only because this code needs
	  // to continue to work with older versions of Node.js that do not include
	  // the prependListener() method. The goal is to eventually remove this hack.

	  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
	}

	function ReadableState(options, stream, isDuplex) {
	  Duplex$2 = Duplex$2 || _stream_duplex;
	  options = options || {}; // Duplex streams are both readable and writable, but share
	  // the same options object.
	  // However, some cases require setting options to different
	  // values for the readable and the writable sides of the duplex stream.
	  // These options can be provided separately as readableXXX and writableXXX.

	  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex$2; // object stream flag. Used to make read(n) ignore n and to
	  // make all the buffer merging and length checks go away

	  this.objectMode = !!options.objectMode;
	  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer
	  // Note: 0 is a valid value, means "don't call _read preemptively ever"

	  this.highWaterMark = getHighWaterMark$2(this, options, 'readableHighWaterMark', isDuplex); // A linked list is used to store data chunks instead of an array because the
	  // linked list can remove elements from the beginning faster than
	  // array.shift()

	  this.buffer = new buffer_list();
	  this.length = 0;
	  this.pipes = null;
	  this.pipesCount = 0;
	  this.flowing = null;
	  this.ended = false;
	  this.endEmitted = false;
	  this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted
	  // immediately, or on a later tick.  We set this to true at first, because
	  // any actions that shouldn't happen until "later" should generally also
	  // not happen before the first read call.

	  this.sync = true; // whenever we return null, then we set a flag to say
	  // that we're awaiting a 'readable' event emission.

	  this.needReadable = false;
	  this.emittedReadable = false;
	  this.readableListening = false;
	  this.resumeScheduled = false;
	  this.paused = true; // Should close be emitted on destroy. Defaults to true.

	  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'end' (and potentially 'finish')

	  this.autoDestroy = !!options.autoDestroy; // has it been destroyed

	  this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.

	  this.defaultEncoding = options.defaultEncoding || 'utf8'; // the number of writers that are awaiting a drain event in .pipe()s

	  this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled

	  this.readingMore = false;
	  this.decoder = null;
	  this.encoding = null;

	  if (options.encoding) {
	    if (!StringDecoder$1) StringDecoder$1 = string_decoder.StringDecoder;
	    this.decoder = new StringDecoder$1(options.encoding);
	    this.encoding = options.encoding;
	  }
	}

	function Readable(options) {
	  Duplex$2 = Duplex$2 || _stream_duplex;
	  if (!(this instanceof Readable)) return new Readable(options); // Checking for a Stream.Duplex instance is faster here instead of inside
	  // the ReadableState constructor, at least with V8 6.5

	  var isDuplex = this instanceof Duplex$2;
	  this._readableState = new ReadableState(options, this, isDuplex); // legacy

	  this.readable = true;

	  if (options) {
	    if (typeof options.read === 'function') this._read = options.read;
	    if (typeof options.destroy === 'function') this._destroy = options.destroy;
	  }

	  streamBrowser.call(this);
	}

	Object.defineProperty(Readable.prototype, 'destroyed', {
	  // making it explicit this property is not enumerable
	  // because otherwise some prototype manipulation in
	  // userland will fail
	  enumerable: false,
	  get: function get() {
	    if (this._readableState === undefined) {
	      return false;
	    }

	    return this._readableState.destroyed;
	  },
	  set: function set(value) {
	    // we ignore the value if the stream
	    // has not been initialized yet
	    if (!this._readableState) {
	      return;
	    } // backward compatibility, the user is explicitly
	    // managing destroyed


	    this._readableState.destroyed = value;
	  }
	});
	Readable.prototype.destroy = destroy_1.destroy;
	Readable.prototype._undestroy = destroy_1.undestroy;

	Readable.prototype._destroy = function (err, cb) {
	  cb(err);
	}; // Manually shove something into the read() buffer.
	// This returns true if the highWaterMark has not been hit yet,
	// similar to how Writable.write() returns true if you should
	// write() some more.


	Readable.prototype.push = function (chunk, encoding) {
	  var state = this._readableState;
	  var skipChunkCheck;

	  if (!state.objectMode) {
	    if (typeof chunk === 'string') {
	      encoding = encoding || state.defaultEncoding;

	      if (encoding !== state.encoding) {
	        chunk = Buffer$4.from(chunk, encoding);
	        encoding = '';
	      }

	      skipChunkCheck = true;
	    }
	  } else {
	    skipChunkCheck = true;
	  }

	  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
	}; // Unshift should *always* be something directly out of read()


	Readable.prototype.unshift = function (chunk) {
	  return readableAddChunk(this, chunk, null, true, false);
	};

	function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
	  debug('readableAddChunk', chunk);
	  var state = stream._readableState;

	  if (chunk === null) {
	    state.reading = false;
	    onEofChunk(stream, state);
	  } else {
	    var er;
	    if (!skipChunkCheck) er = chunkInvalid(state, chunk);

	    if (er) {
	      errorOrDestroy$2(stream, er);
	    } else if (state.objectMode || chunk && chunk.length > 0) {
	      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer$4.prototype) {
	        chunk = _uint8ArrayToBuffer$1(chunk);
	      }

	      if (addToFront) {
	        if (state.endEmitted) errorOrDestroy$2(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);
	      } else if (state.ended) {
	        errorOrDestroy$2(stream, new ERR_STREAM_PUSH_AFTER_EOF());
	      } else if (state.destroyed) {
	        return false;
	      } else {
	        state.reading = false;

	        if (state.decoder && !encoding) {
	          chunk = state.decoder.write(chunk);
	          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
	        } else {
	          addChunk(stream, state, chunk, false);
	        }
	      }
	    } else if (!addToFront) {
	      state.reading = false;
	      maybeReadMore(stream, state);
	    }
	  } // We can push more data if we are below the highWaterMark.
	  // Also, if we have no data yet, we can stand some more bytes.
	  // This is to work around cases where hwm=0, such as the repl.


	  return !state.ended && (state.length < state.highWaterMark || state.length === 0);
	}

	function addChunk(stream, state, chunk, addToFront) {
	  if (state.flowing && state.length === 0 && !state.sync) {
	    state.awaitDrain = 0;
	    stream.emit('data', chunk);
	  } else {
	    // update the buffer info.
	    state.length += state.objectMode ? 1 : chunk.length;
	    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
	    if (state.needReadable) emitReadable(stream);
	  }

	  maybeReadMore(stream, state);
	}

	function chunkInvalid(state, chunk) {
	  var er;

	  if (!_isUint8Array$1(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
	    er = new ERR_INVALID_ARG_TYPE$1('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);
	  }

	  return er;
	}

	Readable.prototype.isPaused = function () {
	  return this._readableState.flowing === false;
	}; // backwards compatibility.


	Readable.prototype.setEncoding = function (enc) {
	  if (!StringDecoder$1) StringDecoder$1 = string_decoder.StringDecoder;
	  var decoder = new StringDecoder$1(enc);
	  this._readableState.decoder = decoder; // If setEncoding(null), decoder.encoding equals utf8

	  this._readableState.encoding = this._readableState.decoder.encoding; // Iterate over current buffer to convert already stored Buffers:

	  var p = this._readableState.buffer.head;
	  var content = '';

	  while (p !== null) {
	    content += decoder.write(p.data);
	    p = p.next;
	  }

	  this._readableState.buffer.clear();

	  if (content !== '') this._readableState.buffer.push(content);
	  this._readableState.length = content.length;
	  return this;
	}; // Don't raise the hwm > 1GB


	var MAX_HWM = 0x40000000;

	function computeNewHighWaterMark(n) {
	  if (n >= MAX_HWM) {
	    // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.
	    n = MAX_HWM;
	  } else {
	    // Get the next highest power of 2 to prevent increasing hwm excessively in
	    // tiny amounts
	    n--;
	    n |= n >>> 1;
	    n |= n >>> 2;
	    n |= n >>> 4;
	    n |= n >>> 8;
	    n |= n >>> 16;
	    n++;
	  }

	  return n;
	} // This function is designed to be inlinable, so please take care when making
	// changes to the function body.


	function howMuchToRead(n, state) {
	  if (n <= 0 || state.length === 0 && state.ended) return 0;
	  if (state.objectMode) return 1;

	  if (n !== n) {
	    // Only flow one buffer at a time
	    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
	  } // If we're asking for more than the current hwm, then raise the hwm.


	  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
	  if (n <= state.length) return n; // Don't have enough

	  if (!state.ended) {
	    state.needReadable = true;
	    return 0;
	  }

	  return state.length;
	} // you can override either this method, or the async _read(n) below.


	Readable.prototype.read = function (n) {
	  debug('read', n);
	  n = parseInt(n, 10);
	  var state = this._readableState;
	  var nOrig = n;
	  if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we
	  // already have a bunch of data in the buffer, then just trigger
	  // the 'readable' event and move on.

	  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
	    debug('read: emitReadable', state.length, state.ended);
	    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
	    return null;
	  }

	  n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.

	  if (n === 0 && state.ended) {
	    if (state.length === 0) endReadable(this);
	    return null;
	  } // All the actual chunk generation logic needs to be
	  // *below* the call to _read.  The reason is that in certain
	  // synthetic stream cases, such as passthrough streams, _read
	  // may be a completely synchronous operation which may change
	  // the state of the read buffer, providing enough data when
	  // before there was *not* enough.
	  //
	  // So, the steps are:
	  // 1. Figure out what the state of things will be after we do
	  // a read from the buffer.
	  //
	  // 2. If that resulting state will trigger a _read, then call _read.
	  // Note that this may be asynchronous, or synchronous.  Yes, it is
	  // deeply ugly to write APIs this way, but that still doesn't mean
	  // that the Readable class should behave improperly, as streams are
	  // designed to be sync/async agnostic.
	  // Take note if the _read call is sync or async (ie, if the read call
	  // has returned yet), so that we know whether or not it's safe to emit
	  // 'readable' etc.
	  //
	  // 3. Actually pull the requested chunks out of the buffer and return.
	  // if we need a readable event, then we need to do some reading.


	  var doRead = state.needReadable;
	  debug('need readable', doRead); // if we currently have less than the highWaterMark, then also read some

	  if (state.length === 0 || state.length - n < state.highWaterMark) {
	    doRead = true;
	    debug('length less than watermark', doRead);
	  } // however, if we've ended, then there's no point, and if we're already
	  // reading, then it's unnecessary.


	  if (state.ended || state.reading) {
	    doRead = false;
	    debug('reading or ended', doRead);
	  } else if (doRead) {
	    debug('do read');
	    state.reading = true;
	    state.sync = true; // if the length is currently zero, then we *need* a readable event.

	    if (state.length === 0) state.needReadable = true; // call internal read method

	    this._read(state.highWaterMark);

	    state.sync = false; // If _read pushed data synchronously, then `reading` will be false,
	    // and we need to re-evaluate how much data we can return to the user.

	    if (!state.reading) n = howMuchToRead(nOrig, state);
	  }

	  var ret;
	  if (n > 0) ret = fromList(n, state);else ret = null;

	  if (ret === null) {
	    state.needReadable = state.length <= state.highWaterMark;
	    n = 0;
	  } else {
	    state.length -= n;
	    state.awaitDrain = 0;
	  }

	  if (state.length === 0) {
	    // If we have nothing in the buffer, then we want to know
	    // as soon as we *do* get something into the buffer.
	    if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.

	    if (nOrig !== n && state.ended) endReadable(this);
	  }

	  if (ret !== null) this.emit('data', ret);
	  return ret;
	};

	function onEofChunk(stream, state) {
	  debug('onEofChunk');
	  if (state.ended) return;

	  if (state.decoder) {
	    var chunk = state.decoder.end();

	    if (chunk && chunk.length) {
	      state.buffer.push(chunk);
	      state.length += state.objectMode ? 1 : chunk.length;
	    }
	  }

	  state.ended = true;

	  if (state.sync) {
	    // if we are sync, wait until next tick to emit the data.
	    // Otherwise we risk emitting data in the flow()
	    // the readable code triggers during a read() call
	    emitReadable(stream);
	  } else {
	    // emit 'readable' now to make sure it gets picked up.
	    state.needReadable = false;

	    if (!state.emittedReadable) {
	      state.emittedReadable = true;
	      emitReadable_(stream);
	    }
	  }
	} // Don't emit readable right away in sync mode, because this can trigger
	// another read() call => stack overflow.  This way, it might trigger
	// a nextTick recursion warning, but that's not so bad.


	function emitReadable(stream) {
	  var state = stream._readableState;
	  debug('emitReadable', state.needReadable, state.emittedReadable);
	  state.needReadable = false;

	  if (!state.emittedReadable) {
	    debug('emitReadable', state.flowing);
	    state.emittedReadable = true;
	    process.nextTick(emitReadable_, stream);
	  }
	}

	function emitReadable_(stream) {
	  var state = stream._readableState;
	  debug('emitReadable_', state.destroyed, state.length, state.ended);

	  if (!state.destroyed && (state.length || state.ended)) {
	    stream.emit('readable');
	    state.emittedReadable = false;
	  } // The stream needs another readable event if
	  // 1. It is not flowing, as the flow mechanism will take
	  //    care of it.
	  // 2. It is not ended.
	  // 3. It is below the highWaterMark, so we can schedule
	  //    another readable later.


	  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
	  flow(stream);
	} // at this point, the user has presumably seen the 'readable' event,
	// and called read() to consume some data.  that may have triggered
	// in turn another _read(n) call, in which case reading = true if
	// it's in progress.
	// However, if we're not ended, or reading, and the length < hwm,
	// then go ahead and try to read some more preemptively.


	function maybeReadMore(stream, state) {
	  if (!state.readingMore) {
	    state.readingMore = true;
	    process.nextTick(maybeReadMore_, stream, state);
	  }
	}

	function maybeReadMore_(stream, state) {
	  // Attempt to read more data if we should.
	  //
	  // The conditions for reading more data are (one of):
	  // - Not enough data buffered (state.length < state.highWaterMark). The loop
	  //   is responsible for filling the buffer with enough data if such data
	  //   is available. If highWaterMark is 0 and we are not in the flowing mode
	  //   we should _not_ attempt to buffer any extra data. We'll get more data
	  //   when the stream consumer calls read() instead.
	  // - No data in the buffer, and the stream is in flowing mode. In this mode
	  //   the loop below is responsible for ensuring read() is called. Failing to
	  //   call read here would abort the flow and there's no other mechanism for
	  //   continuing the flow if the stream consumer has just subscribed to the
	  //   'data' event.
	  //
	  // In addition to the above conditions to keep reading data, the following
	  // conditions prevent the data from being read:
	  // - The stream has ended (state.ended).
	  // - There is already a pending 'read' operation (state.reading). This is a
	  //   case where the the stream has called the implementation defined _read()
	  //   method, but they are processing the call asynchronously and have _not_
	  //   called push() with new data. In this case we skip performing more
	  //   read()s. The execution ends in this method again after the _read() ends
	  //   up calling push() with more data.
	  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
	    var len = state.length;
	    debug('maybeReadMore read 0');
	    stream.read(0);
	    if (len === state.length) // didn't get any data, stop spinning.
	      break;
	  }

	  state.readingMore = false;
	} // abstract method.  to be overridden in specific implementation classes.
	// call cb(er, data) where data is <= n in length.
	// for virtual (non-string, non-buffer) streams, "length" is somewhat
	// arbitrary, and perhaps not very meaningful.


	Readable.prototype._read = function (n) {
	  errorOrDestroy$2(this, new ERR_METHOD_NOT_IMPLEMENTED$1('_read()'));
	};

	Readable.prototype.pipe = function (dest, pipeOpts) {
	  var src = this;
	  var state = this._readableState;

	  switch (state.pipesCount) {
	    case 0:
	      state.pipes = dest;
	      break;

	    case 1:
	      state.pipes = [state.pipes, dest];
	      break;

	    default:
	      state.pipes.push(dest);
	      break;
	  }

	  state.pipesCount += 1;
	  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
	  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
	  var endFn = doEnd ? onend : unpipe;
	  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);
	  dest.on('unpipe', onunpipe);

	  function onunpipe(readable, unpipeInfo) {
	    debug('onunpipe');

	    if (readable === src) {
	      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
	        unpipeInfo.hasUnpiped = true;
	        cleanup();
	      }
	    }
	  }

	  function onend() {
	    debug('onend');
	    dest.end();
	  } // when the dest drains, it reduces the awaitDrain counter
	  // on the source.  This would be more elegant with a .once()
	  // handler in flow(), but adding and removing repeatedly is
	  // too slow.


	  var ondrain = pipeOnDrain(src);
	  dest.on('drain', ondrain);
	  var cleanedUp = false;

	  function cleanup() {
	    debug('cleanup'); // cleanup event handlers once the pipe is broken

	    dest.removeListener('close', onclose);
	    dest.removeListener('finish', onfinish);
	    dest.removeListener('drain', ondrain);
	    dest.removeListener('error', onerror);
	    dest.removeListener('unpipe', onunpipe);
	    src.removeListener('end', onend);
	    src.removeListener('end', unpipe);
	    src.removeListener('data', ondata);
	    cleanedUp = true; // if the reader is waiting for a drain event from this
	    // specific writer, then it would cause it to never start
	    // flowing again.
	    // So, if this is awaiting a drain, then we just call it now.
	    // If we don't know, then assume that we are waiting for one.

	    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
	  }

	  src.on('data', ondata);

	  function ondata(chunk) {
	    debug('ondata');
	    var ret = dest.write(chunk);
	    debug('dest.write', ret);

	    if (ret === false) {
	      // If the user unpiped during `dest.write()`, it is possible
	      // to get stuck in a permanently paused state if that write
	      // also returned false.
	      // => Check whether `dest` is still a piping destination.
	      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf$1(state.pipes, dest) !== -1) && !cleanedUp) {
	        debug('false write response, pause', state.awaitDrain);
	        state.awaitDrain++;
	      }

	      src.pause();
	    }
	  } // if the dest has an error, then stop piping into it.
	  // however, don't suppress the throwing behavior for this.


	  function onerror(er) {
	    debug('onerror', er);
	    unpipe();
	    dest.removeListener('error', onerror);
	    if (EElistenerCount(dest, 'error') === 0) errorOrDestroy$2(dest, er);
	  } // Make sure our error handler is attached before userland ones.


	  prependListener(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.

	  function onclose() {
	    dest.removeListener('finish', onfinish);
	    unpipe();
	  }

	  dest.once('close', onclose);

	  function onfinish() {
	    debug('onfinish');
	    dest.removeListener('close', onclose);
	    unpipe();
	  }

	  dest.once('finish', onfinish);

	  function unpipe() {
	    debug('unpipe');
	    src.unpipe(dest);
	  } // tell the dest that it's being piped to


	  dest.emit('pipe', src); // start the flow if it hasn't been started already.

	  if (!state.flowing) {
	    debug('pipe resume');
	    src.resume();
	  }

	  return dest;
	};

	function pipeOnDrain(src) {
	  return function pipeOnDrainFunctionResult() {
	    var state = src._readableState;
	    debug('pipeOnDrain', state.awaitDrain);
	    if (state.awaitDrain) state.awaitDrain--;

	    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
	      state.flowing = true;
	      flow(src);
	    }
	  };
	}

	Readable.prototype.unpipe = function (dest) {
	  var state = this._readableState;
	  var unpipeInfo = {
	    hasUnpiped: false
	  }; // if we're not piping anywhere, then do nothing.

	  if (state.pipesCount === 0) return this; // just one destination.  most common case.

	  if (state.pipesCount === 1) {
	    // passed in one, but it's not the right one.
	    if (dest && dest !== state.pipes) return this;
	    if (!dest) dest = state.pipes; // got a match.

	    state.pipes = null;
	    state.pipesCount = 0;
	    state.flowing = false;
	    if (dest) dest.emit('unpipe', this, unpipeInfo);
	    return this;
	  } // slow case. multiple pipe destinations.


	  if (!dest) {
	    // remove all.
	    var dests = state.pipes;
	    var len = state.pipesCount;
	    state.pipes = null;
	    state.pipesCount = 0;
	    state.flowing = false;

	    for (var i = 0; i < len; i++) {
	      dests[i].emit('unpipe', this, {
	        hasUnpiped: false
	      });
	    }

	    return this;
	  } // try to find the right one.


	  var index = indexOf$1(state.pipes, dest);
	  if (index === -1) return this;
	  state.pipes.splice(index, 1);
	  state.pipesCount -= 1;
	  if (state.pipesCount === 1) state.pipes = state.pipes[0];
	  dest.emit('unpipe', this, unpipeInfo);
	  return this;
	}; // set up data events if they are asked for
	// Ensure readable listeners eventually get something


	Readable.prototype.on = function (ev, fn) {
	  var res = streamBrowser.prototype.on.call(this, ev, fn);
	  var state = this._readableState;

	  if (ev === 'data') {
	    // update readableListening so that resume() may be a no-op
	    // a few lines down. This is needed to support once('readable').
	    state.readableListening = this.listenerCount('readable') > 0; // Try start flowing on next tick if stream isn't explicitly paused

	    if (state.flowing !== false) this.resume();
	  } else if (ev === 'readable') {
	    if (!state.endEmitted && !state.readableListening) {
	      state.readableListening = state.needReadable = true;
	      state.flowing = false;
	      state.emittedReadable = false;
	      debug('on readable', state.length, state.reading);

	      if (state.length) {
	        emitReadable(this);
	      } else if (!state.reading) {
	        process.nextTick(nReadingNextTick, this);
	      }
	    }
	  }

	  return res;
	};

	Readable.prototype.addListener = Readable.prototype.on;

	Readable.prototype.removeListener = function (ev, fn) {
	  var res = streamBrowser.prototype.removeListener.call(this, ev, fn);

	  if (ev === 'readable') {
	    // We need to check if there is someone still listening to
	    // readable and reset the state. However this needs to happen
	    // after readable has been emitted but before I/O (nextTick) to
	    // support once('readable', fn) cycles. This means that calling
	    // resume within the same tick will have no
	    // effect.
	    process.nextTick(updateReadableListening, this);
	  }

	  return res;
	};

	Readable.prototype.removeAllListeners = function (ev) {
	  var res = streamBrowser.prototype.removeAllListeners.apply(this, arguments);

	  if (ev === 'readable' || ev === undefined) {
	    // We need to check if there is someone still listening to
	    // readable and reset the state. However this needs to happen
	    // after readable has been emitted but before I/O (nextTick) to
	    // support once('readable', fn) cycles. This means that calling
	    // resume within the same tick will have no
	    // effect.
	    process.nextTick(updateReadableListening, this);
	  }

	  return res;
	};

	function updateReadableListening(self) {
	  var state = self._readableState;
	  state.readableListening = self.listenerCount('readable') > 0;

	  if (state.resumeScheduled && !state.paused) {
	    // flowing needs to be set to true now, otherwise
	    // the upcoming resume will not flow.
	    state.flowing = true; // crude way to check if we should resume
	  } else if (self.listenerCount('data') > 0) {
	    self.resume();
	  }
	}

	function nReadingNextTick(self) {
	  debug('readable nexttick read 0');
	  self.read(0);
	} // pause() and resume() are remnants of the legacy readable stream API
	// If the user uses them, then switch into old mode.


	Readable.prototype.resume = function () {
	  var state = this._readableState;

	  if (!state.flowing) {
	    debug('resume'); // we flow only if there is no one listening
	    // for readable, but we still have to call
	    // resume()

	    state.flowing = !state.readableListening;
	    resume(this, state);
	  }

	  state.paused = false;
	  return this;
	};

	function resume(stream, state) {
	  if (!state.resumeScheduled) {
	    state.resumeScheduled = true;
	    process.nextTick(resume_, stream, state);
	  }
	}

	function resume_(stream, state) {
	  debug('resume', state.reading);

	  if (!state.reading) {
	    stream.read(0);
	  }

	  state.resumeScheduled = false;
	  stream.emit('resume');
	  flow(stream);
	  if (state.flowing && !state.reading) stream.read(0);
	}

	Readable.prototype.pause = function () {
	  debug('call pause flowing=%j', this._readableState.flowing);

	  if (this._readableState.flowing !== false) {
	    debug('pause');
	    this._readableState.flowing = false;
	    this.emit('pause');
	  }

	  this._readableState.paused = true;
	  return this;
	};

	function flow(stream) {
	  var state = stream._readableState;
	  debug('flow', state.flowing);

	  while (state.flowing && stream.read() !== null) {
	  }
	} // wrap an old-style stream as the async data source.
	// This is *not* part of the readable stream interface.
	// It is an ugly unfortunate mess of history.


	Readable.prototype.wrap = function (stream) {
	  var _this = this;

	  var state = this._readableState;
	  var paused = false;
	  stream.on('end', function () {
	    debug('wrapped end');

	    if (state.decoder && !state.ended) {
	      var chunk = state.decoder.end();
	      if (chunk && chunk.length) _this.push(chunk);
	    }

	    _this.push(null);
	  });
	  stream.on('data', function (chunk) {
	    debug('wrapped data');
	    if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode

	    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

	    var ret = _this.push(chunk);

	    if (!ret) {
	      paused = true;
	      stream.pause();
	    }
	  }); // proxy all the other methods.
	  // important when wrapping filters and duplexes.

	  for (var i in stream) {
	    if (this[i] === undefined && typeof stream[i] === 'function') {
	      this[i] = function methodWrap(method) {
	        return function methodWrapReturnFunction() {
	          return stream[method].apply(stream, arguments);
	        };
	      }(i);
	    }
	  } // proxy certain important events.


	  for (var n = 0; n < kProxyEvents.length; n++) {
	    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
	  } // when we try to consume some more bytes, simply unpause the
	  // underlying stream.


	  this._read = function (n) {
	    debug('wrapped _read', n);

	    if (paused) {
	      paused = false;
	      stream.resume();
	    }
	  };

	  return this;
	};

	if (typeof Symbol === 'function') {
	  Readable.prototype[Symbol.asyncIterator] = function () {
	    if (createReadableStreamAsyncIterator$1 === undefined) {
	      createReadableStreamAsyncIterator$1 = async_iterator;
	    }

	    return createReadableStreamAsyncIterator$1(this);
	  };
	}

	Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
	  // making it explicit this property is not enumerable
	  // because otherwise some prototype manipulation in
	  // userland will fail
	  enumerable: false,
	  get: function get() {
	    return this._readableState.highWaterMark;
	  }
	});
	Object.defineProperty(Readable.prototype, 'readableBuffer', {
	  // making it explicit this property is not enumerable
	  // because otherwise some prototype manipulation in
	  // userland will fail
	  enumerable: false,
	  get: function get() {
	    return this._readableState && this._readableState.buffer;
	  }
	});
	Object.defineProperty(Readable.prototype, 'readableFlowing', {
	  // making it explicit this property is not enumerable
	  // because otherwise some prototype manipulation in
	  // userland will fail
	  enumerable: false,
	  get: function get() {
	    return this._readableState.flowing;
	  },
	  set: function set(state) {
	    if (this._readableState) {
	      this._readableState.flowing = state;
	    }
	  }
	}); // exposed for testing purposes only.

	Readable._fromList = fromList;
	Object.defineProperty(Readable.prototype, 'readableLength', {
	  // making it explicit this property is not enumerable
	  // because otherwise some prototype manipulation in
	  // userland will fail
	  enumerable: false,
	  get: function get() {
	    return this._readableState.length;
	  }
	}); // Pluck off n bytes from an array of buffers.
	// Length is the combined lengths of all the buffers in the list.
	// This function is designed to be inlinable, so please take care when making
	// changes to the function body.

	function fromList(n, state) {
	  // nothing buffered
	  if (state.length === 0) return null;
	  var ret;
	  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
	    // read it all, truncate the list
	    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);
	    state.buffer.clear();
	  } else {
	    // read part of list
	    ret = state.buffer.consume(n, state.decoder);
	  }
	  return ret;
	}

	function endReadable(stream) {
	  var state = stream._readableState;
	  debug('endReadable', state.endEmitted);

	  if (!state.endEmitted) {
	    state.ended = true;
	    process.nextTick(endReadableNT, state, stream);
	  }
	}

	function endReadableNT(state, stream) {
	  debug('endReadableNT', state.endEmitted, state.length); // Check that we didn't get one last unshift.

	  if (!state.endEmitted && state.length === 0) {
	    state.endEmitted = true;
	    stream.readable = false;
	    stream.emit('end');

	    if (state.autoDestroy) {
	      // In case of duplex streams we need a way to detect
	      // if the writable side is ready for autoDestroy as well
	      var wState = stream._writableState;

	      if (!wState || wState.autoDestroy && wState.finished) {
	        stream.destroy();
	      }
	    }
	  }
	}

	if (typeof Symbol === 'function') {
	  Readable.from = function (iterable, opts) {
	    if (from === undefined) {
	      from = fromBrowser;
	    }

	    return from(Readable, iterable, opts);
	  };
	}

	function indexOf$1(xs, x) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    if (xs[i] === x) return i;
	  }

	  return -1;
	}

	var _stream_transform = Transform;

	var _require$codes$2 = errorsBrowser.codes,
	    ERR_METHOD_NOT_IMPLEMENTED$2 = _require$codes$2.ERR_METHOD_NOT_IMPLEMENTED,
	    ERR_MULTIPLE_CALLBACK$1 = _require$codes$2.ERR_MULTIPLE_CALLBACK,
	    ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes$2.ERR_TRANSFORM_ALREADY_TRANSFORMING,
	    ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes$2.ERR_TRANSFORM_WITH_LENGTH_0;



	inherits_browser(Transform, _stream_duplex);

	function afterTransform(er, data) {
	  var ts = this._transformState;
	  ts.transforming = false;
	  var cb = ts.writecb;

	  if (cb === null) {
	    return this.emit('error', new ERR_MULTIPLE_CALLBACK$1());
	  }

	  ts.writechunk = null;
	  ts.writecb = null;
	  if (data != null) // single equals check for both `null` and `undefined`
	    this.push(data);
	  cb(er);
	  var rs = this._readableState;
	  rs.reading = false;

	  if (rs.needReadable || rs.length < rs.highWaterMark) {
	    this._read(rs.highWaterMark);
	  }
	}

	function Transform(options) {
	  if (!(this instanceof Transform)) return new Transform(options);
	  _stream_duplex.call(this, options);
	  this._transformState = {
	    afterTransform: afterTransform.bind(this),
	    needTransform: false,
	    transforming: false,
	    writecb: null,
	    writechunk: null,
	    writeencoding: null
	  }; // start out asking for a readable event once data is transformed.

	  this._readableState.needReadable = true; // we have implemented the _read method, and done the other things
	  // that Readable wants before the first _read call, so unset the
	  // sync guard flag.

	  this._readableState.sync = false;

	  if (options) {
	    if (typeof options.transform === 'function') this._transform = options.transform;
	    if (typeof options.flush === 'function') this._flush = options.flush;
	  } // When the writable side finishes, then flush out anything remaining.


	  this.on('prefinish', prefinish$1);
	}

	function prefinish$1() {
	  var _this = this;

	  if (typeof this._flush === 'function' && !this._readableState.destroyed) {
	    this._flush(function (er, data) {
	      done(_this, er, data);
	    });
	  } else {
	    done(this, null, null);
	  }
	}

	Transform.prototype.push = function (chunk, encoding) {
	  this._transformState.needTransform = false;
	  return _stream_duplex.prototype.push.call(this, chunk, encoding);
	}; // This is the part where you do stuff!
	// override this function in implementation classes.
	// 'chunk' is an input chunk.
	//
	// Call `push(newChunk)` to pass along transformed output
	// to the readable side.  You may call 'push' zero or more times.
	//
	// Call `cb(err)` when you are done with this chunk.  If you pass
	// an error, then that'll put the hurt on the whole operation.  If you
	// never call cb(), then you'll never get another chunk.


	Transform.prototype._transform = function (chunk, encoding, cb) {
	  cb(new ERR_METHOD_NOT_IMPLEMENTED$2('_transform()'));
	};

	Transform.prototype._write = function (chunk, encoding, cb) {
	  var ts = this._transformState;
	  ts.writecb = cb;
	  ts.writechunk = chunk;
	  ts.writeencoding = encoding;

	  if (!ts.transforming) {
	    var rs = this._readableState;
	    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
	  }
	}; // Doesn't matter what the args are here.
	// _transform does all the work.
	// That we got here means that the readable side wants more data.


	Transform.prototype._read = function (n) {
	  var ts = this._transformState;

	  if (ts.writechunk !== null && !ts.transforming) {
	    ts.transforming = true;

	    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
	  } else {
	    // mark that we need a transform, so that any data that comes in
	    // will get processed, now that we've asked for it.
	    ts.needTransform = true;
	  }
	};

	Transform.prototype._destroy = function (err, cb) {
	  _stream_duplex.prototype._destroy.call(this, err, function (err2) {
	    cb(err2);
	  });
	};

	function done(stream, er, data) {
	  if (er) return stream.emit('error', er);
	  if (data != null) // single equals check for both `null` and `undefined`
	    stream.push(data); // TODO(BridgeAR): Write a test for these two error cases
	  // if there's nothing in the write buffer, then that means
	  // that nothing more will ever be provided

	  if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
	  if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
	  return stream.push(null);
	}

	var _stream_passthrough = PassThrough;



	inherits_browser(PassThrough, _stream_transform);

	function PassThrough(options) {
	  if (!(this instanceof PassThrough)) return new PassThrough(options);
	  _stream_transform.call(this, options);
	}

	PassThrough.prototype._transform = function (chunk, encoding, cb) {
	  cb(null, chunk);
	};

	var eos$1;

	function once$1(callback) {
	  var called = false;
	  return function () {
	    if (called) return;
	    called = true;
	    callback.apply(void 0, arguments);
	  };
	}

	var _require$codes$3 = errorsBrowser.codes,
	    ERR_MISSING_ARGS = _require$codes$3.ERR_MISSING_ARGS,
	    ERR_STREAM_DESTROYED$1 = _require$codes$3.ERR_STREAM_DESTROYED;

	function noop$1(err) {
	  // Rethrow the error if it exists to avoid swallowing it
	  if (err) throw err;
	}

	function isRequest$1(stream) {
	  return stream.setHeader && typeof stream.abort === 'function';
	}

	function destroyer(stream, reading, writing, callback) {
	  callback = once$1(callback);
	  var closed = false;
	  stream.on('close', function () {
	    closed = true;
	  });
	  if (eos$1 === undefined) eos$1 = endOfStream;
	  eos$1(stream, {
	    readable: reading,
	    writable: writing
	  }, function (err) {
	    if (err) return callback(err);
	    closed = true;
	    callback();
	  });
	  var destroyed = false;
	  return function (err) {
	    if (closed) return;
	    if (destroyed) return;
	    destroyed = true; // request.destroy just do .end - .abort is what we want

	    if (isRequest$1(stream)) return stream.abort();
	    if (typeof stream.destroy === 'function') return stream.destroy();
	    callback(err || new ERR_STREAM_DESTROYED$1('pipe'));
	  };
	}

	function call(fn) {
	  fn();
	}

	function pipe(from, to) {
	  return from.pipe(to);
	}

	function popCallback(streams) {
	  if (!streams.length) return noop$1;
	  if (typeof streams[streams.length - 1] !== 'function') return noop$1;
	  return streams.pop();
	}

	function pipeline() {
	  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
	    streams[_key] = arguments[_key];
	  }

	  var callback = popCallback(streams);
	  if (Array.isArray(streams[0])) streams = streams[0];

	  if (streams.length < 2) {
	    throw new ERR_MISSING_ARGS('streams');
	  }

	  var error;
	  var destroys = streams.map(function (stream, i) {
	    var reading = i < streams.length - 1;
	    var writing = i > 0;
	    return destroyer(stream, reading, writing, function (err) {
	      if (!error) error = err;
	      if (err) destroys.forEach(call);
	      if (reading) return;
	      destroys.forEach(call);
	      callback(error);
	    });
	  });
	  return streams.reduce(pipe);
	}

	var pipeline_1 = pipeline;

	var readableBrowser = createCommonjsModule(function (module, exports) {
	exports = module.exports = _stream_readable;
	exports.Stream = exports;
	exports.Readable = exports;
	exports.Writable = _stream_writable;
	exports.Duplex = _stream_duplex;
	exports.Transform = _stream_transform;
	exports.PassThrough = _stream_passthrough;
	exports.finished = endOfStream;
	exports.pipeline = pipeline_1;
	});
	var readableBrowser_1 = readableBrowser.Stream;
	var readableBrowser_2 = readableBrowser.Readable;
	var readableBrowser_3 = readableBrowser.Writable;
	var readableBrowser_4 = readableBrowser.Duplex;
	var readableBrowser_5 = readableBrowser.Transform;
	var readableBrowser_6 = readableBrowser.PassThrough;
	var readableBrowser_7 = readableBrowser.finished;
	var readableBrowser_8 = readableBrowser.pipeline;

	// useful stuff
	const inherits = function(cls, superCtor, statics, prototype) {
	  // eslint-disable-next-line no-underscore-dangle
	  cls.super_ = superCtor;

	  if (!prototype) {
	    prototype = statics;
	    statics = null;
	  }

	  if (statics) {
	    Object.keys(statics).forEach(i => {
	      Object.defineProperty(cls, i, Object.getOwnPropertyDescriptor(statics, i));
	    });
	  }

	  const properties = {
	    constructor: {
	      value: cls,
	      enumerable: false,
	      writable: false,
	      configurable: true,
	    },
	  };
	  if (prototype) {
	    Object.keys(prototype).forEach(i => {
	      properties[i] = Object.getOwnPropertyDescriptor(prototype, i);
	    });
	  }

	  cls.prototype = Object.create(superCtor.prototype, properties);
	};

	// eslint-disable-next-line no-control-regex
	const xmlDecodeRegex = /[<>&'"\x7F\x00-\x08\x0B-\x0C\x0E-\x1F]/;
	const utils = {
	  nop() {},
	  promiseImmediate(value) {
	    return new Promise(resolve => {
	      if (commonjsGlobal.setImmediate) {
	        setImmediate(() => {
	          resolve(value);
	        });
	      } else {
	        // poorman's setImmediate - must wait at least 1ms
	        setTimeout(() => {
	          resolve(value);
	        }, 1);
	      }
	    });
	  },
	  inherits,
	  dateToExcel(d, date1904) {
	    return 25569 + ( d.getTime() / (24 * 3600 * 1000) ) - (date1904 ? 1462 : 0);
	  },
	  excelToDate(v, date1904) {
	    const millisecondSinceEpoch = Math.round((v - 25569 + (date1904 ? 1462 : 0)) * 24 * 3600 * 1000);
	    return new Date(millisecondSinceEpoch);
	  },
	  parsePath(filepath) {
	    const last = filepath.lastIndexOf('/');
	    return {
	      path: filepath.substring(0, last),
	      name: filepath.substring(last + 1),
	    };
	  },
	  getRelsPath(filepath) {
	    const path = utils.parsePath(filepath);
	    return `${path.path}/_rels/${path.name}.rels`;
	  },
	  xmlEncode(text) {
	    const regexResult = xmlDecodeRegex.exec(text);
	    if (!regexResult) return text;

	    let result = '';
	    let escape = '';
	    let lastIndex = 0;
	    let i = regexResult.index;
	    for (; i < text.length; i++) {
	      const charCode = text.charCodeAt(i);
	      switch (charCode) {
	        case 34: // "
	          escape = '&quot;';
	          break;
	        case 38: // &
	          escape = '&amp;';
	          break;
	        case 39: // '
	          escape = '&apos;';
	          break;
	        case 60: // <
	          escape = '&lt;';
	          break;
	        case 62: // >
	          escape = '&gt;';
	          break;
	        case 127:
	          escape = '';
	          break;
	        default: {
	          if (charCode <= 31 && (charCode <= 8 || (charCode >= 11 && charCode !== 13))) {
	            escape = '';
	            break;
	          }
	          continue;
	        }
	      }
	      if (lastIndex !== i) result += text.substring(lastIndex, i);
	      lastIndex = i + 1;
	      if (escape) result += escape;
	    }
	    if (lastIndex !== i) return result + text.substring(lastIndex, i);
	    return result;
	  },
	  xmlDecode(text) {
	    return text.replace(/&([a-z]*);/g, c => {
	      switch (c) {
	        case '&lt;':
	          return '<';
	        case '&gt;':
	          return '>';
	        case '&amp;':
	          return '&';
	        case '&apos;':
	          return '\'';
	        case '&quot;':
	          return '"';
	        default:
	          return c;
	      }
	    });
	  },
	  validInt(value) {
	    const i = parseInt(value, 10);
	    return !Number.isNaN(i) ? i : 0;
	  },

	  isDateFmt(fmt) {
	    if (!fmt) {
	      return false;
	    }

	    // must remove all chars inside quotes and []
	    fmt = fmt.replace(/\[[^\]]*]/g, '');
	    fmt = fmt.replace(/"[^"]*"/g, '');
	    // then check for date formatting chars
	    const result = fmt.match(/[ymdhMsb]+/) !== null;
	    return result;
	  },

	  fs: {
	    exists(path) {
	      return new Promise(resolve => {
	        fs__default['default'].access(path, fs__default['default'].constants.F_OK, err => {
	          resolve(!err);
	        });
	      });
	    },
	  },

	  toIsoDateString(dt) {
	    return dt.toIsoString().subsstr(0, 10);
	  },
	};

	var utils_1 = utils;

	// StringBuf - a way to keep string memory operations to a minimum
	// while building the strings for the xml files
	class StringBuf {
	  constructor(options) {
	    this._buf = Buffer.alloc((options && options.size) || 16384);
	    this._encoding = (options && options.encoding) || 'utf8';

	    // where in the buffer we are at
	    this._inPos = 0;

	    // for use by toBuffer()
	    this._buffer = undefined;
	  }

	  get length() {
	    return this._inPos;
	  }

	  get capacity() {
	    return this._buf.length;
	  }

	  get buffer() {
	    return this._buf;
	  }

	  toBuffer() {
	    // return the current data as a single enclosing buffer
	    if (!this._buffer) {
	      this._buffer = Buffer.alloc(this.length);
	      this._buf.copy(this._buffer, 0, 0, this.length);
	    }
	    return this._buffer;
	  }

	  reset(position) {
	    position = position || 0;
	    this._buffer = undefined;
	    this._inPos = position;
	  }

	  _grow(min) {
	    let size = this._buf.length * 2;
	    while (size < min) {
	      size *= 2;
	    }
	    const buf = Buffer.alloc(size);
	    this._buf.copy(buf, 0);
	    this._buf = buf;
	  }

	  addText(text) {
	    this._buffer = undefined;

	    let inPos = this._inPos + this._buf.write(text, this._inPos, this._encoding);

	    // if we've hit (or nearing capacity), grow the buf
	    while (inPos >= this._buf.length - 4) {
	      this._grow(this._inPos + text.length);

	      // keep trying to write until we've completely written the text
	      inPos = this._inPos + this._buf.write(text, this._inPos, this._encoding);
	    }

	    this._inPos = inPos;
	  }

	  addStringBuf(inBuf) {
	    if (inBuf.length) {
	      this._buffer = undefined;

	      if (this.length + inBuf.length > this.capacity) {
	        this._grow(this.length + inBuf.length);
	      }
	      // eslint-disable-next-line no-underscore-dangle
	      inBuf._buf.copy(this._buf, this._inPos, 0, inBuf.length);
	      this._inPos += inBuf.length;
	    }
	  }
	}

	var stringBuf = StringBuf;

	/* eslint-disable max-classes-per-file */





	// =============================================================================
	// data chunks - encapsulating incoming data
	class StringChunk {
	  constructor(data, encoding) {
	    this._data = data;
	    this._encoding = encoding;
	  }

	  get length() {
	    return this.toBuffer().length;
	  }

	  // copy to target buffer
	  copy(target, targetOffset, offset, length) {
	    return this.toBuffer().copy(target, targetOffset, offset, length);
	  }

	  toBuffer() {
	    if (!this._buffer) {
	      this._buffer = Buffer.from(this._data, this._encoding);
	    }
	    return this._buffer;
	  }
	}

	class StringBufChunk {
	  constructor(data) {
	    this._data = data;
	  }

	  get length() {
	    return this._data.length;
	  }

	  // copy to target buffer
	  copy(target, targetOffset, offset, length) {
	    // eslint-disable-next-line no-underscore-dangle
	    return this._data._buf.copy(target, targetOffset, offset, length);
	  }

	  toBuffer() {
	    return this._data.toBuffer();
	  }
	}

	class BufferChunk {
	  constructor(data) {
	    this._data = data;
	  }

	  get length() {
	    return this._data.length;
	  }

	  // copy to target buffer
	  copy(target, targetOffset, offset, length) {
	    this._data.copy(target, targetOffset, offset, length);
	  }

	  toBuffer() {
	    return this._data;
	  }
	}

	// =============================================================================
	// ReadWriteBuf - a single buffer supporting simple read-write
	class ReadWriteBuf {
	  constructor(size) {
	    this.size = size;
	    // the buffer
	    this.buffer = Buffer.alloc(size);
	    // read index
	    this.iRead = 0;
	    // write index
	    this.iWrite = 0;
	  }

	  toBuffer() {
	    if (this.iRead === 0 && this.iWrite === this.size) {
	      return this.buffer;
	    }

	    const buf = Buffer.alloc(this.iWrite - this.iRead);
	    this.buffer.copy(buf, 0, this.iRead, this.iWrite);
	    return buf;
	  }

	  get length() {
	    return this.iWrite - this.iRead;
	  }

	  get eod() {
	    return this.iRead === this.iWrite;
	  }

	  get full() {
	    return this.iWrite === this.size;
	  }

	  read(size) {
	    let buf;
	    // read size bytes from buffer and return buffer
	    if (size === 0) {
	      // special case - return null if no data requested
	      return null;
	    }

	    if (size === undefined || size >= this.length) {
	      // if no size specified or size is at least what we have then return all of the bytes
	      buf = this.toBuffer();
	      this.iRead = this.iWrite;
	      return buf;
	    }

	    // otherwise return a chunk
	    buf = Buffer.alloc(size);
	    this.buffer.copy(buf, 0, this.iRead, size);
	    this.iRead += size;
	    return buf;
	  }

	  write(chunk, offset, length) {
	    // write as many bytes from data from optional source offset
	    // and return number of bytes written
	    const size = Math.min(length, this.size - this.iWrite);
	    chunk.copy(this.buffer, this.iWrite, offset, offset + size);
	    this.iWrite += size;
	    return size;
	  }
	}

	// =============================================================================
	// StreamBuf - a multi-purpose read-write stream
	//  As MemBuf - write as much data as you like. Then call toBuffer() to consolidate
	//  As StreamHub - pipe to multiple writables
	//  As readable stream - feed data into the writable part and have some other code read from it.

	// Note: Not sure why but StreamBuf does not like JS "class" sugar. It fails the
	// integration tests
	const StreamBuf = function(options) {
	  options = options || {};
	  this.bufSize = options.bufSize || 1024 * 1024;
	  this.buffers = [];

	  // batch mode fills a buffer completely before passing the data on
	  // to pipes or 'readable' event listeners
	  this.batch = options.batch || false;

	  this.corked = false;
	  // where in the current writable buffer we're up to
	  this.inPos = 0;

	  // where in the current readable buffer we've read up to
	  this.outPos = 0;

	  // consuming pipe streams go here
	  this.pipes = [];

	  // controls emit('data')
	  this.paused = false;

	  this.encoding = null;
	};

	utils_1.inherits(StreamBuf, readableBrowser.Duplex, {
	  toBuffer() {
	    switch (this.buffers.length) {
	      case 0:
	        return null;
	      case 1:
	        return this.buffers[0].toBuffer();
	      default:
	        return Buffer.concat(this.buffers.map(rwBuf => rwBuf.toBuffer()));
	    }
	  },

	  // writable
	  // event drain - if write returns false (which it won't), indicates when safe to write again.
	  // finish - end() has been called
	  // pipe(src) - pipe() has been called on readable
	  // unpipe(src) - unpipe() has been called on readable
	  // error - duh

	  _getWritableBuffer() {
	    if (this.buffers.length) {
	      const last = this.buffers[this.buffers.length - 1];
	      if (!last.full) {
	        return last;
	      }
	    }
	    const buf = new ReadWriteBuf(this.bufSize);
	    this.buffers.push(buf);
	    return buf;
	  },

	  async _pipe(chunk) {
	    const write = function(pipe) {
	      return new Promise(resolve => {
	        pipe.write(chunk.toBuffer(), () => {
	          resolve();
	        });
	      });
	    };
	    await Promise.all(this.pipes.map(write));
	  },
	  _writeToBuffers(chunk) {
	    let inPos = 0;
	    const inLen = chunk.length;
	    while (inPos < inLen) {
	      // find writable buffer
	      const buffer = this._getWritableBuffer();

	      // write some data
	      inPos += buffer.write(chunk, inPos, inLen - inPos);
	    }
	  },
	  async write(data, encoding, callback) {
	    if (encoding instanceof Function) {
	      callback = encoding;
	      encoding = 'utf8';
	    }
	    callback = callback || utils_1.nop;

	    // encapsulate data into a chunk
	    let chunk;
	    if (data instanceof stringBuf) {
	      chunk = new StringBufChunk(data);
	    } else if (data instanceof Buffer) {
	      chunk = new BufferChunk(data);
	    } else if (typeof data === 'string' || data instanceof String || data instanceof ArrayBuffer) {
	      chunk = new StringChunk(data, encoding);
	    } else {
	      throw new Error('Chunk must be one of type String, Buffer or StringBuf.');
	    }

	    // now, do something with the chunk
	    if (this.pipes.length) {
	      if (this.batch) {
	        this._writeToBuffers(chunk);
	        while (!this.corked && this.buffers.length > 1) {
	          this._pipe(this.buffers.shift());
	        }
	      } else if (!this.corked) {
	        await this._pipe(chunk);
	        callback();
	      } else {
	        this._writeToBuffers(chunk);
	        process.nextTick(callback);
	      }
	    } else {
	      if (!this.paused) {
	        this.emit('data', chunk.toBuffer());
	      }

	      this._writeToBuffers(chunk);
	      this.emit('readable');
	    }

	    return true;
	  },
	  cork() {
	    this.corked = true;
	  },
	  _flush(/* destination */) {
	    // if we have comsumers...
	    if (this.pipes.length) {
	      // and there's stuff not written
	      while (this.buffers.length) {
	        this._pipe(this.buffers.shift());
	      }
	    }
	  },
	  uncork() {
	    this.corked = false;
	    this._flush();
	  },
	  end(chunk, encoding, callback) {
	    const writeComplete = error => {
	      if (error) {
	        callback(error);
	      } else {
	        this._flush();
	        this.pipes.forEach(pipe => {
	          pipe.end();
	        });
	        this.emit('finish');
	      }
	    };
	    if (chunk) {
	      this.write(chunk, encoding, writeComplete);
	    } else {
	      writeComplete();
	    }
	  },

	  // readable
	  // event readable - some data is now available
	  // event data - switch to flowing mode - feeds chunks to handler
	  // event end - no more data
	  // event close - optional, indicates upstream close
	  // event error - duh
	  read(size) {
	    let buffers;
	    // read min(buffer, size || infinity)
	    if (size) {
	      buffers = [];
	      while (size && this.buffers.length && !this.buffers[0].eod) {
	        const first = this.buffers[0];
	        const buffer = first.read(size);
	        size -= buffer.length;
	        buffers.push(buffer);
	        if (first.eod && first.full) {
	          this.buffers.shift();
	        }
	      }
	      return Buffer.concat(buffers);
	    }

	    buffers = this.buffers.map(buf => buf.toBuffer()).filter(Boolean);
	    this.buffers = [];
	    return Buffer.concat(buffers);
	  },
	  setEncoding(encoding) {
	    // causes stream.read or stream.on('data) to return strings of encoding instead of Buffer objects
	    this.encoding = encoding;
	  },
	  pause() {
	    this.paused = true;
	  },
	  resume() {
	    this.paused = false;
	  },
	  isPaused() {
	    return !!this.paused;
	  },
	  pipe(destination) {
	    // add destination to pipe list & write current buffer
	    this.pipes.push(destination);
	    if (!this.paused && this.buffers.length) {
	      this.end();
	    }
	  },
	  unpipe(destination) {
	    // remove destination from pipe list
	    this.pipes = this.pipes.filter(pipe => pipe !== destination);
	  },
	  unshift(/* chunk */) {
	    // some numpty has read some data that's not for them and they want to put it back!
	    // Might implement this some day
	    throw new Error('Not Implemented');
	  },
	  wrap(/* stream */) {
	    // not implemented
	    throw new Error('Not Implemented');
	  },
	});

	var streamBuf = StreamBuf;

	// eslint-disable-next-line node/no-unsupported-features/node-builtins
	const textEncoder = typeof TextEncoder === 'undefined' ? null : new TextEncoder('utf-8');
	const {Buffer: Buffer$5} = buffer__default['default'];

	function stringToBuffer(str) {
	  if (typeof str !== 'string') {
	    return str;
	  }
	  if (textEncoder) {
	    return Buffer$5.from(textEncoder.encode(str).buffer);
	  }
	  return Buffer$5.from(str);
	}

	var stringToBuffer_1 = stringToBuffer;

	var browserBufferEncode = {
		stringToBuffer: stringToBuffer_1
	};

	const {stringToBuffer: stringToBuffer$1} = browserBufferEncode;

	// =============================================================================
	// The ZipWriter class
	// Packs streamed data into an output zip stream
	class ZipWriter extends events__default['default'].EventEmitter {
	  constructor(options) {
	    super();
	    this.options = Object.assign(
	      {
	        type: 'nodebuffer',
	        compression: 'DEFLATE',
	      },
	      options
	    );

	    this.zip = new jszip_min();
	    this.stream = new streamBuf();
	  }

	  append(data, options) {
	    if (options.hasOwnProperty('base64') && options.base64) {
	      this.zip.file(options.name, data, {base64: true});
	    } else {
	      // https://www.npmjs.com/package/process
	      if (process.browser && typeof data === 'string') {
	        // use TextEncoder in browser
	        data = stringToBuffer$1(data);
	      }
	      this.zip.file(options.name, data);
	    }
	  }

	  async finalize() {
	    const content = await this.zip.generateAsync(this.options);
	    this.stream.end(content);
	    this.emit('finish');
	  }

	  // ==========================================================================
	  // Stream.Readable interface
	  read(size) {
	    return this.stream.read(size);
	  }

	  setEncoding(encoding) {
	    return this.stream.setEncoding(encoding);
	  }

	  pause() {
	    return this.stream.pause();
	  }

	  resume() {
	    return this.stream.resume();
	  }

	  isPaused() {
	    return this.stream.isPaused();
	  }

	  pipe(destination, options) {
	    return this.stream.pipe(destination, options);
	  }

	  unpipe(destination) {
	    return this.stream.unpipe(destination);
	  }

	  unshift(chunk) {
	    return this.stream.unshift(chunk);
	  }

	  wrap(stream) {
	    return this.stream.wrap(stream);
	  }
	}

	// =============================================================================

	var zipStream = {
	  ZipWriter,
	};

	// constants
	const OPEN_ANGLE = '<';
	const CLOSE_ANGLE = '>';
	const OPEN_ANGLE_SLASH = '</';
	const CLOSE_SLASH_ANGLE = '/>';
	const EQUALS_QUOTE = '="';
	const QUOTE = '"';
	const SPACE = ' ';

	function pushAttribute(xml, name, value) {
	  xml.push(SPACE);
	  xml.push(name);
	  xml.push(EQUALS_QUOTE);
	  xml.push(utils_1.xmlEncode(value.toString()));
	  xml.push(QUOTE);
	}
	function pushAttributes(xml, attributes) {
	  if (attributes) {
	    underDash.each(attributes, (value, name) => {
	      if (value !== undefined) {
	        pushAttribute(xml, name, value);
	      }
	    });
	  }
	}

	class XmlStream {
	  constructor() {
	    this._xml = [];
	    this._stack = [];
	    this._rollbacks = [];
	  }

	  get tos() {
	    return this._stack.length ? this._stack[this._stack.length - 1] : undefined;
	  }

	  get cursor() {
	    // handy way to track whether anything has been added
	    return this._xml.length;
	  }

	  openXml(docAttributes) {
	    const xml = this._xml;
	    // <?xml version="1.0" encoding="UTF-8" standalone="yes"?>
	    xml.push('<?xml');
	    pushAttributes(xml, docAttributes);
	    xml.push('?>\n');
	  }

	  openNode(name, attributes) {
	    const parent = this.tos;
	    const xml = this._xml;
	    if (parent && this.open) {
	      xml.push(CLOSE_ANGLE);
	    }

	    this._stack.push(name);

	    // start streaming node
	    xml.push(OPEN_ANGLE);
	    xml.push(name);
	    pushAttributes(xml, attributes);
	    this.leaf = true;
	    this.open = true;
	  }

	  addAttribute(name, value) {
	    if (!this.open) {
	      throw new Error('Cannot write attributes to node if it is not open');
	    }
	    if (value !== undefined) {
	      pushAttribute(this._xml, name, value);
	    }
	  }

	  addAttributes(attrs) {
	    if (!this.open) {
	      throw new Error('Cannot write attributes to node if it is not open');
	    }
	    pushAttributes(this._xml, attrs);
	  }

	  writeText(text) {
	    const xml = this._xml;
	    if (this.open) {
	      xml.push(CLOSE_ANGLE);
	      this.open = false;
	    }
	    this.leaf = false;
	    xml.push(utils_1.xmlEncode(text.toString()));
	  }

	  writeXml(xml) {
	    if (this.open) {
	      this._xml.push(CLOSE_ANGLE);
	      this.open = false;
	    }
	    this.leaf = false;
	    this._xml.push(xml);
	  }

	  closeNode() {
	    const node = this._stack.pop();
	    const xml = this._xml;
	    if (this.leaf) {
	      xml.push(CLOSE_SLASH_ANGLE);
	    } else {
	      xml.push(OPEN_ANGLE_SLASH);
	      xml.push(node);
	      xml.push(CLOSE_ANGLE);
	    }
	    this.open = false;
	    this.leaf = false;
	  }

	  leafNode(name, attributes, text) {
	    this.openNode(name, attributes);
	    if (text !== undefined) {
	      // zeros need to be written
	      this.writeText(text);
	    }
	    this.closeNode();
	  }

	  closeAll() {
	    while (this._stack.length) {
	      this.closeNode();
	    }
	  }

	  addRollback() {
	    this._rollbacks.push({
	      xml: this._xml.length,
	      stack: this._stack.length,
	      leaf: this.leaf,
	      open: this.open,
	    });
	    return this.cursor;
	  }

	  commit() {
	    this._rollbacks.pop();
	  }

	  rollback() {
	    const r = this._rollbacks.pop();
	    if (this._xml.length > r.xml) {
	      this._xml.splice(r.xml, this._xml.length - r.xml);
	    }
	    if (this._stack.length > r.stack) {
	      this._stack.splice(r.stack, this._stack.length - r.stack);
	    }
	    this.leaf = r.leaf;
	    this.open = r.open;
	  }

	  get xml() {
	    this.closeAll();
	    return this._xml.join('');
	  }
	}

	XmlStream.StdDocAttributes = {
	  version: '1.0',
	  encoding: 'UTF-8',
	  standalone: 'yes',
	};

	var xmlStream = XmlStream;

	// eslint-disable-next-line node/no-unsupported-features/node-builtins
	const textDecoder = typeof TextDecoder === 'undefined' ? null : new TextDecoder('utf-8');

	function bufferToString(chunk) {
	  if (typeof chunk === 'string') {
	    return chunk;
	  }
	  if (textDecoder) {
	    return textDecoder.decode(chunk);
	  }
	  return chunk.toString();
	}

	var bufferToString_1 = bufferToString;

	var browserBufferDecode = {
		bufferToString: bufferToString_1
	};

	var ed5 = createCommonjsModule(function (module, exports) {
	/**
	 * Character classes and associated utilities for the 5th edition of XML 1.0.
	 *
	 * @author Louis-Dominique Dubeau
	 * @license MIT
	 * @copyright Louis-Dominique Dubeau
	 */
	Object.defineProperty(exports, "__esModule", { value: true });
	//
	// Fragments.
	//
	exports.CHAR = "\t\n\r -\uD7FF\uE000-\uFFFD\uD800\uDC00-\uDBFF\uDFFF";
	exports.S = " \t\r\n";
	// tslint:disable-next-line:max-line-length
	exports.NAME_START_CHAR = ":A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\uD800\uDC00-\uDB7F\uDFFF";
	exports.NAME_CHAR = "-" + exports.NAME_START_CHAR + ".0-9\u00B7\u0300-\u036F\u203F-\u2040";
	//
	// Regular expressions.
	//
	exports.CHAR_RE = new RegExp("^[" + exports.CHAR + "]$", "u");
	exports.S_RE = new RegExp("^[" + exports.S + "]+$", "u");
	exports.NAME_START_CHAR_RE = new RegExp("^[" + exports.NAME_START_CHAR + "]$", "u");
	exports.NAME_CHAR_RE = new RegExp("^[" + exports.NAME_CHAR + "]$", "u");
	exports.NAME_RE = new RegExp("^[" + exports.NAME_START_CHAR + "][" + exports.NAME_CHAR + "]*$", "u");
	exports.NMTOKEN_RE = new RegExp("^[" + exports.NAME_CHAR + "]+$", "u");
	var TAB = 9;
	var NL = 0xA;
	var CR = 0xD;
	var SPACE = 0x20;
	//
	// Lists.
	//
	/** All characters in the ``S`` production. */
	exports.S_LIST = [SPACE, NL, CR, TAB];
	/**
	 * Determines whether a codepoint matches the ``CHAR`` production.
	 *
	 * @param c The code point.
	 *
	 * @returns ``true`` if the codepoint matches ``CHAR``.
	 */
	function isChar(c) {
	    return (c >= SPACE && c <= 0xD7FF) ||
	        c === NL || c === CR || c === TAB ||
	        (c >= 0xE000 && c <= 0xFFFD) ||
	        (c >= 0x10000 && c <= 0x10FFFF);
	}
	exports.isChar = isChar;
	/**
	 * Determines whether a codepoint matches the ``S`` (space) production.
	 *
	 * @param c The code point.
	 *
	 * @returns ``true`` if the codepoint matches ``S``.
	 */
	function isS(c) {
	    return c === SPACE || c === NL || c === CR || c === TAB;
	}
	exports.isS = isS;
	/**
	 * Determines whether a codepoint matches the ``NAME_START_CHAR`` production.
	 *
	 * @param c The code point.
	 *
	 * @returns ``true`` if the codepoint matches ``NAME_START_CHAR``.
	 */
	function isNameStartChar(c) {
	    return ((c >= 0x41 && c <= 0x5A) ||
	        (c >= 0x61 && c <= 0x7A) ||
	        c === 0x3A ||
	        c === 0x5F ||
	        c === 0x200C ||
	        c === 0x200D ||
	        (c >= 0xC0 && c <= 0xD6) ||
	        (c >= 0xD8 && c <= 0xF6) ||
	        (c >= 0x00F8 && c <= 0x02FF) ||
	        (c >= 0x0370 && c <= 0x037D) ||
	        (c >= 0x037F && c <= 0x1FFF) ||
	        (c >= 0x2070 && c <= 0x218F) ||
	        (c >= 0x2C00 && c <= 0x2FEF) ||
	        (c >= 0x3001 && c <= 0xD7FF) ||
	        (c >= 0xF900 && c <= 0xFDCF) ||
	        (c >= 0xFDF0 && c <= 0xFFFD) ||
	        (c >= 0x10000 && c <= 0xEFFFF));
	}
	exports.isNameStartChar = isNameStartChar;
	/**
	 * Determines whether a codepoint matches the ``NAME_CHAR`` production.
	 *
	 * @param c The code point.
	 *
	 * @returns ``true`` if the codepoint matches ``NAME_CHAR``.
	 */
	function isNameChar(c) {
	    return isNameStartChar(c) ||
	        (c >= 0x30 && c <= 0x39) ||
	        c === 0x2D ||
	        c === 0x2E ||
	        c === 0xB7 ||
	        (c >= 0x0300 && c <= 0x036F) ||
	        (c >= 0x203F && c <= 0x2040);
	}
	exports.isNameChar = isNameChar;

	});

	unwrapExports(ed5);
	var ed5_1 = ed5.CHAR;
	var ed5_2 = ed5.S;
	var ed5_3 = ed5.NAME_START_CHAR;
	var ed5_4 = ed5.NAME_CHAR;
	var ed5_5 = ed5.CHAR_RE;
	var ed5_6 = ed5.S_RE;
	var ed5_7 = ed5.NAME_START_CHAR_RE;
	var ed5_8 = ed5.NAME_CHAR_RE;
	var ed5_9 = ed5.NAME_RE;
	var ed5_10 = ed5.NMTOKEN_RE;
	var ed5_11 = ed5.S_LIST;
	var ed5_12 = ed5.isChar;
	var ed5_13 = ed5.isS;
	var ed5_14 = ed5.isNameStartChar;
	var ed5_15 = ed5.isNameChar;

	var ed2 = createCommonjsModule(function (module, exports) {
	/**
	 * Character classes and associated utilities for the 2nd edition of XML 1.1.
	 *
	 * @author Louis-Dominique Dubeau
	 * @license MIT
	 * @copyright Louis-Dominique Dubeau
	 */
	Object.defineProperty(exports, "__esModule", { value: true });
	//
	// Fragments.
	//
	exports.CHAR = "\u0001-\uD7FF\uE000-\uFFFD\uD800\uDC00-\uDBFF\uDFFF";
	exports.RESTRICTED_CHAR = "\u0001-\u0008\u000B\u000C\u000E-\u001F\u007F-\u0084\u0086-\u009F";
	exports.S = " \t\r\n";
	// tslint:disable-next-line:max-line-length
	exports.NAME_START_CHAR = ":A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\uD800\uDC00-\uDB7F\uDFFF";
	exports.NAME_CHAR = "-" + exports.NAME_START_CHAR + ".0-9\u00B7\u0300-\u036F\u203F-\u2040";
	//
	// Regular expressions.
	//
	exports.CHAR_RE = new RegExp("^[" + exports.CHAR + "]$", "u");
	exports.RESTRICTED_CHAR_RE = new RegExp("^[" + exports.RESTRICTED_CHAR + "]$", "u");
	exports.S_RE = new RegExp("^[" + exports.S + "]+$", "u");
	exports.NAME_START_CHAR_RE = new RegExp("^[" + exports.NAME_START_CHAR + "]$", "u");
	exports.NAME_CHAR_RE = new RegExp("^[" + exports.NAME_CHAR + "]$", "u");
	exports.NAME_RE = new RegExp("^[" + exports.NAME_START_CHAR + "][" + exports.NAME_CHAR + "]*$", "u");
	exports.NMTOKEN_RE = new RegExp("^[" + exports.NAME_CHAR + "]+$", "u");
	var TAB = 9;
	var NL = 0xA;
	var CR = 0xD;
	var SPACE = 0x20;
	//
	// Lists.
	//
	/** All characters in the ``S`` production. */
	exports.S_LIST = [SPACE, NL, CR, TAB];
	/**
	 * Determines whether a codepoint matches the ``CHAR`` production.
	 *
	 * @param c The code point.
	 *
	 * @returns ``true`` if the codepoint matches ``CHAR``.
	 */
	function isChar(c) {
	    return (c >= 0x0001 && c <= 0xD7FF) ||
	        (c >= 0xE000 && c <= 0xFFFD) ||
	        (c >= 0x10000 && c <= 0x10FFFF);
	}
	exports.isChar = isChar;
	/**
	 * Determines whether a codepoint matches the ``RESTRICTED_CHAR`` production.
	 *
	 * @param c The code point.
	 *
	 * @returns ``true`` if the codepoint matches ``RESTRICTED_CHAR``.
	 */
	function isRestrictedChar(c) {
	    return (c >= 0x1 && c <= 0x8) ||
	        c === 0xB ||
	        c === 0xC ||
	        (c >= 0xE && c <= 0x1F) ||
	        (c >= 0x7F && c <= 0x84) ||
	        (c >= 0x86 && c <= 0x9F);
	}
	exports.isRestrictedChar = isRestrictedChar;
	/**
	 * Determines whether a codepoint matches the ``CHAR`` production and does not
	 * match the ``RESTRICTED_CHAR`` production. ``isCharAndNotRestricted(x)`` is
	 * equivalent to ``isChar(x) && !isRestrictedChar(x)``. This function is faster
	 * than running the two-call equivalent.
	 *
	 * @param c The code point.
	 *
	 * @returns ``true`` if the codepoint matches ``CHAR`` and does not match
	 * ``RESTRICTED_CHAR``.
	 */
	function isCharAndNotRestricted(c) {
	    return (c === 0x9) ||
	        (c === 0xA) ||
	        (c === 0xD) ||
	        (c > 0x1F && c < 0x7F) ||
	        (c === 0x85) ||
	        (c > 0x9F && c <= 0xD7FF) ||
	        (c >= 0xE000 && c <= 0xFFFD) ||
	        (c >= 0x10000 && c <= 0x10FFFF);
	}
	exports.isCharAndNotRestricted = isCharAndNotRestricted;
	/**
	 * Determines whether a codepoint matches the ``S`` (space) production.
	 *
	 * @param c The code point.
	 *
	 * @returns ``true`` if the codepoint matches ``S``.
	 */
	function isS(c) {
	    return c === SPACE || c === NL || c === CR || c === TAB;
	}
	exports.isS = isS;
	/**
	 * Determines whether a codepoint matches the ``NAME_START_CHAR`` production.
	 *
	 * @param c The code point.
	 *
	 * @returns ``true`` if the codepoint matches ``NAME_START_CHAR``.
	 */
	// tslint:disable-next-line:cyclomatic-complexity
	function isNameStartChar(c) {
	    return ((c >= 0x41 && c <= 0x5A) ||
	        (c >= 0x61 && c <= 0x7A) ||
	        c === 0x3A ||
	        c === 0x5F ||
	        c === 0x200C ||
	        c === 0x200D ||
	        (c >= 0xC0 && c <= 0xD6) ||
	        (c >= 0xD8 && c <= 0xF6) ||
	        (c >= 0x00F8 && c <= 0x02FF) ||
	        (c >= 0x0370 && c <= 0x037D) ||
	        (c >= 0x037F && c <= 0x1FFF) ||
	        (c >= 0x2070 && c <= 0x218F) ||
	        (c >= 0x2C00 && c <= 0x2FEF) ||
	        (c >= 0x3001 && c <= 0xD7FF) ||
	        (c >= 0xF900 && c <= 0xFDCF) ||
	        (c >= 0xFDF0 && c <= 0xFFFD) ||
	        (c >= 0x10000 && c <= 0xEFFFF));
	}
	exports.isNameStartChar = isNameStartChar;
	/**
	 * Determines whether a codepoint matches the ``NAME_CHAR`` production.
	 *
	 * @param c The code point.
	 *
	 * @returns ``true`` if the codepoint matches ``NAME_CHAR``.
	 */
	function isNameChar(c) {
	    return isNameStartChar(c) ||
	        (c >= 0x30 && c <= 0x39) ||
	        c === 0x2D ||
	        c === 0x2E ||
	        c === 0xB7 ||
	        (c >= 0x0300 && c <= 0x036F) ||
	        (c >= 0x203F && c <= 0x2040);
	}
	exports.isNameChar = isNameChar;

	});

	unwrapExports(ed2);
	var ed2_1 = ed2.CHAR;
	var ed2_2 = ed2.RESTRICTED_CHAR;
	var ed2_3 = ed2.S;
	var ed2_4 = ed2.NAME_START_CHAR;
	var ed2_5 = ed2.NAME_CHAR;
	var ed2_6 = ed2.CHAR_RE;
	var ed2_7 = ed2.RESTRICTED_CHAR_RE;
	var ed2_8 = ed2.S_RE;
	var ed2_9 = ed2.NAME_START_CHAR_RE;
	var ed2_10 = ed2.NAME_CHAR_RE;
	var ed2_11 = ed2.NAME_RE;
	var ed2_12 = ed2.NMTOKEN_RE;
	var ed2_13 = ed2.S_LIST;
	var ed2_14 = ed2.isChar;
	var ed2_15 = ed2.isRestrictedChar;
	var ed2_16 = ed2.isCharAndNotRestricted;
	var ed2_17 = ed2.isS;
	var ed2_18 = ed2.isNameStartChar;
	var ed2_19 = ed2.isNameChar;

	var ed3 = createCommonjsModule(function (module, exports) {
	/**
	 * Character class utilities for XML NS 1.0 edition 3.
	 *
	 * @author Louis-Dominique Dubeau
	 * @license MIT
	 * @copyright Louis-Dominique Dubeau
	 */
	Object.defineProperty(exports, "__esModule", { value: true });
	//
	// Fragments.
	//
	// tslint:disable-next-line:max-line-length
	exports.NC_NAME_START_CHAR = "A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\uD800\uDC00-\uDB7F\uDFFF";
	exports.NC_NAME_CHAR = "-" + exports.NC_NAME_START_CHAR + ".0-9\u00B7\u0300-\u036F\u203F-\u2040";
	//
	// Regular expressions.
	//
	exports.NC_NAME_START_CHAR_RE = new RegExp("^[" + exports.NC_NAME_START_CHAR + "]$", "u");
	exports.NC_NAME_CHAR_RE = new RegExp("^[" + exports.NC_NAME_CHAR + "]$", "u");
	exports.NC_NAME_RE = new RegExp("^[" + exports.NC_NAME_START_CHAR + "][" + exports.NC_NAME_CHAR + "]*$", "u");
	/**
	 * Determines whether a codepoint matches [[NC_NAME_START_CHAR]].
	 *
	 * @param c The code point.
	 *
	 * @returns ``true`` if the codepoint matches.
	 */
	// tslint:disable-next-line:cyclomatic-complexity
	function isNCNameStartChar(c) {
	    return ((c >= 0x41 && c <= 0x5A) ||
	        c === 0x5F ||
	        (c >= 0x61 && c <= 0x7A) ||
	        (c >= 0xC0 && c <= 0xD6) ||
	        (c >= 0xD8 && c <= 0xF6) ||
	        (c >= 0x00F8 && c <= 0x02FF) ||
	        (c >= 0x0370 && c <= 0x037D) ||
	        (c >= 0x037F && c <= 0x1FFF) ||
	        (c >= 0x200C && c <= 0x200D) ||
	        (c >= 0x2070 && c <= 0x218F) ||
	        (c >= 0x2C00 && c <= 0x2FEF) ||
	        (c >= 0x3001 && c <= 0xD7FF) ||
	        (c >= 0xF900 && c <= 0xFDCF) ||
	        (c >= 0xFDF0 && c <= 0xFFFD) ||
	        (c >= 0x10000 && c <= 0xEFFFF));
	}
	exports.isNCNameStartChar = isNCNameStartChar;
	/**
	 * Determines whether a codepoint matches [[NC_NAME_CHAR]].
	 *
	 * @param c The code point.
	 *
	 * @returns ``true`` if the codepoint matches.
	 */
	function isNCNameChar(c) {
	    return isNCNameStartChar(c) ||
	        (c === 0x2D ||
	            c === 0x2E ||
	            (c >= 0x30 && c <= 0x39) ||
	            c === 0x00B7 ||
	            (c >= 0x0300 && c <= 0x036F) ||
	            (c >= 0x203F && c <= 0x2040));
	}
	exports.isNCNameChar = isNCNameChar;

	});

	unwrapExports(ed3);
	var ed3_1 = ed3.NC_NAME_START_CHAR;
	var ed3_2 = ed3.NC_NAME_CHAR;
	var ed3_3 = ed3.NC_NAME_START_CHAR_RE;
	var ed3_4 = ed3.NC_NAME_CHAR_RE;
	var ed3_5 = ed3.NC_NAME_RE;
	var ed3_6 = ed3.isNCNameStartChar;
	var ed3_7 = ed3.isNCNameChar;

	var saxes = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });



	var isS = ed5.isS;
	var isChar10 = ed5.isChar;
	var isNameStartChar = ed5.isNameStartChar;
	var isNameChar = ed5.isNameChar;
	var S_LIST = ed5.S_LIST;
	var NAME_RE = ed5.NAME_RE;
	var isChar11 = ed2.isChar;
	var isNCNameStartChar = ed3.isNCNameStartChar;
	var isNCNameChar = ed3.isNCNameChar;
	var NC_NAME_RE = ed3.NC_NAME_RE;
	const XML_NAMESPACE = "http://www.w3.org/XML/1998/namespace";
	const XMLNS_NAMESPACE = "http://www.w3.org/2000/xmlns/";
	const rootNS = {
	    // eslint-disable-next-line @typescript-eslint/no-explicit-any
	    __proto__: null,
	    xml: XML_NAMESPACE,
	    xmlns: XMLNS_NAMESPACE,
	};
	const XML_ENTITIES = {
	    // eslint-disable-next-line @typescript-eslint/no-explicit-any
	    __proto__: null,
	    amp: "&",
	    gt: ">",
	    lt: "<",
	    quot: "\"",
	    apos: "'",
	};
	// EOC: end-of-chunk
	const EOC = -1;
	const NL_LIKE = -2;
	const S_BEGIN = 0; // Initial state.
	const S_BEGIN_WHITESPACE = 1; // leading whitespace
	const S_DOCTYPE = 2; // <!DOCTYPE
	const S_DOCTYPE_QUOTE = 3; // <!DOCTYPE "//blah
	const S_DTD = 4; // <!DOCTYPE "//blah" [ ...
	const S_DTD_QUOTED = 5; // <!DOCTYPE "//blah" [ "foo
	const S_DTD_OPEN_WAKA = 6;
	const S_DTD_OPEN_WAKA_BANG = 7;
	const S_DTD_COMMENT = 8; // <!--
	const S_DTD_COMMENT_ENDING = 9; // <!-- blah -
	const S_DTD_COMMENT_ENDED = 10; // <!-- blah --
	const S_DTD_PI = 11; // <?
	const S_DTD_PI_ENDING = 12; // <?hi "there" ?
	const S_TEXT = 13; // general stuff
	const S_ENTITY = 14; // &amp and such
	const S_OPEN_WAKA = 15; // <
	const S_OPEN_WAKA_BANG = 16; // <!...
	const S_COMMENT = 17; // <!--
	const S_COMMENT_ENDING = 18; // <!-- blah -
	const S_COMMENT_ENDED = 19; // <!-- blah --
	const S_CDATA = 20; // <![CDATA[ something
	const S_CDATA_ENDING = 21; // ]
	const S_CDATA_ENDING_2 = 22; // ]]
	const S_PI_FIRST_CHAR = 23; // <?hi, first char
	const S_PI_REST = 24; // <?hi, rest of the name
	const S_PI_BODY = 25; // <?hi there
	const S_PI_ENDING = 26; // <?hi "there" ?
	const S_XML_DECL_NAME_START = 27; // <?xml
	const S_XML_DECL_NAME = 28; // <?xml foo
	const S_XML_DECL_EQ = 29; // <?xml foo=
	const S_XML_DECL_VALUE_START = 30; // <?xml foo=
	const S_XML_DECL_VALUE = 31; // <?xml foo="bar"
	const S_XML_DECL_SEPARATOR = 32; // <?xml foo="bar"
	const S_XML_DECL_ENDING = 33; // <?xml ... ?
	const S_OPEN_TAG = 34; // <strong
	const S_OPEN_TAG_SLASH = 35; // <strong /
	const S_ATTRIB = 36; // <a
	const S_ATTRIB_NAME = 37; // <a foo
	const S_ATTRIB_NAME_SAW_WHITE = 38; // <a foo _
	const S_ATTRIB_VALUE = 39; // <a foo=
	const S_ATTRIB_VALUE_QUOTED = 40; // <a foo="bar
	const S_ATTRIB_VALUE_CLOSED = 41; // <a foo="bar"
	const S_ATTRIB_VALUE_UNQUOTED = 42; // <a foo=bar
	const S_CLOSE_TAG = 43; // </a
	const S_CLOSE_TAG_SAW_WHITE = 44; // </a   >
	const TAB = 9;
	const NL = 0xA;
	const CR = 0xD;
	const SPACE = 0x20;
	const BANG = 0x21;
	const DQUOTE = 0x22;
	const AMP = 0x26;
	const SQUOTE = 0x27;
	const MINUS = 0x2D;
	const FORWARD_SLASH = 0x2F;
	const SEMICOLON = 0x3B;
	const LESS = 0x3C;
	const EQUAL = 0x3D;
	const GREATER = 0x3E;
	const QUESTION = 0x3F;
	const OPEN_BRACKET = 0x5B;
	const CLOSE_BRACKET = 0x5D;
	const NEL = 0x85;
	const LS = 0x2028; // Line Separator
	const isQuote = (c) => c === DQUOTE || c === SQUOTE;
	const QUOTES = [DQUOTE, SQUOTE];
	const DOCTYPE_TERMINATOR = [...QUOTES, OPEN_BRACKET, GREATER];
	const DTD_TERMINATOR = [...QUOTES, LESS, CLOSE_BRACKET];
	const XML_DECL_NAME_TERMINATOR = [EQUAL, QUESTION, ...S_LIST];
	const ATTRIB_VALUE_UNQUOTED_TERMINATOR = [...S_LIST, GREATER, AMP, LESS];
	function nsPairCheck(parser, prefix, uri) {
	    switch (prefix) {
	        case "xml":
	            if (uri !== XML_NAMESPACE) {
	                parser.fail(`xml prefix must be bound to ${XML_NAMESPACE}.`);
	            }
	            break;
	        case "xmlns":
	            if (uri !== XMLNS_NAMESPACE) {
	                parser.fail(`xmlns prefix must be bound to ${XMLNS_NAMESPACE}.`);
	            }
	            break;
	    }
	    switch (uri) {
	        case XMLNS_NAMESPACE:
	            parser.fail(prefix === "" ?
	                `the default namespace may not be set to ${uri}.` :
	                `may not assign a prefix (even "xmlns") to the URI \
${XMLNS_NAMESPACE}.`);
	            break;
	        case XML_NAMESPACE:
	            switch (prefix) {
	                case "xml":
	                    // Assinging the XML namespace to "xml" is fine.
	                    break;
	                case "":
	                    parser.fail(`the default namespace may not be set to ${uri}.`);
	                    break;
	                default:
	                    parser.fail("may not assign the xml namespace to another prefix.");
	            }
	            break;
	    }
	}
	function nsMappingCheck(parser, mapping) {
	    for (const local of Object.keys(mapping)) {
	        nsPairCheck(parser, local, mapping[local]);
	    }
	}
	const isNCName = (name) => NC_NAME_RE.test(name);
	const isName = (name) => NAME_RE.test(name);
	const FORBIDDEN_START = 0;
	const FORBIDDEN_BRACKET = 1;
	const FORBIDDEN_BRACKET_BRACKET = 2;
	/**
	 * The list of supported events.
	 */
	exports.EVENTS = [
	    "xmldecl",
	    "text",
	    "processinginstruction",
	    "doctype",
	    "comment",
	    "opentagstart",
	    "attribute",
	    "opentag",
	    "closetag",
	    "cdata",
	    "error",
	    "end",
	    "ready",
	];
	const EVENT_NAME_TO_HANDLER_NAME = {
	    xmldecl: "xmldeclHandler",
	    text: "textHandler",
	    processinginstruction: "piHandler",
	    doctype: "doctypeHandler",
	    comment: "commentHandler",
	    opentagstart: "openTagStartHandler",
	    attribute: "attributeHandler",
	    opentag: "openTagHandler",
	    closetag: "closeTagHandler",
	    cdata: "cdataHandler",
	    error: "errorHandler",
	    end: "endHandler",
	    ready: "readyHandler",
	};
	class SaxesParser {
	    /**
	     * @param opt The parser options.
	     */
	    constructor(opt) {
	        this.opt = opt !== null && opt !== void 0 ? opt : {};
	        this.fragmentOpt = !!this.opt.fragment;
	        const xmlnsOpt = this.xmlnsOpt = !!this.opt.xmlns;
	        this.trackPosition = this.opt.position !== false;
	        this.fileName = this.opt.fileName;
	        if (xmlnsOpt) {
	            // This is the function we use to perform name checks on PIs and entities.
	            // When namespaces are used, colons are not allowed in PI target names or
	            // entity names. So the check depends on whether namespaces are used. See:
	            //
	            // https://www.w3.org/XML/xml-names-19990114-errata.html
	            // NE08
	            //
	            this.nameStartCheck = isNCNameStartChar;
	            this.nameCheck = isNCNameChar;
	            this.isName = isNCName;
	            // eslint-disable-next-line @typescript-eslint/unbound-method
	            this.processAttribs = this.processAttribsNS;
	            // eslint-disable-next-line @typescript-eslint/unbound-method
	            this.pushAttrib = this.pushAttribNS;
	            // eslint-disable-next-line @typescript-eslint/no-explicit-any
	            this.ns = Object.assign({ __proto__: null }, rootNS);
	            const additional = this.opt.additionalNamespaces;
	            if (additional != null) {
	                nsMappingCheck(this, additional);
	                Object.assign(this.ns, additional);
	            }
	        }
	        else {
	            this.nameStartCheck = isNameStartChar;
	            this.nameCheck = isNameChar;
	            this.isName = isName;
	            // eslint-disable-next-line @typescript-eslint/unbound-method
	            this.processAttribs = this.processAttribsPlain;
	            // eslint-disable-next-line @typescript-eslint/unbound-method
	            this.pushAttrib = this.pushAttribPlain;
	        }
	        //
	        // The order of the members in this table needs to correspond to the state
	        // numbers given to the states that correspond to the methods being recorded
	        // here.
	        //
	        this.stateTable = [
	            /* eslint-disable @typescript-eslint/unbound-method */
	            this.sBegin,
	            this.sBeginWhitespace,
	            this.sDoctype,
	            this.sDoctypeQuote,
	            this.sDTD,
	            this.sDTDQuoted,
	            this.sDTDOpenWaka,
	            this.sDTDOpenWakaBang,
	            this.sDTDComment,
	            this.sDTDCommentEnding,
	            this.sDTDCommentEnded,
	            this.sDTDPI,
	            this.sDTDPIEnding,
	            this.sText,
	            this.sEntity,
	            this.sOpenWaka,
	            this.sOpenWakaBang,
	            this.sComment,
	            this.sCommentEnding,
	            this.sCommentEnded,
	            this.sCData,
	            this.sCDataEnding,
	            this.sCDataEnding2,
	            this.sPIFirstChar,
	            this.sPIRest,
	            this.sPIBody,
	            this.sPIEnding,
	            this.sXMLDeclNameStart,
	            this.sXMLDeclName,
	            this.sXMLDeclEq,
	            this.sXMLDeclValueStart,
	            this.sXMLDeclValue,
	            this.sXMLDeclSeparator,
	            this.sXMLDeclEnding,
	            this.sOpenTag,
	            this.sOpenTagSlash,
	            this.sAttrib,
	            this.sAttribName,
	            this.sAttribNameSawWhite,
	            this.sAttribValue,
	            this.sAttribValueQuoted,
	            this.sAttribValueClosed,
	            this.sAttribValueUnquoted,
	            this.sCloseTag,
	            this.sCloseTagSawWhite,
	        ];
	        this._init();
	    }
	    /**
	     * Indicates whether or not the parser is closed. If ``true``, wait for
	     * the ``ready`` event to write again.
	     */
	    get closed() {
	        return this._closed;
	    }
	    _init() {
	        var _a;
	        this.openWakaBang = "";
	        this.text = "";
	        this.name = "";
	        this.piTarget = "";
	        this.entity = "";
	        this.q = null;
	        this.tags = [];
	        this.tag = null;
	        this.topNS = null;
	        this.chunk = "";
	        this.chunkPosition = 0;
	        this.i = 0;
	        this.prevI = 0;
	        this.carriedFromPrevious = undefined;
	        this.forbiddenState = FORBIDDEN_START;
	        this.attribList = [];
	        // The logic is organized so as to minimize the need to check
	        // this.opt.fragment while parsing.
	        const { fragmentOpt } = this;
	        this.state = fragmentOpt ? S_TEXT : S_BEGIN;
	        // We want these to be all true if we are dealing with a fragment.
	        this.reportedTextBeforeRoot = this.reportedTextAfterRoot = this.closedRoot =
	            this.sawRoot = fragmentOpt;
	        // An XML declaration is intially possible only when parsing whole
	        // documents.
	        this.xmlDeclPossible = !fragmentOpt;
	        this.xmlDeclExpects = ["version"];
	        this.entityReturnState = undefined;
	        let { defaultXMLVersion } = this.opt;
	        if (defaultXMLVersion === undefined) {
	            if (this.opt.forceXMLVersion === true) {
	                throw new Error("forceXMLVersion set but defaultXMLVersion is not set");
	            }
	            defaultXMLVersion = "1.0";
	        }
	        this.setXMLVersion(defaultXMLVersion);
	        this.positionAtNewLine = 0;
	        this.doctype = false;
	        this._closed = false;
	        this.xmlDecl = {
	            version: undefined,
	            encoding: undefined,
	            standalone: undefined,
	        };
	        this.line = 1;
	        this.column = 0;
	        this.ENTITIES = Object.create(XML_ENTITIES);
	        // eslint-disable-next-line no-unused-expressions
	        (_a = this.readyHandler) === null || _a === void 0 ? void 0 : _a.call(this);
	    }
	    /**
	     * The stream position the parser is currently looking at. This field is
	     * zero-based.
	     *
	     * This field is not based on counting Unicode characters but is to be
	     * interpreted as a plain index into a JavaScript string.
	     */
	    get position() {
	        return this.chunkPosition + this.i;
	    }
	    /**
	     * The column number of the next character to be read by the parser.  *
	     * This field is zero-based. (The first column in a line is 0.)
	     *
	     * This field reports the index at which the next character would be in the
	     * line if the line were represented as a JavaScript string.  Note that this
	     * *can* be different to a count based on the number of *Unicode characters*
	     * due to how JavaScript handles astral plane characters.
	     *
	     * See [[column]] for a number that corresponds to a count of Unicode
	     * characters.
	     */
	    get columnIndex() {
	        return this.position - this.positionAtNewLine;
	    }
	    /**
	     * Set an event listener on an event. The parser supports one handler per
	     * event type. If you try to set an event handler over an existing handler,
	     * the old handler is silently overwritten.
	     *
	     * @param name The event to listen to.
	     *
	     * @param handler The handler to set.
	     */
	    on(name, handler) {
	        // eslint-disable-next-line @typescript-eslint/no-explicit-any
	        this[EVENT_NAME_TO_HANDLER_NAME[name]] = handler;
	    }
	    /**
	     * Unset an event handler.
	     *
	     * @parma name The event to stop listening to.
	     */
	    off(name) {
	        // eslint-disable-next-line @typescript-eslint/no-explicit-any
	        this[EVENT_NAME_TO_HANDLER_NAME[name]] = undefined;
	    }
	    /**
	     * Make an error object. The error object will have a message that contains
	     * the ``fileName`` option passed at the creation of the parser. If position
	     * tracking was turned on, it will also have line and column number
	     * information.
	     *
	     * @param message The message describing the error to report.
	     *
	     * @returns An error object with a properly formatted message.
	     */
	    makeError(message) {
	        var _a;
	        let msg = (_a = this.fileName) !== null && _a !== void 0 ? _a : "";
	        if (this.trackPosition) {
	            if (msg.length > 0) {
	                msg += ":";
	            }
	            msg += `${this.line}:${this.column}`;
	        }
	        if (msg.length > 0) {
	            msg += ": ";
	        }
	        return new Error(msg + message);
	    }
	    /**
	     * Report a parsing error. This method is made public so that client code may
	     * check for issues that are outside the scope of this project and can report
	     * errors.
	     *
	     * @param message The error to report.
	     *
	     * @returns this
	     */
	    fail(message) {
	        const err = this.makeError(message);
	        const handler = this.errorHandler;
	        if (handler === undefined) {
	            throw err;
	        }
	        else {
	            handler(err);
	        }
	        return this;
	    }
	    /**
	     * Write a XML data to the parser.
	     *
	     * @param chunk The XML data to write.
	     *
	     * @returns this
	     */
	    write(chunk) {
	        if (this.closed) {
	            return this.fail("cannot write after close; assign an onready handler.");
	        }
	        let end = false;
	        if (chunk === null) {
	            // We cannot return immediately because carriedFromPrevious may need
	            // processing.
	            end = true;
	            chunk = "";
	        }
	        else if (typeof chunk === "object") {
	            chunk = chunk.toString();
	        }
	        // We checked if performing a pre-decomposition of the string into an array
	        // of single complete characters (``Array.from(chunk)``) would be faster
	        // than the current repeated calls to ``charCodeAt``. As of August 2018, it
	        // isn't. (There may be Node-specific code that would perform faster than
	        // ``Array.from`` but don't want to be dependent on Node.)
	        if (this.carriedFromPrevious !== undefined) {
	            // The previous chunk had char we must carry over.
	            chunk = `${this.carriedFromPrevious}${chunk}`;
	            this.carriedFromPrevious = undefined;
	        }
	        let limit = chunk.length;
	        const lastCode = chunk.charCodeAt(limit - 1);
	        if (!end &&
	            // A trailing CR or surrogate must be carried over to the next
	            // chunk.
	            (lastCode === CR || (lastCode >= 0xD800 && lastCode <= 0xDBFF))) {
	            // The chunk ends with a character that must be carried over. We cannot
	            // know how to handle it until we get the next chunk or the end of the
	            // stream. So save it for later.
	            this.carriedFromPrevious = chunk[limit - 1];
	            limit--;
	            chunk = chunk.slice(0, limit);
	        }
	        const { stateTable } = this;
	        this.chunk = chunk;
	        this.i = 0;
	        while (this.i < limit) {
	            // eslint-disable-next-line @typescript-eslint/no-explicit-any
	            stateTable[this.state].call(this);
	        }
	        this.chunkPosition += limit;
	        return end ? this.end() : this;
	    }
	    /**
	     * Close the current stream. Perform final well-formedness checks and reset
	     * the parser tstate.
	     *
	     * @returns this
	     */
	    close() {
	        return this.write(null);
	    }
	    /**
	     * Get a single code point out of the current chunk. This updates the current
	     * position if we do position tracking.
	     *
	     * This is the algorithm to use for XML 1.0.
	     *
	     * @returns The character read.
	     */
	    getCode10() {
	        const { chunk, i } = this;
	        this.prevI = i;
	        // Yes, we do this instead of doing this.i++. Doing it this way, we do not
	        // read this.i again, which is a bit faster.
	        this.i = i + 1;
	        if (i >= chunk.length) {
	            return EOC;
	        }
	        // Using charCodeAt and handling the surrogates ourselves is faster
	        // than using codePointAt.
	        const code = chunk.charCodeAt(i);
	        this.column++;
	        if (code < 0xD800) {
	            if (code >= SPACE || code === TAB) {
	                return code;
	            }
	            switch (code) {
	                case NL:
	                    this.line++;
	                    this.column = 0;
	                    this.positionAtNewLine = this.position;
	                    return NL;
	                case CR:
	                    // We may get NaN if we read past the end of the chunk, which is fine.
	                    if (chunk.charCodeAt(i + 1) === NL) {
	                        // A \r\n sequence is converted to \n so we have to skip over the
	                        // next character. We already know it has a size of 1 so ++ is fine
	                        // here.
	                        this.i = i + 2;
	                    }
	                    // Otherwise, a \r is just converted to \n, so we don't have to skip
	                    // ahead.
	                    // In either case, \r becomes \n.
	                    this.line++;
	                    this.column = 0;
	                    this.positionAtNewLine = this.position;
	                    return NL_LIKE;
	                default:
	                    // If we get here, then code < SPACE and it is not NL CR or TAB.
	                    this.fail("disallowed character.");
	                    return code;
	            }
	        }
	        if (code > 0xDBFF) {
	            // This is a specialized version of isChar10 that takes into account
	            // that in this context code > 0xDBFF and code <= 0xFFFF. So it does not
	            // test cases that don't need testing.
	            if (!(code >= 0xE000 && code <= 0xFFFD)) {
	                this.fail("disallowed character.");
	            }
	            return code;
	        }
	        const final = 0x10000 + ((code - 0xD800) * 0x400) +
	            (chunk.charCodeAt(i + 1) - 0xDC00);
	        this.i = i + 2;
	        // This is a specialized version of isChar10 that takes into account that in
	        // this context necessarily final >= 0x10000.
	        if (final > 0x10FFFF) {
	            this.fail("disallowed character.");
	        }
	        return final;
	    }
	    /**
	     * Get a single code point out of the current chunk. This updates the current
	     * position if we do position tracking.
	     *
	     * This is the algorithm to use for XML 1.1.
	     *
	     * @returns {number} The character read.
	     */
	    getCode11() {
	        const { chunk, i } = this;
	        this.prevI = i;
	        // Yes, we do this instead of doing this.i++. Doing it this way, we do not
	        // read this.i again, which is a bit faster.
	        this.i = i + 1;
	        if (i >= chunk.length) {
	            return EOC;
	        }
	        // Using charCodeAt and handling the surrogates ourselves is faster
	        // than using codePointAt.
	        const code = chunk.charCodeAt(i);
	        this.column++;
	        if (code < 0xD800) {
	            if ((code > 0x1F && code < 0x7F) || (code > 0x9F && code !== LS) ||
	                code === TAB) {
	                return code;
	            }
	            switch (code) {
	                case NL: // 0xA
	                    this.line++;
	                    this.column = 0;
	                    this.positionAtNewLine = this.position;
	                    return NL;
	                case CR: { // 0xD
	                    // We may get NaN if we read past the end of the chunk, which is
	                    // fine.
	                    const next = chunk.charCodeAt(i + 1);
	                    if (next === NL || next === NEL) {
	                        // A CR NL or CR NEL sequence is converted to NL so we have to skip
	                        // over the next character. We already know it has a size of 1.
	                        this.i = i + 2;
	                    }
	                    // Otherwise, a CR is just converted to NL, no skip.
	                }
	                /* yes, fall through */
	                case NEL: // 0x85
	                case LS: // Ox2028
	                    this.line++;
	                    this.column = 0;
	                    this.positionAtNewLine = this.position;
	                    return NL_LIKE;
	                default:
	                    this.fail("disallowed character.");
	                    return code;
	            }
	        }
	        if (code > 0xDBFF) {
	            // This is a specialized version of isCharAndNotRestricted that takes into
	            // account that in this context code > 0xDBFF and code <= 0xFFFF. So it
	            // does not test cases that don't need testing.
	            if (!(code >= 0xE000 && code <= 0xFFFD)) {
	                this.fail("disallowed character.");
	            }
	            return code;
	        }
	        const final = 0x10000 + ((code - 0xD800) * 0x400) +
	            (chunk.charCodeAt(i + 1) - 0xDC00);
	        this.i = i + 2;
	        // This is a specialized version of isCharAndNotRestricted that takes into
	        // account that in this context necessarily final >= 0x10000.
	        if (final > 0x10FFFF) {
	            this.fail("disallowed character.");
	        }
	        return final;
	    }
	    /**
	     * Like ``getCode`` but with the return value normalized so that ``NL`` is
	     * returned for ``NL_LIKE``.
	     */
	    getCodeNorm() {
	        const c = this.getCode();
	        return c === NL_LIKE ? NL : c;
	    }
	    unget() {
	        this.i = this.prevI;
	        this.column--;
	    }
	    /**
	     * Capture characters into a buffer until encountering one of a set of
	     * characters.
	     *
	     * @param chars An array of codepoints. Encountering a character in the array
	     * ends the capture. (``chars`` may safely contain ``NL``.)
	     *
	     * @return The character code that made the capture end, or ``EOC`` if we hit
	     * the end of the chunk. The return value cannot be NL_LIKE: NL is returned
	     * instead.
	     */
	    captureTo(chars) {
	        let { i: start } = this;
	        const { chunk } = this;
	        // eslint-disable-next-line no-constant-condition
	        while (true) {
	            const c = this.getCode();
	            const isNLLike = c === NL_LIKE;
	            const final = isNLLike ? NL : c;
	            if (final === EOC || chars.includes(final)) {
	                this.text += chunk.slice(start, this.prevI);
	                return final;
	            }
	            if (isNLLike) {
	                this.text += `${chunk.slice(start, this.prevI)}\n`;
	                start = this.i;
	            }
	        }
	    }
	    /**
	     * Capture characters into a buffer until encountering a character.
	     *
	     * @param char The codepoint that ends the capture. **NOTE ``char`` MAY NOT
	     * CONTAIN ``NL``.** Passing ``NL`` will result in buggy behavior.
	     *
	     * @return ``true`` if we ran into the character. Otherwise, we ran into the
	     * end of the current chunk.
	     */
	    captureToChar(char) {
	        let { i: start } = this;
	        const { chunk } = this;
	        // eslint-disable-next-line no-constant-condition
	        while (true) {
	            let c = this.getCode();
	            switch (c) {
	                case NL_LIKE:
	                    this.text += `${chunk.slice(start, this.prevI)}\n`;
	                    start = this.i;
	                    c = NL;
	                    break;
	                case EOC:
	                    this.text += chunk.slice(start);
	                    return false;
	            }
	            if (c === char) {
	                this.text += chunk.slice(start, this.prevI);
	                return true;
	            }
	        }
	    }
	    /**
	     * Capture characters that satisfy ``isNameChar`` into the ``name`` field of
	     * this parser.
	     *
	     * @return The character code that made the test fail, or ``EOC`` if we hit
	     * the end of the chunk. The return value cannot be NL_LIKE: NL is returned
	     * instead.
	     */
	    captureNameChars() {
	        const { chunk, i: start } = this;
	        // eslint-disable-next-line no-constant-condition
	        while (true) {
	            const c = this.getCode();
	            if (c === EOC) {
	                this.name += chunk.slice(start);
	                return EOC;
	            }
	            // NL is not a name char so we don't have to test specifically for it.
	            if (!isNameChar(c)) {
	                this.name += chunk.slice(start, this.prevI);
	                return c === NL_LIKE ? NL : c;
	            }
	        }
	    }
	    /**
	     * Skip white spaces.
	     *
	     * @return The character that ended the skip, or ``EOC`` if we hit
	     * the end of the chunk. The return value cannot be NL_LIKE: NL is returned
	     * instead.
	     */
	    skipSpaces() {
	        // eslint-disable-next-line no-constant-condition
	        while (true) {
	            const c = this.getCodeNorm();
	            if (c === EOC || !isS(c)) {
	                return c;
	            }
	        }
	    }
	    setXMLVersion(version) {
	        this.currentXMLVersion = version;
	        /*  eslint-disable @typescript-eslint/unbound-method */
	        if (version === "1.0") {
	            this.isChar = isChar10;
	            this.getCode = this.getCode10;
	        }
	        else {
	            this.isChar = isChar11;
	            this.getCode = this.getCode11;
	        }
	        /* eslint-enable @typescript-eslint/unbound-method */
	    }
	    // STATE ENGINE METHODS
	    // This needs to be a state separate from S_BEGIN_WHITESPACE because we want
	    // to be sure never to come back to this state later.
	    sBegin() {
	        // We are essentially peeking at the first character of the chunk. Since
	        // S_BEGIN can be in effect only when we start working on the first chunk,
	        // the index at which we must look is necessarily 0. Note also that the
	        // following test does not depend on decoding surrogates.
	        // If the initial character is 0xFEFF, ignore it.
	        if (this.chunk.charCodeAt(0) === 0xFEFF) {
	            this.i++;
	            this.column++;
	        }
	        this.state = S_BEGIN_WHITESPACE;
	    }
	    sBeginWhitespace() {
	        // We need to know whether we've encountered spaces or not because as soon
	        // as we run into a space, an XML declaration is no longer possible. Rather
	        // than slow down skipSpaces even in places where we don't care whether it
	        // skipped anything or not, we check whether prevI is equal to the value of
	        // i from before we skip spaces.
	        const iBefore = this.i;
	        const c = this.skipSpaces();
	        if (this.prevI !== iBefore) {
	            this.xmlDeclPossible = false;
	        }
	        switch (c) {
	            case LESS:
	                this.state = S_OPEN_WAKA;
	                // We could naively call closeText but in this state, it is not normal
	                // to have text be filled with any data.
	                if (this.text.length !== 0) {
	                    throw new Error("no-empty text at start");
	                }
	                break;
	            case EOC:
	                break;
	            default:
	                this.unget();
	                this.state = S_TEXT;
	                this.xmlDeclPossible = false;
	        }
	    }
	    sDoctype() {
	        var _a;
	        const c = this.captureTo(DOCTYPE_TERMINATOR);
	        switch (c) {
	            case GREATER: {
	                // eslint-disable-next-line no-unused-expressions
	                (_a = this.doctypeHandler) === null || _a === void 0 ? void 0 : _a.call(this, this.text);
	                this.text = "";
	                this.state = S_TEXT;
	                this.doctype = true; // just remember that we saw it.
	                break;
	            }
	            case EOC:
	                break;
	            default:
	                this.text += String.fromCodePoint(c);
	                if (c === OPEN_BRACKET) {
	                    this.state = S_DTD;
	                }
	                else if (isQuote(c)) {
	                    this.state = S_DOCTYPE_QUOTE;
	                    this.q = c;
	                }
	        }
	    }
	    sDoctypeQuote() {
	        const q = this.q;
	        if (this.captureToChar(q)) {
	            this.text += String.fromCodePoint(q);
	            this.q = null;
	            this.state = S_DOCTYPE;
	        }
	    }
	    sDTD() {
	        const c = this.captureTo(DTD_TERMINATOR);
	        if (c === EOC) {
	            return;
	        }
	        this.text += String.fromCodePoint(c);
	        if (c === CLOSE_BRACKET) {
	            this.state = S_DOCTYPE;
	        }
	        else if (c === LESS) {
	            this.state = S_DTD_OPEN_WAKA;
	        }
	        else if (isQuote(c)) {
	            this.state = S_DTD_QUOTED;
	            this.q = c;
	        }
	    }
	    sDTDQuoted() {
	        const q = this.q;
	        if (this.captureToChar(q)) {
	            this.text += String.fromCodePoint(q);
	            this.state = S_DTD;
	            this.q = null;
	        }
	    }
	    sDTDOpenWaka() {
	        const c = this.getCodeNorm();
	        this.text += String.fromCodePoint(c);
	        switch (c) {
	            case BANG:
	                this.state = S_DTD_OPEN_WAKA_BANG;
	                this.openWakaBang = "";
	                break;
	            case QUESTION:
	                this.state = S_DTD_PI;
	                break;
	            default:
	                this.state = S_DTD;
	        }
	    }
	    sDTDOpenWakaBang() {
	        const char = String.fromCodePoint(this.getCodeNorm());
	        const owb = this.openWakaBang += char;
	        this.text += char;
	        if (owb !== "-") {
	            this.state = owb === "--" ? S_DTD_COMMENT : S_DTD;
	            this.openWakaBang = "";
	        }
	    }
	    sDTDComment() {
	        if (this.captureToChar(MINUS)) {
	            this.text += "-";
	            this.state = S_DTD_COMMENT_ENDING;
	        }
	    }
	    sDTDCommentEnding() {
	        const c = this.getCodeNorm();
	        this.text += String.fromCodePoint(c);
	        this.state = c === MINUS ? S_DTD_COMMENT_ENDED : S_DTD_COMMENT;
	    }
	    sDTDCommentEnded() {
	        const c = this.getCodeNorm();
	        this.text += String.fromCodePoint(c);
	        if (c === GREATER) {
	            this.state = S_DTD;
	        }
	        else {
	            this.fail("malformed comment.");
	            // <!-- blah -- bloo --> will be recorded as
	            // a comment of " blah -- bloo "
	            this.state = S_DTD_COMMENT;
	        }
	    }
	    sDTDPI() {
	        if (this.captureToChar(QUESTION)) {
	            this.text += "?";
	            this.state = S_DTD_PI_ENDING;
	        }
	    }
	    sDTDPIEnding() {
	        const c = this.getCodeNorm();
	        this.text += String.fromCodePoint(c);
	        if (c === GREATER) {
	            this.state = S_DTD;
	        }
	    }
	    sText() {
	        //
	        // We did try a version of saxes where the S_TEXT state was split in two
	        // states: one for text inside the root element, and one for text
	        // outside. This was avoiding having to test this.tags.length to decide
	        // what implementation to actually use.
	        //
	        // Peformance testing on gigabyte-size files did not show any advantage to
	        // using the two states solution instead of the current one. Conversely, it
	        // made the code a bit more complicated elsewhere. For instance, a comment
	        // can appear before the root element so when a comment ended it was
	        // necessary to determine whether to return to the S_TEXT state or to the
	        // new text-outside-root state.
	        //
	        if (this.tags.length !== 0) {
	            this.handleTextInRoot();
	        }
	        else {
	            this.handleTextOutsideRoot();
	        }
	    }
	    sEntity() {
	        // This is essentially a specialized version of captureToChar(SEMICOLON...)
	        let { i: start } = this;
	        const { chunk } = this;
	        // eslint-disable-next-line no-labels, no-restricted-syntax
	        loop: 
	        // eslint-disable-next-line no-constant-condition
	        while (true) {
	            switch (this.getCode()) {
	                case NL_LIKE:
	                    this.entity += `${chunk.slice(start, this.prevI)}\n`;
	                    start = this.i;
	                    break;
	                case SEMICOLON: {
	                    const { entityReturnState } = this;
	                    const entity = this.entity + chunk.slice(start, this.prevI);
	                    this.state = entityReturnState;
	                    let parsed;
	                    if (entity === "") {
	                        this.fail("empty entity name.");
	                        parsed = "&;";
	                    }
	                    else {
	                        parsed = this.parseEntity(entity);
	                        this.entity = "";
	                    }
	                    if (entityReturnState !== S_TEXT || this.textHandler !== undefined) {
	                        this.text += parsed;
	                    }
	                    // eslint-disable-next-line no-labels
	                    break loop;
	                }
	                case EOC:
	                    this.entity += chunk.slice(start);
	                    // eslint-disable-next-line no-labels
	                    break loop;
	            }
	        }
	    }
	    sOpenWaka() {
	        // Reminder: a state handler is called with at least one character
	        // available in the current chunk. So the first call to get code inside of
	        // a state handler cannot return ``EOC``. That's why we don't test
	        // for it.
	        const c = this.getCode();
	        // either a /, ?, !, or text is coming next.
	        if (isNameStartChar(c)) {
	            this.state = S_OPEN_TAG;
	            this.unget();
	            this.xmlDeclPossible = false;
	        }
	        else {
	            switch (c) {
	                case FORWARD_SLASH:
	                    this.state = S_CLOSE_TAG;
	                    this.xmlDeclPossible = false;
	                    break;
	                case BANG:
	                    this.state = S_OPEN_WAKA_BANG;
	                    this.openWakaBang = "";
	                    this.xmlDeclPossible = false;
	                    break;
	                case QUESTION:
	                    this.state = S_PI_FIRST_CHAR;
	                    break;
	                default:
	                    this.fail("disallowed character in tag name");
	                    this.state = S_TEXT;
	                    this.xmlDeclPossible = false;
	            }
	        }
	    }
	    sOpenWakaBang() {
	        this.openWakaBang += String.fromCodePoint(this.getCodeNorm());
	        switch (this.openWakaBang) {
	            case "[CDATA[":
	                if (!this.sawRoot && !this.reportedTextBeforeRoot) {
	                    this.fail("text data outside of root node.");
	                    this.reportedTextBeforeRoot = true;
	                }
	                if (this.closedRoot && !this.reportedTextAfterRoot) {
	                    this.fail("text data outside of root node.");
	                    this.reportedTextAfterRoot = true;
	                }
	                this.state = S_CDATA;
	                this.openWakaBang = "";
	                break;
	            case "--":
	                this.state = S_COMMENT;
	                this.openWakaBang = "";
	                break;
	            case "DOCTYPE":
	                this.state = S_DOCTYPE;
	                if (this.doctype || this.sawRoot) {
	                    this.fail("inappropriately located doctype declaration.");
	                }
	                this.openWakaBang = "";
	                break;
	            default:
	                // 7 happens to be the maximum length of the string that can possibly
	                // match one of the cases above.
	                if (this.openWakaBang.length >= 7) {
	                    this.fail("incorrect syntax.");
	                }
	        }
	    }
	    sComment() {
	        if (this.captureToChar(MINUS)) {
	            this.state = S_COMMENT_ENDING;
	        }
	    }
	    sCommentEnding() {
	        var _a;
	        const c = this.getCodeNorm();
	        if (c === MINUS) {
	            this.state = S_COMMENT_ENDED;
	            // eslint-disable-next-line no-unused-expressions
	            (_a = this.commentHandler) === null || _a === void 0 ? void 0 : _a.call(this, this.text);
	            this.text = "";
	        }
	        else {
	            this.text += `-${String.fromCodePoint(c)}`;
	            this.state = S_COMMENT;
	        }
	    }
	    sCommentEnded() {
	        const c = this.getCodeNorm();
	        if (c !== GREATER) {
	            this.fail("malformed comment.");
	            // <!-- blah -- bloo --> will be recorded as
	            // a comment of " blah -- bloo "
	            this.text += `--${String.fromCodePoint(c)}`;
	            this.state = S_COMMENT;
	        }
	        else {
	            this.state = S_TEXT;
	        }
	    }
	    sCData() {
	        if (this.captureToChar(CLOSE_BRACKET)) {
	            this.state = S_CDATA_ENDING;
	        }
	    }
	    sCDataEnding() {
	        const c = this.getCodeNorm();
	        if (c === CLOSE_BRACKET) {
	            this.state = S_CDATA_ENDING_2;
	        }
	        else {
	            this.text += `]${String.fromCodePoint(c)}`;
	            this.state = S_CDATA;
	        }
	    }
	    sCDataEnding2() {
	        var _a;
	        const c = this.getCodeNorm();
	        switch (c) {
	            case GREATER: {
	                // eslint-disable-next-line no-unused-expressions
	                (_a = this.cdataHandler) === null || _a === void 0 ? void 0 : _a.call(this, this.text);
	                this.text = "";
	                this.state = S_TEXT;
	                break;
	            }
	            case CLOSE_BRACKET:
	                this.text += "]";
	                break;
	            default:
	                this.text += `]]${String.fromCodePoint(c)}`;
	                this.state = S_CDATA;
	        }
	    }
	    // We need this separate state to check the first character fo the pi target
	    // with this.nameStartCheck which allows less characters than this.nameCheck.
	    sPIFirstChar() {
	        const c = this.getCodeNorm();
	        // This is first because in the case where the file is well-formed this is
	        // the branch taken. We optimize for well-formedness.
	        if (this.nameStartCheck(c)) {
	            this.piTarget += String.fromCodePoint(c);
	            this.state = S_PI_REST;
	        }
	        else if (c === QUESTION || isS(c)) {
	            this.fail("processing instruction without a target.");
	            this.state = c === QUESTION ? S_PI_ENDING : S_PI_BODY;
	        }
	        else {
	            this.fail("disallowed character in processing instruction name.");
	            this.piTarget += String.fromCodePoint(c);
	            this.state = S_PI_REST;
	        }
	    }
	    sPIRest() {
	        // Capture characters into a piTarget while ``this.nameCheck`` run on the
	        // character read returns true.
	        const { chunk, i: start } = this;
	        // eslint-disable-next-line no-constant-condition
	        while (true) {
	            const c = this.getCodeNorm();
	            if (c === EOC) {
	                this.piTarget += chunk.slice(start);
	                return;
	            }
	            // NL cannot satisfy this.nameCheck so we don't have to test specifically
	            // for it.
	            if (!this.nameCheck(c)) {
	                this.piTarget += chunk.slice(start, this.prevI);
	                const isQuestion = c === QUESTION;
	                if (isQuestion || isS(c)) {
	                    if (this.piTarget === "xml") {
	                        if (!this.xmlDeclPossible) {
	                            this.fail("an XML declaration must be at the start of the document.");
	                        }
	                        this.state = isQuestion ? S_XML_DECL_ENDING : S_XML_DECL_NAME_START;
	                    }
	                    else {
	                        this.state = isQuestion ? S_PI_ENDING : S_PI_BODY;
	                    }
	                }
	                else {
	                    this.fail("disallowed character in processing instruction name.");
	                    this.piTarget += String.fromCodePoint(c);
	                }
	                break;
	            }
	        }
	    }
	    sPIBody() {
	        if (this.text.length === 0) {
	            const c = this.getCodeNorm();
	            if (c === QUESTION) {
	                this.state = S_PI_ENDING;
	            }
	            else if (!isS(c)) {
	                this.text = String.fromCodePoint(c);
	            }
	        }
	        // The question mark character is not valid inside any of the XML
	        // declaration name/value pairs.
	        else if (this.captureToChar(QUESTION)) {
	            this.state = S_PI_ENDING;
	        }
	    }
	    sPIEnding() {
	        var _a;
	        const c = this.getCodeNorm();
	        if (c === GREATER) {
	            const { piTarget } = this;
	            if (piTarget.toLowerCase() === "xml") {
	                this.fail("the XML declaration must appear at the start of the document.");
	            }
	            // eslint-disable-next-line no-unused-expressions
	            (_a = this.piHandler) === null || _a === void 0 ? void 0 : _a.call(this, {
	                target: piTarget,
	                body: this.text,
	            });
	            this.piTarget = this.text = "";
	            this.state = S_TEXT;
	        }
	        else if (c === QUESTION) {
	            // We ran into ?? as part of a processing instruction. We initially took
	            // the first ? as a sign that the PI was ending, but it is not. So we have
	            // to add it to the body but we take the new ? as a sign that the PI is
	            // ending.
	            this.text += "?";
	        }
	        else {
	            this.text += `?${String.fromCodePoint(c)}`;
	            this.state = S_PI_BODY;
	        }
	        this.xmlDeclPossible = false;
	    }
	    sXMLDeclNameStart() {
	        const c = this.skipSpaces();
	        // The question mark character is not valid inside any of the XML
	        // declaration name/value pairs.
	        if (c === QUESTION) {
	            // It is valid to go to S_XML_DECL_ENDING from this state.
	            this.state = S_XML_DECL_ENDING;
	            return;
	        }
	        if (c !== EOC) {
	            this.state = S_XML_DECL_NAME;
	            this.name = String.fromCodePoint(c);
	        }
	    }
	    sXMLDeclName() {
	        const c = this.captureTo(XML_DECL_NAME_TERMINATOR);
	        // The question mark character is not valid inside any of the XML
	        // declaration name/value pairs.
	        if (c === QUESTION) {
	            this.state = S_XML_DECL_ENDING;
	            this.name += this.text;
	            this.text = "";
	            this.fail("XML declaration is incomplete.");
	            return;
	        }
	        if (!(isS(c) || c === EQUAL)) {
	            return;
	        }
	        this.name += this.text;
	        this.text = "";
	        if (!this.xmlDeclExpects.includes(this.name)) {
	            switch (this.name.length) {
	                case 0:
	                    this.fail("did not expect any more name/value pairs.");
	                    break;
	                case 1:
	                    this.fail(`expected the name ${this.xmlDeclExpects[0]}.`);
	                    break;
	                default:
	                    this.fail(`expected one of ${this.xmlDeclExpects.join(", ")}`);
	            }
	        }
	        this.state = c === EQUAL ? S_XML_DECL_VALUE_START : S_XML_DECL_EQ;
	    }
	    sXMLDeclEq() {
	        const c = this.getCodeNorm();
	        // The question mark character is not valid inside any of the XML
	        // declaration name/value pairs.
	        if (c === QUESTION) {
	            this.state = S_XML_DECL_ENDING;
	            this.fail("XML declaration is incomplete.");
	            return;
	        }
	        if (isS(c)) {
	            return;
	        }
	        if (c !== EQUAL) {
	            this.fail("value required.");
	        }
	        this.state = S_XML_DECL_VALUE_START;
	    }
	    sXMLDeclValueStart() {
	        const c = this.getCodeNorm();
	        // The question mark character is not valid inside any of the XML
	        // declaration name/value pairs.
	        if (c === QUESTION) {
	            this.state = S_XML_DECL_ENDING;
	            this.fail("XML declaration is incomplete.");
	            return;
	        }
	        if (isS(c)) {
	            return;
	        }
	        if (!isQuote(c)) {
	            this.fail("value must be quoted.");
	            this.q = SPACE;
	        }
	        else {
	            this.q = c;
	        }
	        this.state = S_XML_DECL_VALUE;
	    }
	    sXMLDeclValue() {
	        const c = this.captureTo([this.q, QUESTION]);
	        // The question mark character is not valid inside any of the XML
	        // declaration name/value pairs.
	        if (c === QUESTION) {
	            this.state = S_XML_DECL_ENDING;
	            this.text = "";
	            this.fail("XML declaration is incomplete.");
	            return;
	        }
	        if (c === EOC) {
	            return;
	        }
	        const value = this.text;
	        this.text = "";
	        switch (this.name) {
	            case "version": {
	                this.xmlDeclExpects = ["encoding", "standalone"];
	                const version = value;
	                this.xmlDecl.version = version;
	                // This is the test specified by XML 1.0 but it is fine for XML 1.1.
	                if (!/^1\.[0-9]+$/.test(version)) {
	                    this.fail("version number must match /^1\\.[0-9]+$/.");
	                }
	                // When forceXMLVersion is set, the XML declaration is ignored.
	                else if (!this.opt.forceXMLVersion) {
	                    this.setXMLVersion(version);
	                }
	                break;
	            }
	            case "encoding":
	                if (!/^[A-Za-z][A-Za-z0-9._-]*$/.test(value)) {
	                    this.fail("encoding value must match \
/^[A-Za-z0-9][A-Za-z0-9._-]*$/.");
	                }
	                this.xmlDeclExpects = ["standalone"];
	                this.xmlDecl.encoding = value;
	                break;
	            case "standalone":
	                if (value !== "yes" && value !== "no") {
	                    this.fail("standalone value must match \"yes\" or \"no\".");
	                }
	                this.xmlDeclExpects = [];
	                this.xmlDecl.standalone = value;
	                break;
	            // We don't need to raise an error here since we've already raised one
	            // when checking what name was expected.
	        }
	        this.name = "";
	        this.state = S_XML_DECL_SEPARATOR;
	    }
	    sXMLDeclSeparator() {
	        const c = this.getCodeNorm();
	        // The question mark character is not valid inside any of the XML
	        // declaration name/value pairs.
	        if (c === QUESTION) {
	            // It is valid to go to S_XML_DECL_ENDING from this state.
	            this.state = S_XML_DECL_ENDING;
	            return;
	        }
	        if (!isS(c)) {
	            this.fail("whitespace required.");
	            this.unget();
	        }
	        this.state = S_XML_DECL_NAME_START;
	    }
	    sXMLDeclEnding() {
	        var _a;
	        const c = this.getCodeNorm();
	        if (c === GREATER) {
	            if (this.piTarget !== "xml") {
	                this.fail("processing instructions are not allowed before root.");
	            }
	            else if (this.name !== "version" &&
	                this.xmlDeclExpects.includes("version")) {
	                this.fail("XML declaration must contain a version.");
	            }
	            // eslint-disable-next-line no-unused-expressions
	            (_a = this.xmldeclHandler) === null || _a === void 0 ? void 0 : _a.call(this, this.xmlDecl);
	            this.name = "";
	            this.piTarget = this.text = "";
	            this.state = S_TEXT;
	        }
	        else {
	            // We got here because the previous character was a ?, but the question
	            // mark character is not valid inside any of the XML declaration
	            // name/value pairs.
	            this.fail("The character ? is disallowed anywhere in XML declarations.");
	        }
	        this.xmlDeclPossible = false;
	    }
	    sOpenTag() {
	        var _a;
	        const c = this.captureNameChars();
	        if (c === EOC) {
	            return;
	        }
	        const tag = this.tag = {
	            name: this.name,
	            attributes: Object.create(null),
	        };
	        this.name = "";
	        if (this.xmlnsOpt) {
	            this.topNS = tag.ns = Object.create(null);
	        }
	        // eslint-disable-next-line no-unused-expressions
	        (_a = this.openTagStartHandler) === null || _a === void 0 ? void 0 : _a.call(this, tag);
	        this.sawRoot = true;
	        if (!this.fragmentOpt && this.closedRoot) {
	            this.fail("documents may contain only one root.");
	        }
	        switch (c) {
	            case GREATER:
	                this.openTag();
	                break;
	            case FORWARD_SLASH:
	                this.state = S_OPEN_TAG_SLASH;
	                break;
	            default:
	                if (!isS(c)) {
	                    this.fail("disallowed character in tag name.");
	                }
	                this.state = S_ATTRIB;
	        }
	    }
	    sOpenTagSlash() {
	        if (this.getCode() === GREATER) {
	            this.openSelfClosingTag();
	        }
	        else {
	            this.fail("forward-slash in opening tag not followed by >.");
	            this.state = S_ATTRIB;
	        }
	    }
	    sAttrib() {
	        const c = this.skipSpaces();
	        if (c === EOC) {
	            return;
	        }
	        if (isNameStartChar(c)) {
	            this.unget();
	            this.state = S_ATTRIB_NAME;
	        }
	        else if (c === GREATER) {
	            this.openTag();
	        }
	        else if (c === FORWARD_SLASH) {
	            this.state = S_OPEN_TAG_SLASH;
	        }
	        else {
	            this.fail("disallowed character in attribute name.");
	        }
	    }
	    sAttribName() {
	        const c = this.captureNameChars();
	        if (c === EQUAL) {
	            this.state = S_ATTRIB_VALUE;
	        }
	        else if (isS(c)) {
	            this.state = S_ATTRIB_NAME_SAW_WHITE;
	        }
	        else if (c === GREATER) {
	            this.fail("attribute without value.");
	            this.pushAttrib(this.name, this.name);
	            this.name = this.text = "";
	            this.openTag();
	        }
	        else if (c !== EOC) {
	            this.fail("disallowed character in attribute name.");
	        }
	    }
	    sAttribNameSawWhite() {
	        const c = this.skipSpaces();
	        switch (c) {
	            case EOC:
	                return;
	            case EQUAL:
	                this.state = S_ATTRIB_VALUE;
	                break;
	            default:
	                this.fail("attribute without value.");
	                // Should we do this???
	                // this.tag.attributes[this.name] = "";
	                this.text = "";
	                this.name = "";
	                if (c === GREATER) {
	                    this.openTag();
	                }
	                else if (isNameStartChar(c)) {
	                    this.unget();
	                    this.state = S_ATTRIB_NAME;
	                }
	                else {
	                    this.fail("disallowed character in attribute name.");
	                    this.state = S_ATTRIB;
	                }
	        }
	    }
	    sAttribValue() {
	        const c = this.getCodeNorm();
	        if (isQuote(c)) {
	            this.q = c;
	            this.state = S_ATTRIB_VALUE_QUOTED;
	        }
	        else if (!isS(c)) {
	            this.fail("unquoted attribute value.");
	            this.state = S_ATTRIB_VALUE_UNQUOTED;
	            this.unget();
	        }
	    }
	    sAttribValueQuoted() {
	        // We deliberately do not use captureTo here. The specialized code we use
	        // here is faster than using captureTo.
	        const { q, chunk } = this;
	        let { i: start } = this;
	        // eslint-disable-next-line no-constant-condition
	        while (true) {
	            switch (this.getCode()) {
	                case q:
	                    this.pushAttrib(this.name, this.text + chunk.slice(start, this.prevI));
	                    this.name = this.text = "";
	                    this.q = null;
	                    this.state = S_ATTRIB_VALUE_CLOSED;
	                    return;
	                case AMP:
	                    this.text += chunk.slice(start, this.prevI);
	                    this.state = S_ENTITY;
	                    this.entityReturnState = S_ATTRIB_VALUE_QUOTED;
	                    return;
	                case NL:
	                case NL_LIKE:
	                case TAB:
	                    this.text += `${chunk.slice(start, this.prevI)} `;
	                    start = this.i;
	                    break;
	                case LESS:
	                    this.text += chunk.slice(start, this.prevI);
	                    this.fail("disallowed character.");
	                    return;
	                case EOC:
	                    this.text += chunk.slice(start);
	                    return;
	            }
	        }
	    }
	    sAttribValueClosed() {
	        const c = this.getCodeNorm();
	        if (isS(c)) {
	            this.state = S_ATTRIB;
	        }
	        else if (c === GREATER) {
	            this.openTag();
	        }
	        else if (c === FORWARD_SLASH) {
	            this.state = S_OPEN_TAG_SLASH;
	        }
	        else if (isNameStartChar(c)) {
	            this.fail("no whitespace between attributes.");
	            this.unget();
	            this.state = S_ATTRIB_NAME;
	        }
	        else {
	            this.fail("disallowed character in attribute name.");
	        }
	    }
	    sAttribValueUnquoted() {
	        // We don't do anything regarding EOL or space handling for unquoted
	        // attributes. We already have failed by the time we get here, and the
	        // contract that saxes upholds states that upon failure, it is not safe to
	        // rely on the data passed to event handlers (other than
	        // ``onerror``). Passing "bad" data is not a problem.
	        const c = this.captureTo(ATTRIB_VALUE_UNQUOTED_TERMINATOR);
	        switch (c) {
	            case AMP:
	                this.state = S_ENTITY;
	                this.entityReturnState = S_ATTRIB_VALUE_UNQUOTED;
	                break;
	            case LESS:
	                this.fail("disallowed character.");
	                break;
	            case EOC:
	                break;
	            default:
	                if (this.text.includes("]]>")) {
	                    this.fail("the string \"]]>\" is disallowed in char data.");
	                }
	                this.pushAttrib(this.name, this.text);
	                this.name = this.text = "";
	                if (c === GREATER) {
	                    this.openTag();
	                }
	                else {
	                    this.state = S_ATTRIB;
	                }
	        }
	    }
	    sCloseTag() {
	        const c = this.captureNameChars();
	        if (c === GREATER) {
	            this.closeTag();
	        }
	        else if (isS(c)) {
	            this.state = S_CLOSE_TAG_SAW_WHITE;
	        }
	        else if (c !== EOC) {
	            this.fail("disallowed character in closing tag.");
	        }
	    }
	    sCloseTagSawWhite() {
	        switch (this.skipSpaces()) {
	            case GREATER:
	                this.closeTag();
	                break;
	            case EOC:
	                break;
	            default:
	                this.fail("disallowed character in closing tag.");
	        }
	    }
	    // END OF STATE ENGINE METHODS
	    handleTextInRoot() {
	        // This is essentially a specialized version of captureTo which is optimized
	        // for performing the ]]> check. A previous version of this code, checked
	        // ``this.text`` for the presence of ]]>. It simplified the code but was
	        // very costly when character data contained a lot of entities to be parsed.
	        //
	        // Since we are using a specialized loop, we also keep track of the presence
	        // of ]]> in text data. The sequence ]]> is forbidden to appear as-is.
	        //
	        let { i: start, forbiddenState } = this;
	        const { chunk, textHandler: handler } = this;
	        // eslint-disable-next-line no-labels, no-restricted-syntax
	        scanLoop: 
	        // eslint-disable-next-line no-constant-condition
	        while (true) {
	            switch (this.getCode()) {
	                case LESS: {
	                    this.state = S_OPEN_WAKA;
	                    if (handler !== undefined) {
	                        const { text } = this;
	                        const slice = chunk.slice(start, this.prevI);
	                        if (text.length !== 0) {
	                            handler(text + slice);
	                            this.text = "";
	                        }
	                        else if (slice.length !== 0) {
	                            handler(slice);
	                        }
	                    }
	                    forbiddenState = FORBIDDEN_START;
	                    // eslint-disable-next-line no-labels
	                    break scanLoop;
	                }
	                case AMP:
	                    this.state = S_ENTITY;
	                    this.entityReturnState = S_TEXT;
	                    if (handler !== undefined) {
	                        this.text += chunk.slice(start, this.prevI);
	                    }
	                    forbiddenState = FORBIDDEN_START;
	                    // eslint-disable-next-line no-labels
	                    break scanLoop;
	                case CLOSE_BRACKET:
	                    switch (forbiddenState) {
	                        case FORBIDDEN_START:
	                            forbiddenState = FORBIDDEN_BRACKET;
	                            break;
	                        case FORBIDDEN_BRACKET:
	                            forbiddenState = FORBIDDEN_BRACKET_BRACKET;
	                            break;
	                        case FORBIDDEN_BRACKET_BRACKET:
	                            break;
	                        default:
	                            throw new Error("impossible state");
	                    }
	                    break;
	                case GREATER:
	                    if (forbiddenState === FORBIDDEN_BRACKET_BRACKET) {
	                        this.fail("the string \"]]>\" is disallowed in char data.");
	                    }
	                    forbiddenState = FORBIDDEN_START;
	                    break;
	                case NL_LIKE:
	                    if (handler !== undefined) {
	                        this.text += `${chunk.slice(start, this.prevI)}\n`;
	                    }
	                    start = this.i;
	                    forbiddenState = FORBIDDEN_START;
	                    break;
	                case EOC:
	                    if (handler !== undefined) {
	                        this.text += chunk.slice(start);
	                    }
	                    // eslint-disable-next-line no-labels
	                    break scanLoop;
	                default:
	                    forbiddenState = FORBIDDEN_START;
	            }
	        }
	        this.forbiddenState = forbiddenState;
	    }
	    handleTextOutsideRoot() {
	        // This is essentially a specialized version of captureTo which is optimized
	        // for a specialized task. We keep track of the presence of non-space
	        // characters in the text since these are errors when appearing outside the
	        // document root element.
	        let { i: start } = this;
	        const { chunk, textHandler: handler } = this;
	        let nonSpace = false;
	        // eslint-disable-next-line no-labels, no-restricted-syntax
	        outRootLoop: 
	        // eslint-disable-next-line no-constant-condition
	        while (true) {
	            const code = this.getCode();
	            switch (code) {
	                case LESS: {
	                    this.state = S_OPEN_WAKA;
	                    if (handler !== undefined) {
	                        const { text } = this;
	                        const slice = chunk.slice(start, this.prevI);
	                        if (text.length !== 0) {
	                            handler(text + slice);
	                            this.text = "";
	                        }
	                        else if (slice.length !== 0) {
	                            handler(slice);
	                        }
	                    }
	                    // eslint-disable-next-line no-labels
	                    break outRootLoop;
	                }
	                case AMP:
	                    this.state = S_ENTITY;
	                    this.entityReturnState = S_TEXT;
	                    if (handler !== undefined) {
	                        this.text += chunk.slice(start, this.prevI);
	                    }
	                    nonSpace = true;
	                    // eslint-disable-next-line no-labels
	                    break outRootLoop;
	                case NL_LIKE:
	                    if (handler !== undefined) {
	                        this.text += `${chunk.slice(start, this.prevI)}\n`;
	                    }
	                    start = this.i;
	                    break;
	                case EOC:
	                    if (handler !== undefined) {
	                        this.text += chunk.slice(start);
	                    }
	                    // eslint-disable-next-line no-labels
	                    break outRootLoop;
	                default:
	                    if (!isS(code)) {
	                        nonSpace = true;
	                    }
	            }
	        }
	        if (!nonSpace) {
	            return;
	        }
	        // We use the reportedTextBeforeRoot and reportedTextAfterRoot flags
	        // to avoid reporting errors for every single character that is out of
	        // place.
	        if (!this.sawRoot && !this.reportedTextBeforeRoot) {
	            this.fail("text data outside of root node.");
	            this.reportedTextBeforeRoot = true;
	        }
	        if (this.closedRoot && !this.reportedTextAfterRoot) {
	            this.fail("text data outside of root node.");
	            this.reportedTextAfterRoot = true;
	        }
	    }
	    pushAttribNS(name, value) {
	        var _a;
	        const { prefix, local } = this.qname(name);
	        const attr = { name, prefix, local, value };
	        this.attribList.push(attr);
	        // eslint-disable-next-line no-unused-expressions
	        (_a = this.attributeHandler) === null || _a === void 0 ? void 0 : _a.call(this, attr);
	        if (prefix === "xmlns") {
	            const trimmed = value.trim();
	            if (this.currentXMLVersion === "1.0" && trimmed === "") {
	                this.fail("invalid attempt to undefine prefix in XML 1.0");
	            }
	            this.topNS[local] = trimmed;
	            nsPairCheck(this, local, trimmed);
	        }
	        else if (name === "xmlns") {
	            const trimmed = value.trim();
	            this.topNS[""] = trimmed;
	            nsPairCheck(this, "", trimmed);
	        }
	    }
	    pushAttribPlain(name, value) {
	        var _a;
	        const attr = { name, value };
	        this.attribList.push(attr);
	        // eslint-disable-next-line no-unused-expressions
	        (_a = this.attributeHandler) === null || _a === void 0 ? void 0 : _a.call(this, attr);
	    }
	    /**
	     * End parsing. This performs final well-formedness checks and resets the
	     * parser to a clean state.
	     *
	     * @returns this
	     */
	    end() {
	        var _a, _b;
	        if (!this.sawRoot) {
	            this.fail("document must contain a root element.");
	        }
	        const { tags } = this;
	        while (tags.length > 0) {
	            const tag = tags.pop();
	            this.fail(`unclosed tag: ${tag.name}`);
	        }
	        if ((this.state !== S_BEGIN) && (this.state !== S_TEXT)) {
	            this.fail("unexpected end.");
	        }
	        const { text } = this;
	        if (text.length !== 0) {
	            // eslint-disable-next-line no-unused-expressions
	            (_a = this.textHandler) === null || _a === void 0 ? void 0 : _a.call(this, text);
	            this.text = "";
	        }
	        this._closed = true;
	        // eslint-disable-next-line no-unused-expressions
	        (_b = this.endHandler) === null || _b === void 0 ? void 0 : _b.call(this);
	        this._init();
	        return this;
	    }
	    /**
	     * Resolve a namespace prefix.
	     *
	     * @param prefix The prefix to resolve.
	     *
	     * @returns The namespace URI or ``undefined`` if the prefix is not defined.
	     */
	    resolve(prefix) {
	        var _a, _b;
	        let uri = this.topNS[prefix];
	        if (uri !== undefined) {
	            return uri;
	        }
	        const { tags } = this;
	        for (let index = tags.length - 1; index >= 0; index--) {
	            uri = tags[index].ns[prefix];
	            if (uri !== undefined) {
	                return uri;
	            }
	        }
	        uri = this.ns[prefix];
	        if (uri !== undefined) {
	            return uri;
	        }
	        return (_b = (_a = this.opt).resolvePrefix) === null || _b === void 0 ? void 0 : _b.call(_a, prefix);
	    }
	    /**
	     * Parse a qname into its prefix and local name parts.
	     *
	     * @param name The name to parse
	     *
	     * @returns
	     */
	    qname(name) {
	        // This is faster than using name.split(":").
	        const colon = name.indexOf(":");
	        if (colon === -1) {
	            return { prefix: "", local: name };
	        }
	        const local = name.slice(colon + 1);
	        const prefix = name.slice(0, colon);
	        if (prefix === "" || local === "" || local.includes(":")) {
	            this.fail(`malformed name: ${name}.`);
	        }
	        return { prefix, local };
	    }
	    processAttribsNS() {
	        var _a;
	        const { attribList } = this;
	        const tag = this.tag;
	        {
	            // add namespace info to tag
	            const { prefix, local } = this.qname(tag.name);
	            tag.prefix = prefix;
	            tag.local = local;
	            const uri = tag.uri = (_a = this.resolve(prefix)) !== null && _a !== void 0 ? _a : "";
	            if (prefix !== "") {
	                if (prefix === "xmlns") {
	                    this.fail("tags may not have \"xmlns\" as prefix.");
	                }
	                if (uri === "") {
	                    this.fail(`unbound namespace prefix: ${JSON.stringify(prefix)}.`);
	                    tag.uri = prefix;
	                }
	            }
	        }
	        if (attribList.length === 0) {
	            return;
	        }
	        const { attributes } = tag;
	        const seen = new Set();
	        // Note: do not apply default ns to attributes:
	        //   http://www.w3.org/TR/REC-xml-names/#defaulting
	        for (const attr of attribList) {
	            const { name, prefix, local } = attr;
	            let uri;
	            let eqname;
	            if (prefix === "") {
	                uri = name === "xmlns" ? XMLNS_NAMESPACE : "";
	                eqname = name;
	            }
	            else {
	                uri = this.resolve(prefix);
	                // if there's any attributes with an undefined namespace,
	                // then fail on them now.
	                if (uri === undefined) {
	                    this.fail(`unbound namespace prefix: ${JSON.stringify(prefix)}.`);
	                    uri = prefix;
	                }
	                eqname = `{${uri}}${local}`;
	            }
	            if (seen.has(eqname)) {
	                this.fail(`duplicate attribute: ${eqname}.`);
	            }
	            seen.add(eqname);
	            attr.uri = uri;
	            attributes[name] = attr;
	        }
	        this.attribList = [];
	    }
	    processAttribsPlain() {
	        const { attribList } = this;
	        // eslint-disable-next-line prefer-destructuring
	        const attributes = this.tag.attributes;
	        for (const { name, value } of attribList) {
	            if (attributes[name] !== undefined) {
	                this.fail(`duplicate attribute: ${name}.`);
	            }
	            attributes[name] = value;
	        }
	        this.attribList = [];
	    }
	    /**
	     * Handle a complete open tag. This parser code calls this once it has seen
	     * the whole tag. This method checks for well-formeness and then emits
	     * ``onopentag``.
	     */
	    openTag() {
	        var _a;
	        this.processAttribs();
	        const { tags } = this;
	        const tag = this.tag;
	        tag.isSelfClosing = false;
	        // There cannot be any pending text here due to the onopentagstart that was
	        // necessarily emitted before we get here. So we do not check text.
	        // eslint-disable-next-line no-unused-expressions
	        (_a = this.openTagHandler) === null || _a === void 0 ? void 0 : _a.call(this, tag);
	        tags.push(tag);
	        this.state = S_TEXT;
	        this.name = "";
	    }
	    /**
	     * Handle a complete self-closing tag. This parser code calls this once it has
	     * seen the whole tag. This method checks for well-formeness and then emits
	     * ``onopentag`` and ``onclosetag``.
	     */
	    openSelfClosingTag() {
	        var _a, _b, _c;
	        this.processAttribs();
	        const { tags } = this;
	        const tag = this.tag;
	        tag.isSelfClosing = true;
	        // There cannot be any pending text here due to the onopentagstart that was
	        // necessarily emitted before we get here. So we do not check text.
	        // eslint-disable-next-line no-unused-expressions
	        (_a = this.openTagHandler) === null || _a === void 0 ? void 0 : _a.call(this, tag);
	        // eslint-disable-next-line no-unused-expressions
	        (_b = this.closeTagHandler) === null || _b === void 0 ? void 0 : _b.call(this, tag);
	        const top = this.tag = (_c = tags[tags.length - 1]) !== null && _c !== void 0 ? _c : null;
	        if (top === null) {
	            this.closedRoot = true;
	        }
	        this.state = S_TEXT;
	        this.name = "";
	    }
	    /**
	     * Handle a complete close tag. This parser code calls this once it has seen
	     * the whole tag. This method checks for well-formeness and then emits
	     * ``onclosetag``.
	     */
	    closeTag() {
	        const { tags, name } = this;
	        // Our state after this will be S_TEXT, no matter what, and we can clear
	        // tagName now.
	        this.state = S_TEXT;
	        this.name = "";
	        if (name === "") {
	            this.fail("weird empty close tag.");
	            this.text += "</>";
	            return;
	        }
	        const handler = this.closeTagHandler;
	        let l = tags.length;
	        while (l-- > 0) {
	            const tag = this.tag = tags.pop();
	            this.topNS = tag.ns;
	            // eslint-disable-next-line no-unused-expressions
	            handler === null || handler === void 0 ? void 0 : handler(tag);
	            if (tag.name === name) {
	                break;
	            }
	            this.fail("unexpected close tag.");
	        }
	        if (l === 0) {
	            this.closedRoot = true;
	        }
	        else if (l < 0) {
	            this.fail(`unmatched closing tag: ${name}.`);
	            this.text += `</${name}>`;
	        }
	    }
	    /**
	     * Resolves an entity. Makes any necessary well-formedness checks.
	     *
	     * @param entity The entity to resolve.
	     *
	     * @returns The parsed entity.
	     */
	    parseEntity(entity) {
	        // startsWith would be significantly slower for this test.
	        // eslint-disable-next-line @typescript-eslint/prefer-string-starts-ends-with
	        if (entity[0] !== "#") {
	            const defined = this.ENTITIES[entity];
	            if (defined !== undefined) {
	                return defined;
	            }
	            this.fail(this.isName(entity) ? "undefined entity." :
	                "disallowed character in entity name.");
	            return `&${entity};`;
	        }
	        let num = NaN;
	        if (entity[1] === "x" && /^#x[0-9a-f]+$/i.test(entity)) {
	            num = parseInt(entity.slice(2), 16);
	        }
	        else if (/^#[0-9]+$/.test(entity)) {
	            num = parseInt(entity.slice(1), 10);
	        }
	        // The character reference is required to match the CHAR production.
	        if (!this.isChar(num)) {
	            this.fail("malformed character entity.");
	            return `&${entity};`;
	        }
	        return String.fromCodePoint(num);
	    }
	}
	exports.SaxesParser = SaxesParser;

	});

	unwrapExports(saxes);
	var saxes_1 = saxes.EVENTS;
	var saxes_2 = saxes.SaxesParser;

	const {SaxesParser} = saxes;
	const {PassThrough: PassThrough$1} = readableBrowser;
	const {bufferToString: bufferToString$1} = browserBufferDecode;

	var parseSax = async function* (iterable) {
	  // TODO: Remove once node v8 is deprecated
	  // Detect and upgrade old streams
	  if (iterable.pipe && !iterable[Symbol.asyncIterator]) {
	    iterable = iterable.pipe(new PassThrough$1());
	  }
	  const saxesParser = new SaxesParser();
	  let error;
	  saxesParser.on('error', err => {
	    error = err;
	  });
	  let events = [];
	  saxesParser.on('opentag', value => events.push({eventType: 'opentag', value}));
	  saxesParser.on('text', value => events.push({eventType: 'text', value}));
	  saxesParser.on('closetag', value => events.push({eventType: 'closetag', value}));
	  for await (const chunk of iterable) {
	    saxesParser.write(bufferToString$1(chunk));
	    // saxesParser.write and saxesParser.on() are synchronous,
	    // so we can only reach the below line once all events have been emitted
	    if (error) throw error;
	    // As a performance optimization, we gather all events instead of passing
	    // them one by one, which would cause each event to go through the event queue
	    yield events;
	    events = [];
	  }
	};

	/* 'virtual' methods used as a form of documentation */
	/* eslint-disable class-methods-use-this */

	// Base class for Xforms
	class BaseXform {
	  // constructor(/* model, name */) {}

	  // ============================================================
	  // Virtual Interface
	  prepare(/* model, options */) {
	    // optional preparation (mutation) of model so it is ready for write
	  }

	  render(/* xmlStream, model */) {
	    // convert model to xml
	  }

	  parseOpen(node) {
	    // XML node opened
	  }

	  parseText(text) {
	    // chunk of text encountered for current node
	  }

	  parseClose(name) {
	    // XML node closed
	  }

	  reconcile(model, options) {
	    // optional post-parse step (opposite to prepare)
	  }

	  // ============================================================
	  reset() {
	    // to make sure parses don't bleed to next iteration
	    this.model = null;

	    // if we have a map - reset them too
	    if (this.map) {
	      Object.values(this.map).forEach(xform => {
	        if (xform instanceof BaseXform) {
	          xform.reset();
	        } else if (xform.xform) {
	          xform.xform.reset();
	        }
	      });
	    }
	  }

	  mergeModel(obj) {
	    // set obj's props to this.model
	    this.model = Object.assign(this.model || {}, obj);
	  }

	  async parse(saxParser) {
	    for await (const events of saxParser) {
	      for (const {eventType, value} of events) {
	        if (eventType === 'opentag') {
	          this.parseOpen(value);
	        } else if (eventType === 'text') {
	          this.parseText(value);
	        } else if (eventType === 'closetag') {
	          if (!this.parseClose(value.name)) {
	            return this.model;
	          }
	        }
	      }
	    }
	    return this.model;
	  }

	  async parseStream(stream) {
	    return this.parse(parseSax(stream));
	  }

	  get xml() {
	    // convenience function to get the xml of this.model
	    // useful for manager types that are built during the prepare phase
	    return this.toXml(this.model);
	  }

	  toXml(model) {
	    const xmlStream$1 = new xmlStream();
	    this.render(xmlStream$1, model);
	    return xmlStream$1.xml;
	  }

	  // ============================================================
	  // Useful Utilities
	  static toAttribute(value, dflt, always = false) {
	    if (value === undefined) {
	      if (always) {
	        return dflt;
	      }
	    } else if (always || value !== dflt) {
	      return value.toString();
	    }
	    return undefined;
	  }

	  static toStringAttribute(value, dflt, always = false) {
	    return BaseXform.toAttribute(value, dflt, always);
	  }

	  static toStringValue(attr, dflt) {
	    return attr === undefined ? dflt : attr;
	  }

	  static toBoolAttribute(value, dflt, always = false) {
	    if (value === undefined) {
	      if (always) {
	        return dflt;
	      }
	    } else if (always || value !== dflt) {
	      return value ? '1' : '0';
	    }
	    return undefined;
	  }

	  static toBoolValue(attr, dflt) {
	    return attr === undefined ? dflt : attr === '1';
	  }

	  static toIntAttribute(value, dflt, always = false) {
	    return BaseXform.toAttribute(value, dflt, always);
	  }

	  static toIntValue(attr, dflt) {
	    return attr === undefined ? dflt : parseInt(attr, 10);
	  }

	  static toFloatAttribute(value, dflt, always = false) {
	    return BaseXform.toAttribute(value, dflt, always);
	  }

	  static toFloatValue(attr, dflt) {
	    return attr === undefined ? dflt : parseFloat(attr);
	  }
	}

	var baseXform = BaseXform;

	// const model = {
	//   tag: 'name',
	//   $: {attr: 'value'},
	//   c: [
	//     { tag: 'child' }
	//   ],
	//   t: 'some text'
	// };

	function build(xmlStream, model) {
	  xmlStream.openNode(model.tag, model.$);
	  if (model.c) {
	    model.c.forEach(child => {
	      build(xmlStream, child);
	    });
	  }
	  if (model.t) {
	    xmlStream.writeText(model.t);
	  }
	  xmlStream.closeNode();
	}

	class StaticXform extends baseXform {
	  constructor(model) {
	    super();

	    // This class is an optimisation for static (unimportant and unchanging) xml
	    // It is stateless - apart from its static model and so can be used as a singleton
	    // Being stateless - it will only track entry to and exit from it's root xml tag during parsing and nothing else
	    // Known issues:
	    //    since stateless - parseOpen always returns true. Parent xform must know when to start using this xform
	    //    if the root tag is recursive, the parsing will behave unpredictably
	    this._model = model;
	  }

	  render(xmlStream$1) {
	    if (!this._xml) {
	      const stream = new xmlStream();
	      build(stream, this._model);
	      this._xml = stream.xml;
	    }
	    xmlStream$1.writeXml(this._xml);
	  }

	  parseOpen() {
	    return true;
	  }

	  parseText() {}

	  parseClose(name) {
	    switch (name) {
	      case this._model.tag:
	        return false;
	      default:
	        return true;
	    }
	  }
	}

	var staticXform = StaticXform;

	class ListXform extends baseXform {
	  constructor(options) {
	    super();

	    this.tag = options.tag;
	    this.always = !!options.always;
	    this.count = options.count;
	    this.empty = options.empty;
	    this.$count = options.$count || 'count';
	    this.$ = options.$;
	    this.childXform = options.childXform;
	    this.maxItems = options.maxItems;
	  }

	  prepare(model, options) {
	    const {childXform} = this;
	    if (model) {
	      model.forEach((childModel, index) => {
	        options.index = index;
	        childXform.prepare(childModel, options);
	      });
	    }
	  }

	  render(xmlStream, model) {
	    if (this.always || (model && model.length)) {
	      xmlStream.openNode(this.tag, this.$);
	      if (this.count) {
	        xmlStream.addAttribute(this.$count, (model && model.length) || 0);
	      }

	      const {childXform} = this;
	      (model || []).forEach((childModel, index) => {
	        childXform.render(xmlStream, childModel, index);
	      });

	      xmlStream.closeNode();
	    } else if (this.empty) {
	      xmlStream.leafNode(this.tag);
	    }
	  }

	  parseOpen(node) {
	    if (this.parser) {
	      this.parser.parseOpen(node);
	      return true;
	    }
	    switch (node.name) {
	      case this.tag:
	        this.model = [];
	        return true;
	      default:
	        if (this.childXform.parseOpen(node)) {
	          this.parser = this.childXform;
	          return true;
	        }
	        return false;
	    }
	  }

	  parseText(text) {
	    if (this.parser) {
	      this.parser.parseText(text);
	    }
	  }

	  parseClose(name) {
	    if (this.parser) {
	      if (!this.parser.parseClose(name)) {
	        this.model.push(this.parser.model);
	        this.parser = undefined;

	        if (this.maxItems && this.model.length > this.maxItems) {
	          throw new Error(`Max ${this.childXform.tag} count (${this.maxItems}) exceeded`);
	        }
	      }
	      return true;
	    }

	    return false;
	  }

	  reconcile(model, options) {
	    if (model) {
	      const {childXform} = this;
	      model.forEach(childModel => {
	        childXform.reconcile(childModel, options);
	      });
	    }
	  }
	}

	var listXform = ListXform;

	// Color encapsulates translation from color model to/from xlsx
	class ColorXform extends baseXform {
	  constructor(name) {
	    super();

	    // this.name controls the xm node name
	    this.name = name || 'color';
	  }

	  get tag() {
	    return this.name;
	  }

	  render(xmlStream, model) {
	    if (model) {
	      xmlStream.openNode(this.name);
	      if (model.argb) {
	        xmlStream.addAttribute('rgb', model.argb);
	      } else if (model.theme !== undefined) {
	        xmlStream.addAttribute('theme', model.theme);
	        if (model.tint !== undefined) {
	          xmlStream.addAttribute('tint', model.tint);
	        }
	      } else if (model.indexed !== undefined) {
	        xmlStream.addAttribute('indexed', model.indexed);
	      } else {
	        xmlStream.addAttribute('auto', '1');
	      }
	      xmlStream.closeNode();
	      return true;
	    }
	    return false;
	  }

	  parseOpen(node) {
	    if (node.name === this.name) {
	      if (node.attributes.rgb) {
	        this.model = {argb: node.attributes.rgb};
	      } else if (node.attributes.theme) {
	        this.model = {theme: parseInt(node.attributes.theme, 10)};
	        if (node.attributes.tint) {
	          this.model.tint = parseFloat(node.attributes.tint);
	        }
	      } else if (node.attributes.indexed) {
	        this.model = {indexed: parseInt(node.attributes.indexed, 10)};
	      } else {
	        this.model = undefined;
	      }
	      return true;
	    }
	    return false;
	  }

	  parseText() {}

	  parseClose() {
	    return false;
	  }
	}

	var colorXform = ColorXform;

	class BooleanXform extends baseXform {
	  constructor(options) {
	    super();

	    this.tag = options.tag;
	    this.attr = options.attr;
	  }

	  render(xmlStream, model) {
	    if (model) {
	      xmlStream.openNode(this.tag);
	      xmlStream.closeNode();
	    }
	  }

	  parseOpen(node) {
	    if (node.name === this.tag) {
	      this.model = true;
	    }
	  }

	  parseText() {}

	  parseClose() {
	    return false;
	  }
	}

	var booleanXform = BooleanXform;

	class IntegerXform extends baseXform {
	  constructor(options) {
	    super();

	    this.tag = options.tag;
	    this.attr = options.attr;
	    this.attrs = options.attrs;

	    // option to render zero
	    this.zero = options.zero;
	  }

	  render(xmlStream, model) {
	    // int is different to float in that zero is not rendered
	    if (model || this.zero) {
	      xmlStream.openNode(this.tag);
	      if (this.attrs) {
	        xmlStream.addAttributes(this.attrs);
	      }
	      if (this.attr) {
	        xmlStream.addAttribute(this.attr, model);
	      } else {
	        xmlStream.writeText(model);
	      }
	      xmlStream.closeNode();
	    }
	  }

	  parseOpen(node) {
	    if (node.name === this.tag) {
	      if (this.attr) {
	        this.model = parseInt(node.attributes[this.attr], 10);
	      } else {
	        this.text = [];
	      }
	      return true;
	    }
	    return false;
	  }

	  parseText(text) {
	    if (!this.attr) {
	      this.text.push(text);
	    }
	  }

	  parseClose() {
	    if (!this.attr) {
	      this.model = parseInt(this.text.join('') || 0, 10);
	    }
	    return false;
	  }
	}

	var integerXform = IntegerXform;

	class StringXform extends baseXform {
	  constructor(options) {
	    super();

	    this.tag = options.tag;
	    this.attr = options.attr;
	    this.attrs = options.attrs;
	  }

	  render(xmlStream, model) {
	    if (model !== undefined) {
	      xmlStream.openNode(this.tag);
	      if (this.attrs) {
	        xmlStream.addAttributes(this.attrs);
	      }
	      if (this.attr) {
	        xmlStream.addAttribute(this.attr, model);
	      } else {
	        xmlStream.writeText(model);
	      }
	      xmlStream.closeNode();
	    }
	  }

	  parseOpen(node) {
	    if (node.name === this.tag) {
	      if (this.attr) {
	        this.model = node.attributes[this.attr];
	      } else {
	        this.text = [];
	      }
	    }
	  }

	  parseText(text) {
	    if (!this.attr) {
	      this.text.push(text);
	    }
	  }

	  parseClose() {
	    if (!this.attr) {
	      this.model = this.text.join('');
	    }
	    return false;
	  }
	}

	var stringXform = StringXform;

	class UnderlineXform extends baseXform {
	  constructor(model) {
	    super();

	    this.model = model;
	  }

	  get tag() {
	    return 'u';
	  }

	  render(xmlStream, model) {
	    model = model || this.model;

	    if (model === true) {
	      xmlStream.leafNode('u');
	    } else {
	      const attr = UnderlineXform.Attributes[model];
	      if (attr) {
	        xmlStream.leafNode('u', attr);
	      }
	    }
	  }

	  parseOpen(node) {
	    if (node.name === 'u') {
	      this.model = node.attributes.val || true;
	    }
	  }

	  parseText() {}

	  parseClose() {
	    return false;
	  }
	}

	UnderlineXform.Attributes = {
	  single: {},
	  double: {val: 'double'},
	  singleAccounting: {val: 'singleAccounting'},
	  doubleAccounting: {val: 'doubleAccounting'},
	};

	var underlineXform = UnderlineXform;

	// Font encapsulates translation from font model to xlsx
	class FontXform extends baseXform {
	  constructor(options) {
	    super();

	    this.options = options || FontXform.OPTIONS;

	    this.map = {
	      b: {prop: 'bold', xform: new booleanXform({tag: 'b', attr: 'val'})},
	      i: {prop: 'italic', xform: new booleanXform({tag: 'i', attr: 'val'})},
	      u: {prop: 'underline', xform: new underlineXform()},
	      charset: {prop: 'charset', xform: new integerXform({tag: 'charset', attr: 'val'})},
	      color: {prop: 'color', xform: new colorXform()},
	      condense: {prop: 'condense', xform: new booleanXform({tag: 'condense', attr: 'val'})},
	      extend: {prop: 'extend', xform: new booleanXform({tag: 'extend', attr: 'val'})},
	      family: {prop: 'family', xform: new integerXform({tag: 'family', attr: 'val'})},
	      outline: {prop: 'outline', xform: new booleanXform({tag: 'outline', attr: 'val'})},
	      vertAlign: {prop: 'vertAlign', xform: new stringXform({tag: 'vertAlign', attr: 'val'})},
	      scheme: {prop: 'scheme', xform: new stringXform({tag: 'scheme', attr: 'val'})},
	      shadow: {prop: 'shadow', xform: new booleanXform({tag: 'shadow', attr: 'val'})},
	      strike: {prop: 'strike', xform: new booleanXform({tag: 'strike', attr: 'val'})},
	      sz: {prop: 'size', xform: new integerXform({tag: 'sz', attr: 'val'})},
	    };
	    this.map[this.options.fontNameTag] = {
	      prop: 'name',
	      xform: new stringXform({tag: this.options.fontNameTag, attr: 'val'}),
	    };
	  }

	  get tag() {
	    return this.options.tagName;
	  }

	  render(xmlStream, model) {
	    const {map} = this;

	    xmlStream.openNode(this.options.tagName);
	    underDash.each(this.map, (defn, tag) => {
	      map[tag].xform.render(xmlStream, model[defn.prop]);
	    });
	    xmlStream.closeNode();
	  }

	  parseOpen(node) {
	    if (this.parser) {
	      this.parser.parseOpen(node);
	      return true;
	    }
	    if (this.map[node.name]) {
	      this.parser = this.map[node.name].xform;
	      return this.parser.parseOpen(node);
	    }
	    switch (node.name) {
	      case this.options.tagName:
	        this.model = {};
	        return true;
	      default:
	        return false;
	    }
	  }

	  parseText(text) {
	    if (this.parser) {
	      this.parser.parseText(text);
	    }
	  }

	  parseClose(name) {
	    if (this.parser && !this.parser.parseClose(name)) {
	      const item = this.map[name];
	      if (this.parser.model) {
	        this.model[item.prop] = this.parser.model;
	      }
	      this.parser = undefined;
	      return true;
	    }
	    switch (name) {
	      case this.options.tagName:
	        return false;
	      default:
	        return true;
	    }
	  }
	}

	FontXform.OPTIONS = {
	  tagName: 'font',
	  fontNameTag: 'name',
	};

	var fontXform = FontXform;

	/* eslint-disable max-classes-per-file */




	class StopXform extends baseXform {
	  constructor() {
	    super();

	    this.map = {
	      color: new colorXform(),
	    };
	  }

	  get tag() {
	    return 'stop';
	  }

	  render(xmlStream, model) {
	    xmlStream.openNode('stop');
	    xmlStream.addAttribute('position', model.position);
	    this.map.color.render(xmlStream, model.color);
	    xmlStream.closeNode();
	  }

	  parseOpen(node) {
	    if (this.parser) {
	      this.parser.parseOpen(node);
	      return true;
	    }
	    switch (node.name) {
	      case 'stop':
	        this.model = {
	          position: parseFloat(node.attributes.position),
	        };
	        return true;
	      case 'color':
	        this.parser = this.map.color;
	        this.parser.parseOpen(node);
	        return true;
	      default:
	        return false;
	    }
	  }

	  parseText() {}

	  parseClose(name) {
	    if (this.parser) {
	      if (!this.parser.parseClose(name)) {
	        this.model.color = this.parser.model;
	        this.parser = undefined;
	      }
	      return true;
	    }
	    return false;
	  }
	}

	class PatternFillXform extends baseXform {
	  constructor() {
	    super();

	    this.map = {
	      fgColor: new colorXform('fgColor'),
	      bgColor: new colorXform('bgColor'),
	    };
	  }

	  get name() {
	    return 'pattern';
	  }

	  get tag() {
	    return 'patternFill';
	  }

	  render(xmlStream, model) {
	    xmlStream.openNode('patternFill');
	    xmlStream.addAttribute('patternType', model.pattern);
	    if (model.fgColor) {
	      this.map.fgColor.render(xmlStream, model.fgColor);
	    }
	    if (model.bgColor) {
	      this.map.bgColor.render(xmlStream, model.bgColor);
	    }
	    xmlStream.closeNode();
	  }

	  parseOpen(node) {
	    if (this.parser) {
	      this.parser.parseOpen(node);
	      return true;
	    }
	    switch (node.name) {
	      case 'patternFill':
	        this.model = {
	          type: 'pattern',
	          pattern: node.attributes.patternType,
	        };
	        return true;
	      default:
	        this.parser = this.map[node.name];
	        if (this.parser) {
	          this.parser.parseOpen(node);
	          return true;
	        }
	        return false;
	    }
	  }

	  parseText(text) {
	    if (this.parser) {
	      this.parser.parseText(text);
	    }
	  }

	  parseClose(name) {
	    if (this.parser) {
	      if (!this.parser.parseClose(name)) {
	        if (this.parser.model) {
	          this.model[name] = this.parser.model;
	        }
	        this.parser = undefined;
	      }
	      return true;
	    }
	    return false;
	  }
	}

	class GradientFillXform extends baseXform {
	  constructor() {
	    super();

	    this.map = {
	      stop: new StopXform(),
	    };
	    // if (model) {
	    //   this.gradient = model.gradient;
	    //   if (model.center) {
	    //     this.center = model.center;
	    //   }
	    //   if (model.degree !== undefined) {
	    //     this.degree = model.degree;
	    //   }
	    //   this.stops = model.stops.map(function(stop) { return new StopXform(stop); });
	    // } else {
	    //   this.stops = [];
	    // }
	  }

	  get name() {
	    return 'gradient';
	  }

	  get tag() {
	    return 'gradientFill';
	  }

	  render(xmlStream, model) {
	    xmlStream.openNode('gradientFill');
	    switch (model.gradient) {
	      case 'angle':
	        xmlStream.addAttribute('degree', model.degree);
	        break;
	      case 'path':
	        xmlStream.addAttribute('type', 'path');
	        if (model.center.left) {
	          xmlStream.addAttribute('left', model.center.left);
	          if (model.center.right === undefined) {
	            xmlStream.addAttribute('right', model.center.left);
	          }
	        }
	        if (model.center.right) {
	          xmlStream.addAttribute('right', model.center.right);
	        }
	        if (model.center.top) {
	          xmlStream.addAttribute('top', model.center.top);
	          if (model.center.bottom === undefined) {
	            xmlStream.addAttribute('bottom', model.center.top);
	          }
	        }
	        if (model.center.bottom) {
	          xmlStream.addAttribute('bottom', model.center.bottom);
	        }
	        break;
	    }

	    const stopXform = this.map.stop;
	    model.stops.forEach(stopModel => {
	      stopXform.render(xmlStream, stopModel);
	    });

	    xmlStream.closeNode();
	  }

	  parseOpen(node) {
	    if (this.parser) {
	      this.parser.parseOpen(node);
	      return true;
	    }
	    switch (node.name) {
	      case 'gradientFill': {
	        const model = (this.model = {
	          stops: [],
	        });
	        if (node.attributes.degree) {
	          model.gradient = 'angle';
	          model.degree = parseInt(node.attributes.degree, 10);
	        } else if (node.attributes.type === 'path') {
	          model.gradient = 'path';
	          model.center = {
	            left: node.attributes.left ? parseFloat(node.attributes.left) : 0,
	            top: node.attributes.top ? parseFloat(node.attributes.top) : 0,
	          };
	          if (node.attributes.right !== node.attributes.left) {
	            model.center.right = node.attributes.right ? parseFloat(node.attributes.right) : 0;
	          }
	          if (node.attributes.bottom !== node.attributes.top) {
	            model.center.bottom = node.attributes.bottom ? parseFloat(node.attributes.bottom) : 0;
	          }
	        }
	        return true;
	      }

	      case 'stop':
	        this.parser = this.map.stop;
	        this.parser.parseOpen(node);
	        return true;

	      default:
	        return false;
	    }
	  }

	  parseText(text) {
	    if (this.parser) {
	      this.parser.parseText(text);
	    }
	  }

	  parseClose(name) {
	    if (this.parser) {
	      if (!this.parser.parseClose(name)) {
	        this.model.stops.push(this.parser.model);
	        this.parser = undefined;
	      }
	      return true;
	    }
	    return false;
	  }
	}

	// Fill encapsulates translation from fill model to/from xlsx
	class FillXform extends baseXform {
	  constructor() {
	    super();

	    this.map = {
	      patternFill: new PatternFillXform(),
	      gradientFill: new GradientFillXform(),
	    };
	  }

	  get tag() {
	    return 'fill';
	  }

	  render(xmlStream, model) {
	    xmlStream.addRollback();
	    xmlStream.openNode('fill');
	    switch (model.type) {
	      case 'pattern':
	        this.map.patternFill.render(xmlStream, model);
	        break;
	      case 'gradient':
	        this.map.gradientFill.render(xmlStream, model);
	        break;
	      default:
	        xmlStream.rollback();
	        return;
	    }
	    xmlStream.closeNode();
	    xmlStream.commit();
	  }

	  parseOpen(node) {
	    if (this.parser) {
	      this.parser.parseOpen(node);
	      return true;
	    }
	    switch (node.name) {
	      case 'fill':
	        this.model = {};
	        return true;
	      default:
	        this.parser = this.map[node.name];
	        if (this.parser) {
	          this.parser.parseOpen(node);
	          return true;
	        }
	        return false;
	    }
	  }

	  parseText(text) {
	    if (this.parser) {
	      this.parser.parseText(text);
	    }
	  }

	  parseClose(name) {
	    if (this.parser) {
	      if (!this.parser.parseClose(name)) {
	        this.model = this.parser.model;
	        this.model.type = this.parser.name;
	        this.parser = undefined;
	      }
	      return true;
	    }
	    return false;
	  }

	  validStyle(value) {
	    return FillXform.validPatternValues[value];
	  }
	}

	FillXform.validPatternValues = [
	  'none',
	  'solid',
	  'darkVertical',
	  'darkGray',
	  'mediumGray',
	  'lightGray',
	  'gray125',
	  'gray0625',
	  'darkHorizontal',
	  'darkVertical',
	  'darkDown',
	  'darkUp',
	  'darkGrid',
	  'darkTrellis',
	  'lightHorizontal',
	  'lightVertical',
	  'lightDown',
	  'lightUp',
	  'lightGrid',
	  'lightTrellis',
	  'lightGrid',
	].reduce((p, v) => {
	  p[v] = true;
	  return p;
	}, {});

	FillXform.StopXform = StopXform;
	FillXform.PatternFillXform = PatternFillXform;
	FillXform.GradientFillXform = GradientFillXform;

	var fillXform = FillXform;

	/* eslint-disable max-classes-per-file */




	class EdgeXform extends baseXform {
	  constructor(name) {
	    super();

	    this.name = name;
	    this.map = {
	      color: new colorXform(),
	    };
	  }

	  get tag() {
	    return this.name;
	  }

	  render(xmlStream, model, defaultColor) {
	    const color = (model && model.color) || defaultColor || this.defaultColor;
	    xmlStream.openNode(this.name);
	    if (model && model.style) {
	      xmlStream.addAttribute('style', model.style);
	      if (color) {
	        this.map.color.render(xmlStream, color);
	      }
	    }
	    xmlStream.closeNode();
	  }

	  parseOpen(node) {
	    if (this.parser) {
	      this.parser.parseOpen(node);
	      return true;
	    }
	    switch (node.name) {
	      case this.name: {
	        const {style} = node.attributes;
	        if (style) {
	          this.model = {
	            style,
	          };
	        } else {
	          this.model = undefined;
	        }
	        return true;
	      }
	      case 'color':
	        this.parser = this.map.color;
	        this.parser.parseOpen(node);
	        return true;
	      default:
	        return false;
	    }
	  }

	  parseText(text) {
	    if (this.parser) {
	      this.parser.parseText(text);
	    }
	  }

	  parseClose(name) {
	    if (this.parser) {
	      if (!this.parser.parseClose(name)) {
	        this.parser = undefined;
	      }
	      return true;
	    }

	    if (name === this.name) {
	      if (this.map.color.model) {
	        if (!this.model) {
	          this.model = {};
	        }
	        this.model.color = this.map.color.model;
	      }
	    }

	    return false;
	  }

	  validStyle(value) {
	    return EdgeXform.validStyleValues[value];
	  }
	}

	EdgeXform.validStyleValues = [
	  'thin',
	  'dotted',
	  'dashDot',
	  'hair',
	  'dashDotDot',
	  'slantDashDot',
	  'mediumDashed',
	  'mediumDashDotDot',
	  'mediumDashDot',
	  'medium',
	  'double',
	  'thick',
	].reduce((p, v) => {
	  p[v] = true;
	  return p;
	}, {});

	// Border encapsulates translation from border model to/from xlsx
	class BorderXform extends baseXform {
	  constructor() {
	    super();

	    this.map = {
	      top: new EdgeXform('top'),
	      left: new EdgeXform('left'),
	      bottom: new EdgeXform('bottom'),
	      right: new EdgeXform('right'),
	      diagonal: new EdgeXform('diagonal'),
	    };
	  }

	  render(xmlStream, model) {
	    const {color} = model;
	    xmlStream.openNode('border');
	    if (model.diagonal && model.diagonal.style) {
	      if (model.diagonal.up) {
	        xmlStream.addAttribute('diagonalUp', '1');
	      }
	      if (model.diagonal.down) {
	        xmlStream.addAttribute('diagonalDown', '1');
	      }
	    }
	    function add(edgeModel, edgeXform) {
	      if (edgeModel && !edgeModel.color && model.color) {
	        // don't mess with incoming models
	        edgeModel = {
	          ...edgeModel,
	          color: model.color,
	        };
	      }
	      edgeXform.render(xmlStream, edgeModel, color);
	    }
	    add(model.left, this.map.left);
	    add(model.right, this.map.right);
	    add(model.top, this.map.top);
	    add(model.bottom, this.map.bottom);
	    add(model.diagonal, this.map.diagonal);

	    xmlStream.closeNode();
	  }

	  parseOpen(node) {
	    if (this.parser) {
	      this.parser.parseOpen(node);
	      return true;
	    }
	    switch (node.name) {
	      case 'border':
	        this.reset();
	        this.diagonalUp = !!node.attributes.diagonalUp;
	        this.diagonalDown = !!node.attributes.diagonalDown;
	        return true;
	      default:
	        this.parser = this.map[node.name];
	        if (this.parser) {
	          this.parser.parseOpen(node);
	          return true;
	        }
	        return false;
	    }
	  }

	  parseText(text) {
	    if (this.parser) {
	      this.parser.parseText(text);
	    }
	  }

	  parseClose(name) {
	    if (this.parser) {
	      if (!this.parser.parseClose(name)) {
	        this.parser = undefined;
	      }
	      return true;
	    }
	    if (name === 'border') {
	      const model = (this.model = {});
	      const add = function(key, edgeModel, extensions) {
	        if (edgeModel) {
	          if (extensions) {
	            Object.assign(edgeModel, extensions);
	          }
	          model[key] = edgeModel;
	        }
	      };
	      add('left', this.map.left.model);
	      add('right', this.map.right.model);
	      add('top', this.map.top.model);
	      add('bottom', this.map.bottom.model);
	      add('diagonal', this.map.diagonal.model, {up: this.diagonalUp, down: this.diagonalDown});
	    }
	    return false;
	  }
	}

	var borderXform = BorderXform;

	var defaultnumformats = {
	  0: {f: 'General'},
	  1: {f: '0'},
	  2: {f: '0.00'},
	  3: {f: '#,##0'},
	  4: {f: '#,##0.00'},
	  9: {f: '0%'},
	  10: {f: '0.00%'},
	  11: {f: '0.00E+00'},
	  12: {f: '# ?/?'},
	  13: {f: '# ??/??'},
	  14: {f: 'mm-dd-yy'},
	  15: {f: 'd-mmm-yy'},
	  16: {f: 'd-mmm'},
	  17: {f: 'mmm-yy'},
	  18: {f: 'h:mm AM/PM'},
	  19: {f: 'h:mm:ss AM/PM'},
	  20: {f: 'h:mm'},
	  21: {f: 'h:mm:ss'},
	  22: {f: 'm/d/yy "h":mm'},

	  27: {
	    'zh-tw': '[$-404]e/m/d',
	    'zh-cn': 'yyyy"å¹´"m"æ"',
	    'ja-jp': '[$-411]ge.m.d',
	    'ko-kr': 'yyyy"å¹´" mm"æ" dd"æ¥"',
	  },
	  28: {
	    'zh-tw': '[$-404]e"å¹´"m"æ"d"æ¥"',
	    'zh-cn': 'm"æ"d"æ¥"',
	    'ja-jp': '[$-411]ggge"å¹´"m"æ"d"æ¥"',
	    'ko-kr': 'mm-dd',
	  },
	  29: {
	    'zh-tw': '[$-404]e"å¹´"m"æ"d"æ¥"',
	    'zh-cn': 'm"æ"d"æ¥"',
	    'ja-jp': '[$-411]ggge"å¹´"m"æ"d"æ¥"',
	    'ko-kr': 'mm-dd',
	  },
	  30: {'zh-tw': 'm/d/yy ', 'zh-cn': 'm-d-yy', 'ja-jp': 'm/d/yy', 'ko-kr': 'mm-dd-yy'},
	  31: {
	    'zh-tw': 'yyyy"å¹´"m"æ"d"æ¥"',
	    'zh-cn': 'yyyy"å¹´"m"æ"d"æ¥"',
	    'ja-jp': 'yyyy"å¹´"m"æ"d"æ¥"',
	    'ko-kr': 'yyyy"ë" mm"ì" dd"ì¼"',
	  },
	  32: {
	    'zh-tw': 'hh"æ"mm"å"',
	    'zh-cn': 'h"æ¶"mm"å"',
	    'ja-jp': 'h"æ"mm"å"',
	    'ko-kr': 'h"ì" mm"ë¶"',
	  },
	  33: {
	    'zh-tw': 'hh"æ"mm"å"ss"ç§"',
	    'zh-cn': 'h"æ¶"mm"å"ss"ç§"',
	    'ja-jp': 'h"æ"mm"å"ss"ç§"',
	    'ko-kr': 'h"ì" mm"ë¶" ss"ì´"',
	  },
	  34: {
	    'zh-tw': 'ä¸å/ä¸å hh"æ"mm"å"',
	    'zh-cn': 'ä¸å/ä¸å h"æ¶"mm"å"',
	    'ja-jp': 'yyyy"å¹´"m"æ"',
	    'ko-kr': 'yyyy-mm-dd',
	  },
	  35: {
	    'zh-tw': 'ä¸å/ä¸å hh"æ"mm"å"ss"ç§"',
	    'zh-cn': 'ä¸å/ä¸å h"æ¶"mm"å"ss"ç§"',
	    'ja-jp': 'm"æ"d"æ¥"',
	    'ko-kr': 'yyyy-mm-dd',
	  },
	  36: {
	    'zh-tw': '[$-404]e/m/d',
	    'zh-cn': 'yyyy"å¹´"m"æ"',
	    'ja-jp': '[$-411]ge.m.d',
	    'ko-kr': 'yyyy"å¹´" mm"æ" dd"æ¥"',
	  },

	  37: {f: '#,##0 ;(#,##0)'},
	  38: {f: '#,##0 ;[Red](#,##0)'},
	  39: {f: '#,##0.00 ;(#,##0.00)'},
	  40: {f: '#,##0.00 ;[Red](#,##0.00)'},
	  45: {f: 'mm:ss'},
	  46: {f: '[h]:mm:ss'},
	  47: {f: 'mmss.0'},
	  48: {f: '##0.0E+0'},
	  49: {f: '@'},

	  50: {
	    'zh-tw': '[$-404]e/m/d',
	    'zh-cn': 'yyyy"å¹´"m"æ"',
	    'ja-jp': '[$-411]ge.m.d',
	    'ko-kr': 'yyyy"å¹´" mm"æ" dd"æ¥"',
	  },
	  51: {
	    'zh-tw': '[$-404]e"å¹´"m"æ"d"æ¥"',
	    'zh-cn': 'm"æ"d"æ¥"',
	    'ja-jp': '[$-411]ggge"å¹´"m"æ"d"æ¥"',
	    'ko-kr': 'mm-dd',
	  },
	  52: {
	    'zh-tw': 'ä¸å/ä¸å hh"æ"mm"å"',
	    'zh-cn': 'yyyy"å¹´"m"æ"',
	    'ja-jp': 'yyyy"å¹´"m"æ"',
	    'ko-kr': 'yyyy-mm-dd',
	  },
	  53: {
	    'zh-tw': 'ä¸å/ä¸å hh"æ"mm"å"ss"ç§"',
	    'zh-cn': 'm"æ"d"æ¥"',
	    'ja-jp': 'm"æ"d"æ¥"',
	    'ko-kr': 'yyyy-mm-dd',
	  },
	  54: {
	    'zh-tw': '[$-404]e"å¹´"m"æ"d"æ¥"',
	    'zh-cn': 'm"æ"d"æ¥"',
	    'ja-jp': '[$-411]ggge"å¹´"m"æ"d"æ¥"',
	    'ko-kr': 'mm-dd',
	  },
	  55: {
	    'zh-tw': 'ä¸å/ä¸å hh"æ"mm"å"',
	    'zh-cn': 'ä¸å/ä¸å h"æ¶"mm"å"',
	    'ja-jp': 'yyyy"å¹´"m"æ"',
	    'ko-kr': 'yyyy-mm-dd',
	  },
	  56: {
	    'zh-tw': 'ä¸å/ä¸å hh"æ"mm"å"ss"ç§"',
	    'zh-cn': 'ä¸å/ä¸å h"æ¶"mm"å"ss"ç§"',
	    'ja-jp': 'm"æ"d"æ¥"',
	    'ko-kr': 'yyyy-mm-dd',
	  },
	  57: {
	    'zh-tw': '[$-404]e/m/d',
	    'zh-cn': 'yyyy"å¹´"m"æ"',
	    'ja-jp': '[$-411]ge.m.d',
	    'ko-kr': 'yyyy"å¹´" mm"æ" dd"æ¥"',
	  },
	  58: {
	    'zh-tw': '[$-404]e"å¹´"m"æ"d"æ¥"',
	    'zh-cn': 'm"æ"d"æ¥"',
	    'ja-jp': '[$-411]ggge"å¹´"m"æ"d"æ¥"',
	    'ko-kr': 'mm-dd',
	  },

	  59: {'th-th': 't0'},
	  60: {'th-th': 't0.00'},
	  61: {'th-th': 't#,##0'},
	  62: {'th-th': 't#,##0.00'},
	  67: {'th-th': 't0%'},
	  68: {'th-th': 't0.00%'},
	  69: {'th-th': 't# ?/?'},
	  70: {'th-th': 't# ??/??'},

	  81: {'th-th': 'd/m/bb'},
	};

	function hashDefaultFormats() {
	  const hash = {};
	  underDash.each(defaultnumformats, (dnf, id) => {
	    if (dnf.f) {
	      hash[dnf.f] = parseInt(id, 10);
	    }
	    // at some point, add the other cultures here...
	  });
	  return hash;
	}
	const defaultFmtHash = hashDefaultFormats();

	// NumFmt encapsulates translation between number format and xlsx
	class NumFmtXform extends baseXform {
	  constructor(id, formatCode) {
	    super();

	    this.id = id;
	    this.formatCode = formatCode;
	  }

	  get tag() {
	    return 'numFmt';
	  }

	  render(xmlStream, model) {
	    xmlStream.leafNode('numFmt', {numFmtId: model.id, formatCode: model.formatCode});
	  }

	  parseOpen(node) {
	    switch (node.name) {
	      case 'numFmt':
	        this.model = {
	          id: parseInt(node.attributes.numFmtId, 10),
	          formatCode: node.attributes.formatCode.replace(/[\\](.)/g, '$1'),
	        };
	        return true;
	      default:
	        return false;
	    }
	  }

	  parseText() {}

	  parseClose() {
	    return false;
	  }
	}

	NumFmtXform.getDefaultFmtId = function getDefaultFmtId(formatCode) {
	  return defaultFmtHash[formatCode];
	};

	NumFmtXform.getDefaultFmtCode = function getDefaultFmtCode(numFmtId) {
	  return defaultnumformats[numFmtId] && defaultnumformats[numFmtId].f;
	};

	var numfmtXform = NumFmtXform;

	const validation = {
	  horizontalValues: [
	    'left',
	    'center',
	    'right',
	    'fill',
	    'centerContinuous',
	    'distributed',
	    'justify',
	  ].reduce((p, v) => {
	    p[v] = true;
	    return p;
	  }, {}),
	  horizontal(value) {
	    return this.horizontalValues[value] ? value : undefined;
	  },

	  verticalValues: ['top', 'middle', 'bottom', 'distributed', 'justify'].reduce((p, v) => {
	    p[v] = true;
	    return p;
	  }, {}),
	  vertical(value) {
	    if (value === 'middle') return 'center';
	    return this.verticalValues[value] ? value : undefined;
	  },
	  wrapText(value) {
	    return value ? true : undefined;
	  },
	  shrinkToFit(value) {
	    return value ? true : undefined;
	  },
	  textRotation(value) {
	    switch (value) {
	      case 'vertical':
	        return value;
	      default:
	        value = utils_1.validInt(value);
	        return value >= -90 && value <= 90 ? value : undefined;
	    }
	  },
	  indent(value) {
	    value = utils_1.validInt(value);
	    return Math.max(0, value);
	  },
	  readingOrder(value) {
	    switch (value) {
	      case 'ltr':
	        return enums.ReadingOrder.LeftToRight;
	      case 'rtl':
	        return enums.ReadingOrder.RightToLeft;
	      default:
	        return undefined;
	    }
	  },
	};

	const textRotationXform = {
	  toXml(textRotation) {
	    textRotation = validation.textRotation(textRotation);
	    if (textRotation) {
	      if (textRotation === 'vertical') {
	        return 255;
	      }

	      const tr = Math.round(textRotation);
	      if (tr >= 0 && tr <= 90) {
	        return tr;
	      }

	      if (tr < 0 && tr >= -90) {
	        return 90 - tr;
	      }
	    }
	    return undefined;
	  },
	  toModel(textRotation) {
	    const tr = utils_1.validInt(textRotation);
	    if (tr !== undefined) {
	      if (tr === 255) {
	        return 'vertical';
	      }
	      if (tr >= 0 && tr <= 90) {
	        return tr;
	      }
	      if (tr > 90 && tr <= 180) {
	        return 90 - tr;
	      }
	    }
	    return undefined;
	  },
	};

	// Alignment encapsulates translation from style.alignment model to/from xlsx
	class AlignmentXform extends baseXform {
	  get tag() {
	    return 'alignment';
	  }

	  render(xmlStream, model) {
	    xmlStream.addRollback();
	    xmlStream.openNode('alignment');

	    let isValid = false;
	    function add(name, value) {
	      if (value) {
	        xmlStream.addAttribute(name, value);
	        isValid = true;
	      }
	    }
	    add('horizontal', validation.horizontal(model.horizontal));
	    add('vertical', validation.vertical(model.vertical));
	    add('wrapText', validation.wrapText(model.wrapText) ? '1' : false);
	    add('shrinkToFit', validation.shrinkToFit(model.shrinkToFit) ? '1' : false);
	    add('indent', validation.indent(model.indent));
	    add('textRotation', textRotationXform.toXml(model.textRotation));
	    add('readingOrder', validation.readingOrder(model.readingOrder));

	    xmlStream.closeNode();

	    if (isValid) {
	      xmlStream.commit();
	    } else {
	      xmlStream.rollback();
	    }
	  }

	  parseOpen(node) {
	    const model = {};

	    let valid = false;
	    function add(truthy, name, value) {
	      if (truthy) {
	        model[name] = value;
	        valid = true;
	      }
	    }
	    add(node.attributes.horizontal, 'horizontal', node.attributes.horizontal);
	    add(
	      node.attributes.vertical,
	      'vertical',
	      node.attributes.vertical === 'center' ? 'middle' : node.attributes.vertical
	    );
	    add(node.attributes.wrapText, 'wrapText', !!node.attributes.wrapText);
	    add(node.attributes.shrinkToFit, 'shrinkToFit', !!node.attributes.shrinkToFit);
	    add(node.attributes.indent, 'indent', parseInt(node.attributes.indent, 10));
	    add(
	      node.attributes.textRotation,
	      'textRotation',
	      textRotationXform.toModel(node.attributes.textRotation)
	    );
	    add(
	      node.attributes.readingOrder,
	      'readingOrder',
	      node.attributes.readingOrder === '2' ? 'rtl' : 'ltr'
	    );

	    this.model = valid ? model : null;
	  }

	  parseText() {}

	  parseClose() {
	    return false;
	  }
	}

	var alignmentXform = AlignmentXform;

	const validation$1 = {
	  boolean(value, dflt) {
	    if (value === undefined) {
	      return dflt;
	    }
	    return value;
	  },
	};

	// Protection encapsulates translation from style.protection model to/from xlsx
	class ProtectionXform extends baseXform {
	  get tag() {
	    return 'protection';
	  }

	  render(xmlStream, model) {
	    xmlStream.addRollback();
	    xmlStream.openNode('protection');

	    let isValid = false;
	    function add(name, value) {
	      if (value !== undefined) {
	        xmlStream.addAttribute(name, value);
	        isValid = true;
	      }
	    }
	    add('locked', validation$1.boolean(model.locked, true) ? undefined : '0');
	    add('hidden', validation$1.boolean(model.hidden, false) ? '1' : undefined);

	    xmlStream.closeNode();

	    if (isValid) {
	      xmlStream.commit();
	    } else {
	      xmlStream.rollback();
	    }
	  }

	  parseOpen(node) {
	    const model = {
	      locked: !(node.attributes.locked === '0'),
	      hidden: node.attributes.hidden === '1',
	    };

	    // only want to record models that differ from defaults
	    const isSignificant = !model.locked || model.hidden;

	    this.model = isSignificant ? model : null;
	  }

	  parseText() {}

	  parseClose() {
	    return false;
	  }
	}

	var protectionXform = ProtectionXform;

	// <xf numFmtId="[numFmtId]" fontId="[fontId]" fillId="[fillId]" borderId="[xf.borderId]" xfId="[xfId]">
	//   Optional <alignment>
	//   Optional <protection>
	// </xf>

	// Style assists translation from style model to/from xlsx
	class StyleXform extends baseXform {
	  constructor(options) {
	    super();

	    this.xfId = !!(options && options.xfId);
	    this.map = {
	      alignment: new alignmentXform(),
	      protection: new protectionXform(),
	    };
	  }

	  get tag() {
	    return 'xf';
	  }

	  render(xmlStream, model) {
	    xmlStream.openNode('xf', {
	      numFmtId: model.numFmtId || 0,
	      fontId: model.fontId || 0,
	      fillId: model.fillId || 0,
	      borderId: model.borderId || 0,
	    });
	    if (this.xfId) {
	      xmlStream.addAttribute('xfId', model.xfId || 0);
	    }

	    if (model.numFmtId) {
	      xmlStream.addAttribute('applyNumberFormat', '1');
	    }
	    if (model.fontId) {
	      xmlStream.addAttribute('applyFont', '1');
	    }
	    if (model.fillId) {
	      xmlStream.addAttribute('applyFill', '1');
	    }
	    if (model.borderId) {
	      xmlStream.addAttribute('applyBorder', '1');
	    }
	    if (model.alignment) {
	      xmlStream.addAttribute('applyAlignment', '1');
	    }
	    if (model.protection) {
	      xmlStream.addAttribute('applyProtection', '1');
	    }

	    /**
	     * Rendering tags causes close of XML stream.
	     * Therefore adding attributes must be done before rendering tags.
	     */

	    if (model.alignment) {
	      this.map.alignment.render(xmlStream, model.alignment);
	    }
	    if (model.protection) {
	      this.map.protection.render(xmlStream, model.protection);
	    }

	    xmlStream.closeNode();
	  }

	  parseOpen(node) {
	    if (this.parser) {
	      this.parser.parseOpen(node);
	      return true;
	    }
	    // used during sax parsing of xml to build font object
	    switch (node.name) {
	      case 'xf':
	        this.model = {
	          numFmtId: parseInt(node.attributes.numFmtId, 10),
	          fontId: parseInt(node.attributes.fontId, 10),
	          fillId: parseInt(node.attributes.fillId, 10),
	          borderId: parseInt(node.attributes.borderId, 10),
	        };
	        if (this.xfId) {
	          this.model.xfId = parseInt(node.attributes.xfId, 10);
	        }
	        return true;
	      case 'alignment':
	        this.parser = this.map.alignment;
	        this.parser.parseOpen(node);
	        return true;
	      case 'protection':
	        this.parser = this.map.protection;
	        this.parser.parseOpen(node);
	        return true;
	      default:
	        return false;
	    }
	  }

	  parseText(text) {
	    if (this.parser) {
	      this.parser.parseText(text);
	    }
	  }

	  parseClose(name) {
	    if (this.parser) {
	      if (!this.parser.parseClose(name)) {
	        if (this.map.protection === this.parser) {
	          this.model.protection = this.parser.model;
	        } else {
	          this.model.alignment = this.parser.model;
	        }
	        this.parser = undefined;
	      }
	      return true;
	    }
	    return name !== 'xf';
	  }
	}

	var styleXform = StyleXform;

	// <xf numFmtId="[numFmtId]" fontId="[fontId]" fillId="[fillId]" borderId="[xf.borderId]" xfId="[xfId]">
	//   Optional <alignment>
	//   Optional <protection>
	// </xf>

	// Style assists translation from style model to/from xlsx
	class DxfXform extends baseXform {
	  constructor() {
	    super();

	    this.map = {
	      alignment: new alignmentXform(),
	      border: new borderXform(),
	      fill: new fillXform(),
	      font: new fontXform(),
	      numFmt: new numfmtXform(),
	      protection: new protectionXform(),
	    };
	  }

	  get tag() {
	    return 'dxf';
	  }

	  // how do we generate dxfid?

	  render(xmlStream, model) {
	    xmlStream.openNode(this.tag);

	    if (model.alignment) {
	      this.map.alignment.render(xmlStream, model.alignment);
	    }
	    if (model.border) {
	      this.map.border.render(xmlStream, model.border);
	    }
	    if (model.fill) {
	      this.map.fill.render(xmlStream, model.fill);
	    }
	    if (model.font) {
	      this.map.font.render(xmlStream, model.font);
	    }
	    if (model.numFmt) {
	      this.map.numFmt.render(xmlStream, model.numFmt);
	    }
	    if (model.protection) {
	      this.map.protection.render(xmlStream, model.protection);
	    }

	    xmlStream.closeNode();
	  }

	  parseOpen(node) {
	    if (this.parser) {
	      this.parser.parseOpen(node);
	      return true;
	    }

	    switch (node.name) {
	      case this.tag:
	        // this node is often repeated. Need to reset children
	        this.reset();
	        return true;
	      default:
	        this.parser = this.map[node.name];
	        if (this.parser) {
	          this.parser.parseOpen(node);
	        }
	        return true;
	    }
	  }

	  parseText(text) {
	    if (this.parser) {
	      this.parser.parseText(text);
	    }
	  }

	  parseClose(name) {
	    if (this.parser) {
	      if (!this.parser.parseClose(name)) {
	        this.parser = undefined;
	      }
	      return true;
	    }
	    if (name === this.tag) {
	      this.model = {
	        alignment: this.map.alignment.model,
	        border: this.map.border.model,
	        fill: this.map.fill.model,
	        font: this.map.font.model,
	        numFmt: this.map.numFmt.model,
	        protection: this.map.protection.model,
	      };
	      return false;
	    }

	    return true;
	  }
	}

	var dxfXform = DxfXform;

	/* eslint-disable max-classes-per-file */













	// custom numfmt ids start here
	const NUMFMT_BASE = 164;

	// =============================================================================
	// StylesXform is used to generate and parse the styles.xml file
	// it manages the collections of fonts, number formats, alignments, etc
	class StylesXform extends baseXform {
	  constructor(initialise) {
	    super();

	    this.map = {
	      numFmts: new listXform({tag: 'numFmts', count: true, childXform: new numfmtXform()}),
	      fonts: new listXform({
	        tag: 'fonts',
	        count: true,
	        childXform: new fontXform(),
	        $: {'x14ac:knownFonts': 1},
	      }),
	      fills: new listXform({tag: 'fills', count: true, childXform: new fillXform()}),
	      borders: new listXform({tag: 'borders', count: true, childXform: new borderXform()}),
	      cellStyleXfs: new listXform({tag: 'cellStyleXfs', count: true, childXform: new styleXform()}),
	      cellXfs: new listXform({
	        tag: 'cellXfs',
	        count: true,
	        childXform: new styleXform({xfId: true}),
	      }),
	      dxfs: new listXform({tag: 'dxfs', always: true, count: true, childXform: new dxfXform()}),

	      // for style manager
	      numFmt: new numfmtXform(),
	      font: new fontXform(),
	      fill: new fillXform(),
	      border: new borderXform(),
	      style: new styleXform({xfId: true}),

	      cellStyles: StylesXform.STATIC_XFORMS.cellStyles,
	      tableStyles: StylesXform.STATIC_XFORMS.tableStyles,
	      extLst: StylesXform.STATIC_XFORMS.extLst,
	    };

	    if (initialise) {
	      // StylesXform also acts as style manager and is used to build up styles-model during worksheet processing
	      this.init();
	    }
	  }

	  initIndex() {
	    this.index = {
	      style: {},
	      numFmt: {},
	      numFmtNextId: 164, // start custom format ids here
	      font: {},
	      border: {},
	      fill: {},
	    };
	  }

	  init() {
	    // Prepare for Style Manager role
	    this.model = {
	      styles: [],
	      numFmts: [],
	      fonts: [],
	      borders: [],
	      fills: [],
	      dxfs: [],
	    };

	    this.initIndex();

	    // default (zero) border
	    this._addBorder({});

	    // add default (all zero) style
	    this._addStyle({numFmtId: 0, fontId: 0, fillId: 0, borderId: 0, xfId: 0});

	    // add default fills
	    this._addFill({type: 'pattern', pattern: 'none'});
	    this._addFill({type: 'pattern', pattern: 'gray125'});

	    this.weakMap = new WeakMap();
	  }

	  render(xmlStream$1, model) {
	    model = model || this.model;
	    //
	    //   <fonts count="2" x14ac:knownFonts="1">
	    xmlStream$1.openXml(xmlStream.StdDocAttributes);

	    xmlStream$1.openNode('styleSheet', StylesXform.STYLESHEET_ATTRIBUTES);

	    if (this.index) {
	      // model has been built by style manager role (contains xml)
	      if (model.numFmts && model.numFmts.length) {
	        xmlStream$1.openNode('numFmts', {count: model.numFmts.length});
	        model.numFmts.forEach(numFmtXml => {
	          xmlStream$1.writeXml(numFmtXml);
	        });
	        xmlStream$1.closeNode();
	      }

	      if (!model.fonts.length) {
	        // default (zero) font
	        this._addFont({size: 11, color: {theme: 1}, name: 'Calibri', family: 2, scheme: 'minor'});
	      }
	      xmlStream$1.openNode('fonts', {count: model.fonts.length, 'x14ac:knownFonts': 1});
	      model.fonts.forEach(fontXml => {
	        xmlStream$1.writeXml(fontXml);
	      });
	      xmlStream$1.closeNode();

	      xmlStream$1.openNode('fills', {count: model.fills.length});
	      model.fills.forEach(fillXml => {
	        xmlStream$1.writeXml(fillXml);
	      });
	      xmlStream$1.closeNode();

	      xmlStream$1.openNode('borders', {count: model.borders.length});
	      model.borders.forEach(borderXml => {
	        xmlStream$1.writeXml(borderXml);
	      });
	      xmlStream$1.closeNode();

	      this.map.cellStyleXfs.render(xmlStream$1, [
	        {numFmtId: 0, fontId: 0, fillId: 0, borderId: 0, xfId: 0},
	      ]);

	      xmlStream$1.openNode('cellXfs', {count: model.styles.length});
	      model.styles.forEach(styleXml => {
	        xmlStream$1.writeXml(styleXml);
	      });
	      xmlStream$1.closeNode();
	    } else {
	      // model is plain JSON and needs to be xformed
	      this.map.numFmts.render(xmlStream$1, model.numFmts);
	      this.map.fonts.render(xmlStream$1, model.fonts);
	      this.map.fills.render(xmlStream$1, model.fills);
	      this.map.borders.render(xmlStream$1, model.borders);
	      this.map.cellStyleXfs.render(xmlStream$1, [
	        {numFmtId: 0, fontId: 0, fillId: 0, borderId: 0, xfId: 0},
	      ]);
	      this.map.cellXfs.render(xmlStream$1, model.styles);
	    }

	    StylesXform.STATIC_XFORMS.cellStyles.render(xmlStream$1);

	    this.map.dxfs.render(xmlStream$1, model.dxfs);

	    StylesXform.STATIC_XFORMS.tableStyles.render(xmlStream$1);
	    StylesXform.STATIC_XFORMS.extLst.render(xmlStream$1);

	    xmlStream$1.closeNode();
	  }

	  parseOpen(node) {
	    if (this.parser) {
	      this.parser.parseOpen(node);
	      return true;
	    }
	    switch (node.name) {
	      case 'styleSheet':
	        this.initIndex();
	        return true;
	      default:
	        this.parser = this.map[node.name];
	        if (this.parser) {
	          this.parser.parseOpen(node);
	        }
	        return true;
	    }
	  }

	  parseText(text) {
	    if (this.parser) {
	      this.parser.parseText(text);
	    }
	  }

	  parseClose(name) {
	    if (this.parser) {
	      if (!this.parser.parseClose(name)) {
	        this.parser = undefined;
	      }
	      return true;
	    }
	    switch (name) {
	      case 'styleSheet': {
	        this.model = {};
	        const add = (propName, xform) => {
	          if (xform.model && xform.model.length) {
	            this.model[propName] = xform.model;
	          }
	        };
	        add('numFmts', this.map.numFmts);
	        add('fonts', this.map.fonts);
	        add('fills', this.map.fills);
	        add('borders', this.map.borders);
	        add('styles', this.map.cellXfs);
	        add('dxfs', this.map.dxfs);

	        // index numFmts
	        this.index = {
	          model: [],
	          numFmt: [],
	        };
	        if (this.model.numFmts) {
	          const numFmtIndex = this.index.numFmt;
	          this.model.numFmts.forEach(numFmt => {
	            numFmtIndex[numFmt.id] = numFmt.formatCode;
	          });
	        }

	        return false;
	      }
	      default:
	        // not quite sure how we get here!
	        return true;
	    }
	  }

	  // add a cell's style model to the collection
	  // each style property is processed and cross-referenced, etc.
	  // the styleId is returned. Note: cellType is used when numFmt not defined
	  addStyleModel(model, cellType) {
	    if (!model) {
	      return 0;
	    }

	    // if we have no default font, add it here now
	    if (!this.model.fonts.length) {
	      // default (zero) font
	      this._addFont({size: 11, color: {theme: 1}, name: 'Calibri', family: 2, scheme: 'minor'});
	    }

	    // if we have seen this style object before, assume it has the same styleId
	    if (this.weakMap && this.weakMap.has(model)) {
	      return this.weakMap.get(model);
	    }

	    const style = {};
	    cellType = cellType || enums.ValueType.Number;

	    if (model.numFmt) {
	      style.numFmtId = this._addNumFmtStr(model.numFmt);
	    } else {
	      switch (cellType) {
	        case enums.ValueType.Number:
	          style.numFmtId = this._addNumFmtStr('General');
	          break;
	        case enums.ValueType.Date:
	          style.numFmtId = this._addNumFmtStr('mm-dd-yy');
	          break;
	      }
	    }

	    if (model.font) {
	      style.fontId = this._addFont(model.font);
	    }

	    if (model.border) {
	      style.borderId = this._addBorder(model.border);
	    }

	    if (model.fill) {
	      style.fillId = this._addFill(model.fill);
	    }

	    if (model.alignment) {
	      style.alignment = model.alignment;
	    }

	    if (model.protection) {
	      style.protection = model.protection;
	    }

	    const styleId = this._addStyle(style);
	    if (this.weakMap) {
	      this.weakMap.set(model, styleId);
	    }
	    return styleId;
	  }

	  // given a styleId (i.e. s="n"), get the cell's style model
	  // objects are shared where possible.
	  getStyleModel(id) {
	    // if the style doesn't exist return null
	    const style = this.model.styles[id];
	    if (!style) return null;

	    // have we built this model before?
	    let model = this.index.model[id];
	    if (model) return model;

	    // build a new model
	    model = this.index.model[id] = {};

	    // -------------------------------------------------------
	    // number format
	    if (style.numFmtId) {
	      const numFmt =
	        this.index.numFmt[style.numFmtId] || numfmtXform.getDefaultFmtCode(style.numFmtId);
	      if (numFmt) {
	        model.numFmt = numFmt;
	      }
	    }

	    function addStyle(name, group, styleId) {
	      if (styleId || styleId === 0) {
	        const part = group[styleId];
	        if (part) {
	          model[name] = part;
	        }
	      }
	    }

	    addStyle('font', this.model.fonts, style.fontId);
	    addStyle('border', this.model.borders, style.borderId);
	    addStyle('fill', this.model.fills, style.fillId);

	    // -------------------------------------------------------
	    // alignment
	    if (style.alignment) {
	      model.alignment = style.alignment;
	    }

	    // -------------------------------------------------------
	    // protection
	    if (style.protection) {
	      model.protection = style.protection;
	    }

	    return model;
	  }

	  addDxfStyle(style) {
	    this.model.dxfs.push(style);
	    return this.model.dxfs.length - 1;
	  }

	  getDxfStyle(id) {
	    return this.model.dxfs[id];
	  }

	  // =========================================================================
	  // Private Interface
	  _addStyle(style) {
	    const xml = this.map.style.toXml(style);
	    let index = this.index.style[xml];
	    if (index === undefined) {
	      index = this.index.style[xml] = this.model.styles.length;
	      this.model.styles.push(xml);
	    }
	    return index;
	  }

	  // =========================================================================
	  // Number Formats
	  _addNumFmtStr(formatCode) {
	    // check if default format
	    let index = numfmtXform.getDefaultFmtId(formatCode);
	    if (index !== undefined) return index;

	    // check if already in
	    index = this.index.numFmt[formatCode];
	    if (index !== undefined) return index;

	    index = this.index.numFmt[formatCode] = NUMFMT_BASE + this.model.numFmts.length;
	    const xml = this.map.numFmt.toXml({id: index, formatCode});
	    this.model.numFmts.push(xml);
	    return index;
	  }

	  // =========================================================================
	  // Fonts
	  _addFont(font) {
	    const xml = this.map.font.toXml(font);
	    let index = this.index.font[xml];
	    if (index === undefined) {
	      index = this.index.font[xml] = this.model.fonts.length;
	      this.model.fonts.push(xml);
	    }
	    return index;
	  }

	  // =========================================================================
	  // Borders
	  _addBorder(border) {
	    const xml = this.map.border.toXml(border);
	    let index = this.index.border[xml];
	    if (index === undefined) {
	      index = this.index.border[xml] = this.model.borders.length;
	      this.model.borders.push(xml);
	    }
	    return index;
	  }

	  // =========================================================================
	  // Fills
	  _addFill(fill) {
	    const xml = this.map.fill.toXml(fill);
	    let index = this.index.fill[xml];
	    if (index === undefined) {
	      index = this.index.fill[xml] = this.model.fills.length;
	      this.model.fills.push(xml);
	    }
	    return index;
	  }

	  // =========================================================================
	}

	StylesXform.STYLESHEET_ATTRIBUTES = {
	  xmlns: 'http://schemas.openxmlformats.org/spreadsheetml/2006/main',
	  'xmlns:mc': 'http://schemas.openxmlformats.org/markup-compatibility/2006',
	  'mc:Ignorable': 'x14ac x16r2',
	  'xmlns:x14ac': 'http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac',
	  'xmlns:x16r2': 'http://schemas.microsoft.com/office/spreadsheetml/2015/02/main',
	};
	StylesXform.STATIC_XFORMS = {
	  cellStyles: new staticXform({
	    tag: 'cellStyles',
	    $: {count: 1},
	    c: [{tag: 'cellStyle', $: {name: 'Normal', xfId: 0, builtinId: 0}}],
	  }),
	  dxfs: new staticXform({tag: 'dxfs', $: {count: 0}}),
	  tableStyles: new staticXform({
	    tag: 'tableStyles',
	    $: {count: 0, defaultTableStyle: 'TableStyleMedium2', defaultPivotStyle: 'PivotStyleLight16'},
	  }),
	  extLst: new staticXform({
	    tag: 'extLst',
	    c: [
	      {
	        tag: 'ext',
	        $: {
	          uri: '{EB79DEF2-80B8-43e5-95BD-54CBDDF9020C}',
	          'xmlns:x14': 'http://schemas.microsoft.com/office/spreadsheetml/2009/9/main',
	        },
	        c: [{tag: 'x14:slicerStyles', $: {defaultSlicerStyle: 'SlicerStyleLight1'}}],
	      },
	      {
	        tag: 'ext',
	        $: {
	          uri: '{9260A510-F301-46a8-8635-F512D64BE5F5}',
	          'xmlns:x15': 'http://schemas.microsoft.com/office/spreadsheetml/2010/11/main',
	        },
	        c: [{tag: 'x15:timelineStyles', $: {defaultTimelineStyle: 'TimeSlicerStyleLight1'}}],
	      },
	    ],
	  }),
	};

	// the stylemanager mock acts like StyleManager except that it always returns 0 or {}
	class StylesXformMock extends StylesXform {
	  constructor() {
	    super();

	    this.model = {
	      styles: [{numFmtId: 0, fontId: 0, fillId: 0, borderId: 0, xfId: 0}],
	      numFmts: [],
	      fonts: [{size: 11, color: {theme: 1}, name: 'Calibri', family: 2, scheme: 'minor'}],
	      borders: [{}],
	      fills: [
	        {type: 'pattern', pattern: 'none'},
	        {type: 'pattern', pattern: 'gray125'},
	      ],
	    };
	  }

	  // =========================================================================
	  // Style Manager Interface

	  // override normal behaviour - consume and dispose
	  parseStream(stream) {
	    stream.autodrain();
	    return Promise.resolve();
	  }

	  // add a cell's style model to the collection
	  // each style property is processed and cross-referenced, etc.
	  // the styleId is returned. Note: cellType is used when numFmt not defined
	  addStyleModel(model, cellType) {
	    switch (cellType) {
	      case enums.ValueType.Date:
	        return this.dateStyleId;
	      default:
	        return 0;
	    }
	  }

	  get dateStyleId() {
	    if (!this._dateStyleId) {
	      const dateStyle = {
	        numFmtId: numfmtXform.getDefaultFmtId('mm-dd-yy'),
	      };
	      this._dateStyleId = this.model.styles.length;
	      this.model.styles.push(dateStyle);
	    }
	    return this._dateStyleId;
	  }

	  // given a styleId (i.e. s="n"), get the cell's style model
	  // objects are shared where possible.
	  getStyleModel(/* id */) {
	    return {};
	  }
	}

	StylesXform.Mock = StylesXformMock;

	var stylesXform = StylesXform;

	class DateXform extends baseXform {
	  constructor(options) {
	    super();

	    this.tag = options.tag;
	    this.attr = options.attr;
	    this.attrs = options.attrs;
	    this._format =
	      options.format ||
	      function(dt) {
	        try {
	          if (Number.isNaN(dt.getTime())) return '';
	          return dt.toISOString();
	        } catch (e) {
	          return '';
	        }
	      };
	    this._parse =
	      options.parse ||
	      function(str) {
	        return new Date(str);
	      };
	  }

	  render(xmlStream, model) {
	    if (model) {
	      xmlStream.openNode(this.tag);
	      if (this.attrs) {
	        xmlStream.addAttributes(this.attrs);
	      }
	      if (this.attr) {
	        xmlStream.addAttribute(this.attr, this._format(model));
	      } else {
	        xmlStream.writeText(this._format(model));
	      }
	      xmlStream.closeNode();
	    }
	  }

	  parseOpen(node) {
	    if (node.name === this.tag) {
	      if (this.attr) {
	        this.model = this._parse(node.attributes[this.attr]);
	      } else {
	        this.text = [];
	      }
	    }
	  }

	  parseText(text) {
	    if (!this.attr) {
	      this.text.push(text);
	    }
	  }

	  parseClose() {
	    if (!this.attr) {
	      this.model = this._parse(this.text.join(''));
	    }
	    return false;
	  }
	}

	var dateXform = DateXform;

	class CoreXform extends baseXform {
	  constructor() {
	    super();

	    this.map = {
	      'dc:creator': new stringXform({tag: 'dc:creator'}),
	      'dc:title': new stringXform({tag: 'dc:title'}),
	      'dc:subject': new stringXform({tag: 'dc:subject'}),
	      'dc:description': new stringXform({tag: 'dc:description'}),
	      'dc:identifier': new stringXform({tag: 'dc:identifier'}),
	      'dc:language': new stringXform({tag: 'dc:language'}),
	      'cp:keywords': new stringXform({tag: 'cp:keywords'}),
	      'cp:category': new stringXform({tag: 'cp:category'}),
	      'cp:lastModifiedBy': new stringXform({tag: 'cp:lastModifiedBy'}),
	      'cp:lastPrinted': new dateXform({tag: 'cp:lastPrinted', format: CoreXform.DateFormat}),
	      'cp:revision': new integerXform({tag: 'cp:revision'}),
	      'cp:version': new stringXform({tag: 'cp:version'}),
	      'cp:contentStatus': new stringXform({tag: 'cp:contentStatus'}),
	      'cp:contentType': new stringXform({tag: 'cp:contentType'}),
	      'dcterms:created': new dateXform({
	        tag: 'dcterms:created',
	        attrs: CoreXform.DateAttrs,
	        format: CoreXform.DateFormat,
	      }),
	      'dcterms:modified': new dateXform({
	        tag: 'dcterms:modified',
	        attrs: CoreXform.DateAttrs,
	        format: CoreXform.DateFormat,
	      }),
	    };
	  }

	  render(xmlStream$1, model) {
	    xmlStream$1.openXml(xmlStream.StdDocAttributes);

	    xmlStream$1.openNode('cp:coreProperties', CoreXform.CORE_PROPERTY_ATTRIBUTES);

	    this.map['dc:creator'].render(xmlStream$1, model.creator);
	    this.map['dc:title'].render(xmlStream$1, model.title);
	    this.map['dc:subject'].render(xmlStream$1, model.subject);
	    this.map['dc:description'].render(xmlStream$1, model.description);
	    this.map['dc:identifier'].render(xmlStream$1, model.identifier);
	    this.map['dc:language'].render(xmlStream$1, model.language);
	    this.map['cp:keywords'].render(xmlStream$1, model.keywords);
	    this.map['cp:category'].render(xmlStream$1, model.category);
	    this.map['cp:lastModifiedBy'].render(xmlStream$1, model.lastModifiedBy);
	    this.map['cp:lastPrinted'].render(xmlStream$1, model.lastPrinted);
	    this.map['cp:revision'].render(xmlStream$1, model.revision);
	    this.map['cp:version'].render(xmlStream$1, model.version);
	    this.map['cp:contentStatus'].render(xmlStream$1, model.contentStatus);
	    this.map['cp:contentType'].render(xmlStream$1, model.contentType);
	    this.map['dcterms:created'].render(xmlStream$1, model.created);
	    this.map['dcterms:modified'].render(xmlStream$1, model.modified);

	    xmlStream$1.closeNode();
	  }

	  parseOpen(node) {
	    if (this.parser) {
	      this.parser.parseOpen(node);
	      return true;
	    }
	    switch (node.name) {
	      case 'cp:coreProperties':
	      case 'coreProperties':
	        return true;
	      default:
	        this.parser = this.map[node.name];
	        if (this.parser) {
	          this.parser.parseOpen(node);
	          return true;
	        }
	        throw new Error(`Unexpected xml node in parseOpen: ${JSON.stringify(node)}`);
	    }
	  }

	  parseText(text) {
	    if (this.parser) {
	      this.parser.parseText(text);
	    }
	  }

	  parseClose(name) {
	    if (this.parser) {
	      if (!this.parser.parseClose(name)) {
	        this.parser = undefined;
	      }
	      return true;
	    }
	    switch (name) {
	      case 'cp:coreProperties':
	      case 'coreProperties':
	        this.model = {
	          creator: this.map['dc:creator'].model,
	          title: this.map['dc:title'].model,
	          subject: this.map['dc:subject'].model,
	          description: this.map['dc:description'].model,
	          identifier: this.map['dc:identifier'].model,
	          language: this.map['dc:language'].model,
	          keywords: this.map['cp:keywords'].model,
	          category: this.map['cp:category'].model,
	          lastModifiedBy: this.map['cp:lastModifiedBy'].model,
	          lastPrinted: this.map['cp:lastPrinted'].model,
	          revision: this.map['cp:revision'].model,
	          contentStatus: this.map['cp:contentStatus'].model,
	          contentType: this.map['cp:contentType'].model,
	          created: this.map['dcterms:created'].model,
	          modified: this.map['dcterms:modified'].model,
	        };
	        return false;
	      default:
	        throw new Error(`Unexpected xml node in parseClose: ${name}`);
	    }
	  }
	}

	CoreXform.DateFormat = function(dt) {
	  return dt.toISOString().replace(/[.]\d{3}/, '');
	};
	CoreXform.DateAttrs = {'xsi:type': 'dcterms:W3CDTF'};

	CoreXform.CORE_PROPERTY_ATTRIBUTES = {
	  'xmlns:cp': 'http://schemas.openxmlformats.org/package/2006/metadata/core-properties',
	  'xmlns:dc': 'http://purl.org/dc/elements/1.1/',
	  'xmlns:dcterms': 'http://purl.org/dc/terms/',
	  'xmlns:dcmitype': 'http://purl.org/dc/dcmitype/',
	  'xmlns:xsi': 'http://www.w3.org/2001/XMLSchema-instance',
	};

	var coreXform = CoreXform;

	//   <t xml:space="preserve"> is </t>

	class TextXform extends baseXform {
	  get tag() {
	    return 't';
	  }

	  render(xmlStream, model) {
	    xmlStream.openNode('t');
	    if (/^\s|\n|\s$/.test(model)) {
	      xmlStream.addAttribute('xml:space', 'preserve');
	    }
	    xmlStream.writeText(model);
	    xmlStream.closeNode();
	  }

	  get model() {
	    return this._text
	      .join('')
	      .replace(/_x([0-9A-F]{4})_/g, ($0, $1) => String.fromCharCode(parseInt($1, 16)));
	  }

	  parseOpen(node) {
	    switch (node.name) {
	      case 't':
	        this._text = [];
	        return true;
	      default:
	        return false;
	    }
	  }

	  parseText(text) {
	    this._text.push(text);
	  }

	  parseClose() {
	    return false;
	  }
	}

	var textXform = TextXform;

	// <r>
	//   <rPr>
	//     <sz val="11"/>
	//     <color theme="1" tint="5"/>
	//     <rFont val="Calibri"/>
	//     <family val="2"/>
	//     <scheme val="minor"/>
	//   </rPr>
	//   <t xml:space="preserve"> is </t>
	// </r>

	class RichTextXform extends baseXform {
	  constructor(model) {
	    super();

	    this.model = model;
	  }

	  get tag() {
	    return 'r';
	  }

	  get textXform() {
	    return this._textXform || (this._textXform = new textXform());
	  }

	  get fontXform() {
	    return this._fontXform || (this._fontXform = new fontXform(RichTextXform.FONT_OPTIONS));
	  }

	  render(xmlStream, model) {
	    model = model || this.model;

	    xmlStream.openNode('r');
	    if (model.font) {
	      this.fontXform.render(xmlStream, model.font);
	    }
	    this.textXform.render(xmlStream, model.text);
	    xmlStream.closeNode();
	  }

	  parseOpen(node) {
	    if (this.parser) {
	      this.parser.parseOpen(node);
	      return true;
	    }
	    switch (node.name) {
	      case 'r':
	        this.model = {};
	        return true;
	      case 't':
	        this.parser = this.textXform;
	        this.parser.parseOpen(node);
	        return true;
	      case 'rPr':
	        this.parser = this.fontXform;
	        this.parser.parseOpen(node);
	        return true;
	      default:
	        return false;
	    }
	  }

	  parseText(text) {
	    if (this.parser) {
	      this.parser.parseText(text);
	    }
	  }

	  parseClose(name) {
	    switch (name) {
	      case 'r':
	        return false;
	      case 't':
	        this.model.text = this.parser.model;
	        this.parser = undefined;
	        return true;
	      case 'rPr':
	        this.model.font = this.parser.model;
	        this.parser = undefined;
	        return true;
	      default:
	        if (this.parser) {
	          this.parser.parseClose(name);
	        }
	        return true;
	    }
	  }
	}

	RichTextXform.FONT_OPTIONS = {
	  tagName: 'rPr',
	  fontNameTag: 'rFont',
	};

	var richTextXform = RichTextXform;

	// <rPh sb="0" eb="1">
	//   <t>(its pronounciation in KATAKANA)</t>
	// </rPh>

	class PhoneticTextXform extends baseXform {
	  constructor() {
	    super();

	    this.map = {
	      r: new richTextXform(),
	      t: new textXform(),
	    };
	  }

	  get tag() {
	    return 'rPh';
	  }

	  render(xmlStream, model) {
	    xmlStream.openNode(this.tag, {
	      sb: model.sb || 0,
	      eb: model.eb || 0,
	    });
	    if (model && model.hasOwnProperty('richText') && model.richText) {
	      const {r} = this.map;
	      model.richText.forEach(text => {
	        r.render(xmlStream, text);
	      });
	    } else if (model) {
	      this.map.t.render(xmlStream, model.text);
	    }
	    xmlStream.closeNode();
	  }

	  parseOpen(node) {
	    const {name} = node;
	    if (this.parser) {
	      this.parser.parseOpen(node);
	      return true;
	    }
	    if (name === this.tag) {
	      this.model = {
	        sb: parseInt(node.attributes.sb, 10),
	        eb: parseInt(node.attributes.eb, 10),
	      };
	      return true;
	    }
	    this.parser = this.map[name];
	    if (this.parser) {
	      this.parser.parseOpen(node);
	      return true;
	    }
	    return false;
	  }

	  parseText(text) {
	    if (this.parser) {
	      this.parser.parseText(text);
	    }
	  }

	  parseClose(name) {
	    if (this.parser) {
	      if (!this.parser.parseClose(name)) {
	        switch (name) {
	          case 'r': {
	            let rt = this.model.richText;
	            if (!rt) {
	              rt = this.model.richText = [];
	            }
	            rt.push(this.parser.model);
	            break;
	          }
	          case 't':
	            this.model.text = this.parser.model;
	            break;
	        }
	        this.parser = undefined;
	      }
	      return true;
	    }
	    switch (name) {
	      case this.tag:
	        return false;
	      default:
	        return true;
	    }
	  }
	}

	var phoneticTextXform = PhoneticTextXform;

	// <si>
	//   <r></r><r></r>...
	// </si>
	// <si>
	//   <t></t>
	// </si>

	class SharedStringXform extends baseXform {
	  constructor(model) {
	    super();

	    this.model = model;

	    this.map = {
	      r: new richTextXform(),
	      t: new textXform(),
	      rPh: new phoneticTextXform(),
	    };
	  }

	  get tag() {
	    return 'si';
	  }

	  render(xmlStream, model) {
	    xmlStream.openNode(this.tag);
	    if (model && model.hasOwnProperty('richText') && model.richText) {
	      if (model.richText.length) {
	        model.richText.forEach(text => {
	          this.map.r.render(xmlStream, text);
	        });
	      } else {
	        this.map.t.render(xmlStream, '');
	      }
	    } else if (model !== undefined && model !== null) {
	      this.map.t.render(xmlStream, model);
	    }
	    xmlStream.closeNode();
	  }

	  parseOpen(node) {
	    const {name} = node;
	    if (this.parser) {
	      this.parser.parseOpen(node);
	      return true;
	    }
	    if (name === this.tag) {
	      this.model = {};
	      return true;
	    }
	    this.parser = this.map[name];
	    if (this.parser) {
	      this.parser.parseOpen(node);
	      return true;
	    }
	    return false;
	  }

	  parseText(text) {
	    if (this.parser) {
	      this.parser.parseText(text);
	    }
	  }

	  parseClose(name) {
	    if (this.parser) {
	      if (!this.parser.parseClose(name)) {
	        switch (name) {
	          case 'r': {
	            let rt = this.model.richText;
	            if (!rt) {
	              rt = this.model.richText = [];
	            }
	            rt.push(this.parser.model);
	            break;
	          }
	          case 't':
	            this.model = this.parser.model;
	            break;
	        }
	        this.parser = undefined;
	      }
	      return true;
	    }
	    switch (name) {
	      case this.tag:
	        return false;
	      default:
	        return true;
	    }
	  }
	}

	var sharedStringXform = SharedStringXform;

	class SharedStringsXform extends baseXform {
	  constructor(model) {
	    super();

	    this.model = model || {
	      values: [],
	      count: 0,
	    };
	    this.hash = Object.create(null);
	    this.rich = Object.create(null);
	  }

	  get sharedStringXform() {
	    return this._sharedStringXform || (this._sharedStringXform = new sharedStringXform());
	  }

	  get values() {
	    return this.model.values;
	  }

	  get uniqueCount() {
	    return this.model.values.length;
	  }

	  get count() {
	    return this.model.count;
	  }

	  getString(index) {
	    return this.model.values[index];
	  }

	  add(value) {
	    return value.richText ? this.addRichText(value) : this.addText(value);
	  }

	  addText(value) {
	    let index = this.hash[value];
	    if (index === undefined) {
	      index = this.hash[value] = this.model.values.length;
	      this.model.values.push(value);
	    }
	    this.model.count++;
	    return index;
	  }

	  addRichText(value) {
	    // TODO: add WeakMap here
	    const xml = this.sharedStringXform.toXml(value);
	    let index = this.rich[xml];
	    if (index === undefined) {
	      index = this.rich[xml] = this.model.values.length;
	      this.model.values.push(value);
	    }
	    this.model.count++;
	    return index;
	  }

	  // <?xml version="1.0" encoding="UTF-8" standalone="yes"?>
	  // <sst xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" count="<%=totalRefs%>" uniqueCount="<%=count%>">
	  //   <si><t><%=text%></t></si>
	  //   <si><r><rPr></rPr><t></t></r></si>
	  // </sst>

	  render(xmlStream$1, model) {
	    model = model || this._values;
	    xmlStream$1.openXml(xmlStream.StdDocAttributes);

	    xmlStream$1.openNode('sst', {
	      xmlns: 'http://schemas.openxmlformats.org/spreadsheetml/2006/main',
	      count: model.count,
	      uniqueCount: model.values.length,
	    });

	    const sx = this.sharedStringXform;
	    model.values.forEach(sharedString => {
	      sx.render(xmlStream$1, sharedString);
	    });
	    xmlStream$1.closeNode();
	  }

	  parseOpen(node) {
	    if (this.parser) {
	      this.parser.parseOpen(node);
	      return true;
	    }
	    switch (node.name) {
	      case 'sst':
	        return true;
	      case 'si':
	        this.parser = this.sharedStringXform;
	        this.parser.parseOpen(node);
	        return true;
	      default:
	        throw new Error(`Unexpected xml node in parseOpen: ${JSON.stringify(node)}`);
	    }
	  }

	  parseText(text) {
	    if (this.parser) {
	      this.parser.parseText(text);
	    }
	  }

	  parseClose(name) {
	    if (this.parser) {
	      if (!this.parser.parseClose(name)) {
	        this.model.values.push(this.parser.model);
	        this.model.count++;
	        this.parser = undefined;
	      }
	      return true;
	    }
	    switch (name) {
	      case 'sst':
	        return false;
	      default:
	        throw new Error(`Unexpected xml node in parseClose: ${name}`);
	    }
	  }
	}

	var sharedStringsXform = SharedStringsXform;

	class RelationshipXform extends baseXform {
	  render(xmlStream, model) {
	    xmlStream.leafNode('Relationship', model);
	  }

	  parseOpen(node) {
	    switch (node.name) {
	      case 'Relationship':
	        this.model = node.attributes;
	        return true;
	      default:
	        return false;
	    }
	  }

	  parseText() {}

	  parseClose() {
	    return false;
	  }
	}

	var relationshipXform = RelationshipXform;

	class RelationshipsXform extends baseXform {
	  constructor() {
	    super();

	    this.map = {
	      Relationship: new relationshipXform(),
	    };
	  }

	  render(xmlStream$1, model) {
	    model = model || this._values;
	    xmlStream$1.openXml(xmlStream.StdDocAttributes);
	    xmlStream$1.openNode('Relationships', RelationshipsXform.RELATIONSHIPS_ATTRIBUTES);

	    model.forEach(relationship => {
	      this.map.Relationship.render(xmlStream$1, relationship);
	    });

	    xmlStream$1.closeNode();
	  }

	  parseOpen(node) {
	    if (this.parser) {
	      this.parser.parseOpen(node);
	      return true;
	    }
	    switch (node.name) {
	      case 'Relationships':
	        this.model = [];
	        return true;
	      default:
	        this.parser = this.map[node.name];
	        if (this.parser) {
	          this.parser.parseOpen(node);
	          return true;
	        }
	        throw new Error(`Unexpected xml node in parseOpen: ${JSON.stringify(node)}`);
	    }
	  }

	  parseText(text) {
	    if (this.parser) {
	      this.parser.parseText(text);
	    }
	  }

	  parseClose(name) {
	    if (this.parser) {
	      if (!this.parser.parseClose(name)) {
	        this.model.push(this.parser.model);
	        this.parser = undefined;
	      }
	      return true;
	    }
	    switch (name) {
	      case 'Relationships':
	        return false;
	      default:
	        throw new Error(`Unexpected xml node in parseClose: ${name}`);
	    }
	  }
	}

	RelationshipsXform.RELATIONSHIPS_ATTRIBUTES = {
	  xmlns: 'http://schemas.openxmlformats.org/package/2006/relationships',
	};

	var relationshipsXform = RelationshipsXform;

	// used for rendering the [Content_Types].xml file
	// not used for parsing
	class ContentTypesXform extends baseXform {
	  render(xmlStream$1, model) {
	    xmlStream$1.openXml(xmlStream.StdDocAttributes);

	    xmlStream$1.openNode('Types', ContentTypesXform.PROPERTY_ATTRIBUTES);

	    const mediaHash = {};
	    (model.media || []).forEach(medium => {
	      if (medium.type === 'image') {
	        const imageType = medium.extension;
	        if (!mediaHash[imageType]) {
	          mediaHash[imageType] = true;
	          xmlStream$1.leafNode('Default', {Extension: imageType, ContentType: `image/${imageType}`});
	        }
	      }
	    });

	    xmlStream$1.leafNode('Default', {
	      Extension: 'rels',
	      ContentType: 'application/vnd.openxmlformats-package.relationships+xml',
	    });
	    xmlStream$1.leafNode('Default', {Extension: 'xml', ContentType: 'application/xml'});

	    xmlStream$1.leafNode('Override', {
	      PartName: '/xl/workbook.xml',
	      ContentType: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml',
	    });

	    model.worksheets.forEach(worksheet => {
	      const name = `/xl/worksheets/sheet${worksheet.id}.xml`;
	      xmlStream$1.leafNode('Override', {
	        PartName: name,
	        ContentType: 'application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml',
	      });
	    });

	    xmlStream$1.leafNode('Override', {
	      PartName: '/xl/theme/theme1.xml',
	      ContentType: 'application/vnd.openxmlformats-officedocument.theme+xml',
	    });
	    xmlStream$1.leafNode('Override', {
	      PartName: '/xl/styles.xml',
	      ContentType: 'application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml',
	    });

	    const hasSharedStrings = model.sharedStrings && model.sharedStrings.count;
	    if (hasSharedStrings) {
	      xmlStream$1.leafNode('Override', {
	        PartName: '/xl/sharedStrings.xml',
	        ContentType:
	          'application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml',
	      });
	    }

	    if (model.tables) {
	      model.tables.forEach(table => {
	        xmlStream$1.leafNode('Override', {
	          PartName: `/xl/tables/${table.target}`,
	          ContentType: 'application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml',
	        });
	      });
	    }

	    if (model.drawings) {
	      model.drawings.forEach(drawing => {
	        xmlStream$1.leafNode('Override', {
	          PartName: `/xl/drawings/${drawing.name}.xml`,
	          ContentType: 'application/vnd.openxmlformats-officedocument.drawing+xml',
	        });
	      });
	    }

	    if (model.commentRefs) {
	      xmlStream$1.leafNode('Default', {
	        Extension: 'vml',
	        ContentType: 'application/vnd.openxmlformats-officedocument.vmlDrawing',
	      });

	      model.commentRefs.forEach(({commentName}) => {
	        xmlStream$1.leafNode('Override', {
	          PartName: `/xl/${commentName}.xml`,
	          ContentType: 'application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml',
	        });
	      });
	    }

	    xmlStream$1.leafNode('Override', {
	      PartName: '/docProps/core.xml',
	      ContentType: 'application/vnd.openxmlformats-package.core-properties+xml',
	    });
	    xmlStream$1.leafNode('Override', {
	      PartName: '/docProps/app.xml',
	      ContentType: 'application/vnd.openxmlformats-officedocument.extended-properties+xml',
	    });

	    xmlStream$1.closeNode();
	  }

	  parseOpen() {
	    return false;
	  }

	  parseText() {}

	  parseClose() {
	    return false;
	  }
	}

	ContentTypesXform.PROPERTY_ATTRIBUTES = {
	  xmlns: 'http://schemas.openxmlformats.org/package/2006/content-types',
	};

	var contentTypesXform = ContentTypesXform;

	class AppHeadingPairsXform extends baseXform {
	  render(xmlStream, model) {
	    xmlStream.openNode('HeadingPairs');
	    xmlStream.openNode('vt:vector', {size: 2, baseType: 'variant'});

	    xmlStream.openNode('vt:variant');
	    xmlStream.leafNode('vt:lpstr', undefined, 'Worksheets');
	    xmlStream.closeNode();

	    xmlStream.openNode('vt:variant');
	    xmlStream.leafNode('vt:i4', undefined, model.length);
	    xmlStream.closeNode();

	    xmlStream.closeNode();
	    xmlStream.closeNode();
	  }

	  parseOpen(node) {
	    // no parsing
	    return node.name === 'HeadingPairs';
	  }

	  parseText() {}

	  parseClose(name) {
	    return name !== 'HeadingPairs';
	  }
	}

	var appHeadingPairsXform = AppHeadingPairsXform;

	class AppTitlesOfPartsXform extends baseXform {
	  render(xmlStream, model) {
	    xmlStream.openNode('TitlesOfParts');
	    xmlStream.openNode('vt:vector', {size: model.length, baseType: 'lpstr'});

	    model.forEach(sheet => {
	      xmlStream.leafNode('vt:lpstr', undefined, sheet.name);
	    });

	    xmlStream.closeNode();
	    xmlStream.closeNode();
	  }

	  parseOpen(node) {
	    // no parsing
	    return node.name === 'TitlesOfParts';
	  }

	  parseText() {}

	  parseClose(name) {
	    return name !== 'TitlesOfParts';
	  }
	}

	var appTitlesOfPartsXform = AppTitlesOfPartsXform;

	class AppXform extends baseXform {
	  constructor() {
	    super();

	    this.map = {
	      Company: new stringXform({tag: 'Company'}),
	      Manager: new stringXform({tag: 'Manager'}),
	      HeadingPairs: new appHeadingPairsXform(),
	      TitleOfParts: new appTitlesOfPartsXform(),
	    };
	  }

	  render(xmlStream$1, model) {
	    xmlStream$1.openXml(xmlStream.StdDocAttributes);

	    xmlStream$1.openNode('Properties', AppXform.PROPERTY_ATTRIBUTES);

	    xmlStream$1.leafNode('Application', undefined, 'Microsoft Excel');
	    xmlStream$1.leafNode('DocSecurity', undefined, '0');
	    xmlStream$1.leafNode('ScaleCrop', undefined, 'false');

	    this.map.HeadingPairs.render(xmlStream$1, model.worksheets);
	    this.map.TitleOfParts.render(xmlStream$1, model.worksheets);
	    this.map.Company.render(xmlStream$1, model.company || '');
	    this.map.Manager.render(xmlStream$1, model.manager);

	    xmlStream$1.leafNode('LinksUpToDate', undefined, 'false');
	    xmlStream$1.leafNode('SharedDoc', undefined, 'false');
	    xmlStream$1.leafNode('HyperlinksChanged', undefined, 'false');
	    xmlStream$1.leafNode('AppVersion', undefined, '16.0300');

	    xmlStream$1.closeNode();
	  }

	  parseOpen(node) {
	    if (this.parser) {
	      this.parser.parseOpen(node);
	      return true;
	    }
	    switch (node.name) {
	      case 'Properties':
	        return true;
	      default:
	        this.parser = this.map[node.name];
	        if (this.parser) {
	          this.parser.parseOpen(node);
	          return true;
	        }

	        // there's a lot we don't bother to parse
	        return false;
	    }
	  }

	  parseText(text) {
	    if (this.parser) {
	      this.parser.parseText(text);
	    }
	  }

	  parseClose(name) {
	    if (this.parser) {
	      if (!this.parser.parseClose(name)) {
	        this.parser = undefined;
	      }
	      return true;
	    }
	    switch (name) {
	      case 'Properties':
	        this.model = {
	          worksheets: this.map.TitleOfParts.model,
	          company: this.map.Company.model,
	          manager: this.map.Manager.model,
	        };
	        return false;
	      default:
	        return true;
	    }
	  }
	}

	AppXform.DateFormat = function(dt) {
	  return dt.toISOString().replace(/[.]\d{3,6}/, '');
	};

	AppXform.DateAttrs = {'xsi:type': 'dcterms:W3CDTF'};

	AppXform.PROPERTY_ATTRIBUTES = {
	  xmlns: 'http://schemas.openxmlformats.org/officeDocument/2006/extended-properties',
	  'xmlns:vt': 'http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes',
	};

	var appXform = AppXform;

	class DefinedNamesXform extends baseXform {
	  render(xmlStream, model) {
	    // <definedNames>
	    //   <definedName name="name">name.ranges.join(',')</definedName>
	    //   <definedName name="_xlnm.Print_Area" localSheetId="0">name.ranges.join(',')</definedName>
	    // </definedNames>
	    xmlStream.openNode('definedName', {
	      name: model.name,
	      localSheetId: model.localSheetId,
	    });
	    xmlStream.writeText(model.ranges.join(','));
	    xmlStream.closeNode();
	  }

	  parseOpen(node) {
	    switch (node.name) {
	      case 'definedName':
	        this._parsedName = node.attributes.name;
	        this._parsedLocalSheetId = node.attributes.localSheetId;
	        this._parsedText = [];
	        return true;
	      default:
	        return false;
	    }
	  }

	  parseText(text) {
	    this._parsedText.push(text);
	  }

	  parseClose() {
	    this.model = {
	      name: this._parsedName,
	      ranges: extractRanges(this._parsedText.join('')),
	    };
	    if (this._parsedLocalSheetId !== undefined) {
	      this.model.localSheetId = parseInt(this._parsedLocalSheetId, 10);
	    }
	    return false;
	  }
	}

	function isValidRange(range) {
	  try {
	    colCache_1.decodeEx(range);
	    return true;
	  } catch (err) {
	    return false;
	  }
	}

	function extractRanges(parsedText) {
	  const ranges = [];
	  let quotesOpened = false;
	  let last = '';
	  parsedText.split(',').forEach(item => {
	    if (!item) {
	      return;
	    }
	    const quotes = (item.match(/'/g) || []).length;

	    if (!quotes) {
	      if (quotesOpened) {
	        last += `${item},`;
	      } else if (isValidRange(item)) {
	        ranges.push(item);
	      }
	      return;
	    }
	    const quotesEven = quotes % 2 === 0;

	    if (!quotesOpened && quotesEven && isValidRange(item)) {
	      ranges.push(item);
	    } else if (quotesOpened && !quotesEven) {
	      quotesOpened = false;
	      if (isValidRange(last + item)) {
	        ranges.push(last + item);
	      }
	      last = '';
	    } else {
	      quotesOpened = true;
	      last += `${item},`;
	    }
	  });
	  return ranges;
	}

	var definedNameXform = DefinedNamesXform;

	class WorksheetXform extends baseXform {
	  render(xmlStream, model) {
	    xmlStream.leafNode('sheet', {
	      sheetId: model.id,
	      name: model.name,
	      state: model.state,
	      'r:id': model.rId,
	    });
	  }

	  parseOpen(node) {
	    if (node.name === 'sheet') {
	      this.model = {
	        name: utils_1.xmlDecode(node.attributes.name),
	        id: parseInt(node.attributes.sheetId, 10),
	        state: node.attributes.state,
	        rId: node.attributes['r:id'],
	      };
	      return true;
	    }
	    return false;
	  }

	  parseText() {}

	  parseClose() {
	    return false;
	  }
	}

	var sheetXform = WorksheetXform;

	class WorkbookViewXform extends baseXform {
	  render(xmlStream, model) {
	    const attributes = {
	      xWindow: model.x || 0,
	      yWindow: model.y || 0,
	      windowWidth: model.width || 12000,
	      windowHeight: model.height || 24000,
	      firstSheet: model.firstSheet,
	      activeTab: model.activeTab,
	    };
	    if (model.visibility && model.visibility !== 'visible') {
	      attributes.visibility = model.visibility;
	    }
	    xmlStream.leafNode('workbookView', attributes);
	  }

	  parseOpen(node) {
	    if (node.name === 'workbookView') {
	      const model = (this.model = {});
	      const addS = function(name, value, dflt) {
	        const s = value !== undefined ? (model[name] = value) : dflt;
	        if (s !== undefined) {
	          model[name] = s;
	        }
	      };
	      const addN = function(name, value, dflt) {
	        const n = value !== undefined ? (model[name] = parseInt(value, 10)) : dflt;
	        if (n !== undefined) {
	          model[name] = n;
	        }
	      };
	      addN('x', node.attributes.xWindow, 0);
	      addN('y', node.attributes.yWindow, 0);
	      addN('width', node.attributes.windowWidth, 25000);
	      addN('height', node.attributes.windowHeight, 10000);
	      addS('visibility', node.attributes.visibility, 'visible');
	      addN('activeTab', node.attributes.activeTab, undefined);
	      addN('firstSheet', node.attributes.firstSheet, undefined);
	      return true;
	    }
	    return false;
	  }

	  parseText() {}

	  parseClose() {
	    return false;
	  }
	}

	var workbookViewXform = WorkbookViewXform;

	class WorksheetPropertiesXform extends baseXform {
	  render(xmlStream, model) {
	    xmlStream.leafNode('workbookPr', {
	      date1904: model.date1904 ? 1 : undefined,
	      defaultThemeVersion: 164011,
	      filterPrivacy: 1,
	    });
	  }

	  parseOpen(node) {
	    if (node.name === 'workbookPr') {
	      this.model = {
	        date1904: node.attributes.date1904 === '1',
	      };
	      return true;
	    }
	    return false;
	  }

	  parseText() {}

	  parseClose() {
	    return false;
	  }
	}

	var workbookPropertiesXform = WorksheetPropertiesXform;

	class WorkbookCalcPropertiesXform extends baseXform {
	  render(xmlStream, model) {
	    xmlStream.leafNode('calcPr', {
	      calcId: 171027,
	      fullCalcOnLoad: model.fullCalcOnLoad ? 1 : undefined,
	    });
	  }

	  parseOpen(node) {
	    if (node.name === 'calcPr') {
	      this.model = {};
	      return true;
	    }
	    return false;
	  }

	  parseText() {}

	  parseClose() {
	    return false;
	  }
	}

	var workbookCalcPropertiesXform = WorkbookCalcPropertiesXform;

	class WorkbookXform extends baseXform {
	  constructor() {
	    super();

	    this.map = {
	      fileVersion: WorkbookXform.STATIC_XFORMS.fileVersion,
	      workbookPr: new workbookPropertiesXform(),
	      bookViews: new listXform({
	        tag: 'bookViews',
	        count: false,
	        childXform: new workbookViewXform(),
	      }),
	      sheets: new listXform({tag: 'sheets', count: false, childXform: new sheetXform()}),
	      definedNames: new listXform({
	        tag: 'definedNames',
	        count: false,
	        childXform: new definedNameXform(),
	      }),
	      calcPr: new workbookCalcPropertiesXform(),
	    };
	  }

	  prepare(model) {
	    model.sheets = model.worksheets;

	    // collate all the print areas from all of the sheets and add them to the defined names
	    const printAreas = [];
	    let index = 0; // sheets is sparse array - calc index manually
	    model.sheets.forEach(sheet => {
	      if (sheet.pageSetup && sheet.pageSetup.printArea) {
	        sheet.pageSetup.printArea.split('&&').forEach(printArea => {
	          const printAreaComponents = printArea.split(':');
	          const definedName = {
	            name: '_xlnm.Print_Area',
	            ranges: [`'${sheet.name}'!$${printAreaComponents[0]}:$${printAreaComponents[1]}`],
	            localSheetId: index,
	          };
	          printAreas.push(definedName);
	        });
	      }

	      if (
	        sheet.pageSetup &&
	        (sheet.pageSetup.printTitlesRow || sheet.pageSetup.printTitlesColumn)
	      ) {
	        const ranges = [];

	        if (sheet.pageSetup.printTitlesColumn) {
	          const titlesColumns = sheet.pageSetup.printTitlesColumn.split(':');
	          ranges.push(`'${sheet.name}'!$${titlesColumns[0]}:$${titlesColumns[1]}`);
	        }

	        if (sheet.pageSetup.printTitlesRow) {
	          const titlesRows = sheet.pageSetup.printTitlesRow.split(':');
	          ranges.push(`'${sheet.name}'!$${titlesRows[0]}:$${titlesRows[1]}`);
	        }

	        const definedName = {
	          name: '_xlnm.Print_Titles',
	          ranges,
	          localSheetId: index,
	        };

	        printAreas.push(definedName);
	      }
	      index++;
	    });
	    if (printAreas.length) {
	      model.definedNames = model.definedNames.concat(printAreas);
	    }

	    (model.media || []).forEach((medium, i) => {
	      // assign name
	      medium.name = medium.type + (i + 1);
	    });
	  }

	  render(xmlStream$1, model) {
	    xmlStream$1.openXml(xmlStream.StdDocAttributes);
	    xmlStream$1.openNode('workbook', WorkbookXform.WORKBOOK_ATTRIBUTES);

	    this.map.fileVersion.render(xmlStream$1);
	    this.map.workbookPr.render(xmlStream$1, model.properties);
	    this.map.bookViews.render(xmlStream$1, model.views);
	    this.map.sheets.render(xmlStream$1, model.sheets);
	    this.map.definedNames.render(xmlStream$1, model.definedNames);
	    this.map.calcPr.render(xmlStream$1, model.calcProperties);

	    xmlStream$1.closeNode();
	  }

	  parseOpen(node) {
	    if (this.parser) {
	      this.parser.parseOpen(node);
	      return true;
	    }
	    switch (node.name) {
	      case 'workbook':
	        return true;
	      default:
	        this.parser = this.map[node.name];
	        if (this.parser) {
	          this.parser.parseOpen(node);
	        }
	        return true;
	    }
	  }

	  parseText(text) {
	    if (this.parser) {
	      this.parser.parseText(text);
	    }
	  }

	  parseClose(name) {
	    if (this.parser) {
	      if (!this.parser.parseClose(name)) {
	        this.parser = undefined;
	      }
	      return true;
	    }
	    switch (name) {
	      case 'workbook':
	        this.model = {
	          sheets: this.map.sheets.model,
	          properties: this.map.workbookPr.model || {},
	          views: this.map.bookViews.model,
	          calcProperties: {},
	        };
	        if (this.map.definedNames.model) {
	          this.model.definedNames = this.map.definedNames.model;
	        }

	        return false;
	      default:
	        // not quite sure how we get here!
	        return true;
	    }
	  }

	  reconcile(model) {
	    const rels = (model.workbookRels || []).reduce((map, rel) => {
	      map[rel.Id] = rel;
	      return map;
	    }, {});

	    // reconcile sheet ids, rIds and names
	    const worksheets = [];
	    let worksheet;
	    let index = 0;

	    (model.sheets || []).forEach(sheet => {
	      const rel = rels[sheet.rId];
	      if (!rel) {
	        return;
	      }
	      // if rel.Target start with `[space]/xl/` or `/xl/` , then it will be replaced with `''` and spliced behind `xl/`,
	      // otherwise it will be spliced directly behind `xl/`. i.g.
	      worksheet = model.worksheetHash[`xl/${rel.Target.replace(/^(\s|\/xl\/)+/, '')}`];
	      // If there are "chartsheets" in the file, rel.Target will
	      // come out as chartsheets/sheet1.xml or similar here, and
	      // that won't be in model.worksheetHash.
	      // As we don't have the infrastructure to support chartsheets,
	      // we will ignore them for now:
	      if (worksheet) {
	        worksheet.name = sheet.name;
	        worksheet.id = sheet.id;
	        worksheet.state = sheet.state;
	        worksheets[index++] = worksheet;
	      }
	    });

	    // reconcile print areas
	    const definedNames = [];
	    underDash.each(model.definedNames, definedName => {
	      if (definedName.name === '_xlnm.Print_Area') {
	        worksheet = worksheets[definedName.localSheetId];
	        if (worksheet) {
	          if (!worksheet.pageSetup) {
	            worksheet.pageSetup = {};
	          }
	          const range = colCache_1.decodeEx(definedName.ranges[0]);
	          worksheet.pageSetup.printArea = worksheet.pageSetup.printArea
	            ? `${worksheet.pageSetup.printArea}&&${range.dimensions}`
	            : range.dimensions;
	        }
	      } else if (definedName.name === '_xlnm.Print_Titles') {
	        worksheet = worksheets[definedName.localSheetId];
	        if (worksheet) {
	          if (!worksheet.pageSetup) {
	            worksheet.pageSetup = {};
	          }

	          const rangeString = definedName.ranges.join(',');

	          const dollarRegex = /\$/g;

	          const rowRangeRegex = /\$\d+:\$\d+/;
	          const rowRangeMatches = rangeString.match(rowRangeRegex);

	          if (rowRangeMatches && rowRangeMatches.length) {
	            const range = rowRangeMatches[0];
	            worksheet.pageSetup.printTitlesRow = range.replace(dollarRegex, '');
	          }

	          const columnRangeRegex = /\$[A-Z]+:\$[A-Z]+/;
	          const columnRangeMatches = rangeString.match(columnRangeRegex);

	          if (columnRangeMatches && columnRangeMatches.length) {
	            const range = columnRangeMatches[0];
	            worksheet.pageSetup.printTitlesColumn = range.replace(dollarRegex, '');
	          }
	        }
	      } else {
	        definedNames.push(definedName);
	      }
	    });
	    model.definedNames = definedNames;

	    // used by sheets to build their image models
	    model.media.forEach((media, i) => {
	      media.index = i;
	    });
	  }
	}

	WorkbookXform.WORKBOOK_ATTRIBUTES = {
	  xmlns: 'http://schemas.openxmlformats.org/spreadsheetml/2006/main',
	  'xmlns:r': 'http://schemas.openxmlformats.org/officeDocument/2006/relationships',
	  'xmlns:mc': 'http://schemas.openxmlformats.org/markup-compatibility/2006',
	  'mc:Ignorable': 'x15',
	  'xmlns:x15': 'http://schemas.microsoft.com/office/spreadsheetml/2010/11/main',
	};
	WorkbookXform.STATIC_XFORMS = {
	  fileVersion: new staticXform({
	    tag: 'fileVersion',
	    $: {appName: 'xl', lastEdited: 5, lowestEdited: 5, rupBuild: 9303},
	  }),
	};

	var workbookXform = WorkbookXform;

	var relType = {
	  OfficeDocument:
	    'http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument',
	  Worksheet: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet',
	  CalcChain: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/calcChain',
	  SharedStrings:
	    'http://schemas.openxmlformats.org/officeDocument/2006/relationships/sharedStrings',
	  Styles: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles',
	  Theme: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme',
	  Hyperlink: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink',
	  Image: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/image',
	  CoreProperties:
	    'http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties',
	  ExtenderProperties:
	    'http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties',
	  Comments: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/comments',
	  VmlDrawing: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/vmlDrawing',
	  Table: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/table',
	};

	class Merges {
	  constructor() {
	    // optional mergeCells is array of ranges (like the xml)
	    this.merges = {};
	  }

	  add(merge) {
	    // merge is {address, master}
	    if (this.merges[merge.master]) {
	      this.merges[merge.master].expandToAddress(merge.address);
	    } else {
	      const range$1 = `${merge.master}:${merge.address}`;
	      this.merges[merge.master] = new range(range$1);
	    }
	  }

	  get mergeCells() {
	    return underDash.map(this.merges, merge => merge.range);
	  }

	  reconcile(mergeCells, rows) {
	    // reconcile merge list with merge cells
	    underDash.each(mergeCells, merge => {
	      const dimensions = colCache_1.decode(merge);
	      for (let i = dimensions.top; i <= dimensions.bottom; i++) {
	        const row = rows[i - 1];
	        for (let j = dimensions.left; j <= dimensions.right; j++) {
	          const cell = row.cells[j - 1];
	          if (!cell) {
	            // nulls are not included in document - so if master cell has no value - add a null one here
	            row.cells[j] = {
	              type: enums.ValueType.Null,
	              address: colCache_1.encodeAddress(i, j),
	            };
	          } else if (cell.type === enums.ValueType.Merge) {
	            cell.master = dimensions.tl;
	          }
	        }
	      }
	    });
	  }

	  getMasterAddress(address) {
	    // if address has been merged, return its master's address. Assumes reconcile has been called
	    const range = this.hash[address];
	    return range && range.tl;
	  }
	}

	var merges = Merges;

	function getValueType(v) {
	  if (v === null || v === undefined) {
	    return enums.ValueType.Null;
	  }
	  if (v instanceof String || typeof v === 'string') {
	    return enums.ValueType.String;
	  }
	  if (typeof v === 'number') {
	    return enums.ValueType.Number;
	  }
	  if (typeof v === 'boolean') {
	    return enums.ValueType.Boolean;
	  }
	  if (v instanceof Date) {
	    return enums.ValueType.Date;
	  }
	  if (v.text && v.hyperlink) {
	    return enums.ValueType.Hyperlink;
	  }
	  if (v.formula) {
	    return enums.ValueType.Formula;
	  }
	  if (v.error) {
	    return enums.ValueType.Error;
	  }
	  throw new Error('I could not understand type of value');
	}

	function getEffectiveCellType(cell) {
	  switch (cell.type) {
	    case enums.ValueType.Formula:
	      return getValueType(cell.result);
	    default:
	      return cell.type;
	  }
	}

	class CellXform extends baseXform {
	  constructor() {
	    super();

	    this.richTextXForm = new richTextXform();
	  }

	  get tag() {
	    return 'c';
	  }

	  prepare(model, options) {
	    const styleId = options.styles.addStyleModel(model.style || {}, getEffectiveCellType(model));
	    if (styleId) {
	      model.styleId = styleId;
	    }

	    if (model.comment) {
	      options.comments.push({...model.comment, ref: model.address});
	    }

	    switch (model.type) {
	      case enums.ValueType.String:
	      case enums.ValueType.RichText:
	        if (options.sharedStrings) {
	          model.ssId = options.sharedStrings.add(model.value);
	        }
	        break;

	      case enums.ValueType.Date:
	        if (options.date1904) {
	          model.date1904 = true;
	        }
	        break;

	      case enums.ValueType.Hyperlink:
	        if (options.sharedStrings && model.text !== undefined && model.text !== null) {
	          model.ssId = options.sharedStrings.add(model.text);
	        }
	        options.hyperlinks.push({
	          address: model.address,
	          target: model.hyperlink,
	          tooltip: model.tooltip,
	        });
	        break;

	      case enums.ValueType.Merge:
	        options.merges.add(model);
	        break;

	      case enums.ValueType.Formula:
	        if (options.date1904) {
	          // in case valueType is date
	          model.date1904 = true;
	        }

	        if (model.shareType === 'shared') {
	          model.si = options.siFormulae++;
	        }

	        if (model.formula) {
	          options.formulae[model.address] = model;
	        } else if (model.sharedFormula) {
	          const master = options.formulae[model.sharedFormula];
	          if (!master) {
	            throw new Error(
	              `Shared Formula master must exist above and or left of clone for cell ${model.address}`
	            );
	          }
	          if (master.si === undefined) {
	            master.shareType = 'shared';
	            master.si = options.siFormulae++;
	            master.range = new range(master.address, model.address);
	          } else if (master.range) {
	            master.range.expandToAddress(model.address);
	          }
	          model.si = master.si;
	        }
	        break;
	    }
	  }

	  renderFormula(xmlStream, model) {
	    let attrs = null;
	    switch (model.shareType) {
	      case 'shared':
	        attrs = {
	          t: 'shared',
	          ref: model.ref || model.range.range,
	          si: model.si,
	        };
	        break;

	      case 'array':
	        attrs = {
	          t: 'array',
	          ref: model.ref,
	        };
	        break;

	      default:
	        if (model.si !== undefined) {
	          attrs = {
	            t: 'shared',
	            si: model.si,
	          };
	        }
	        break;
	    }

	    switch (getValueType(model.result)) {
	      case enums.ValueType.Null: // ?
	        xmlStream.leafNode('f', attrs, model.formula);
	        break;

	      case enums.ValueType.String:
	        // oddly, formula results don't ever use shared strings
	        xmlStream.addAttribute('t', 'str');
	        xmlStream.leafNode('f', attrs, model.formula);
	        xmlStream.leafNode('v', null, model.result);
	        break;

	      case enums.ValueType.Number:
	        xmlStream.leafNode('f', attrs, model.formula);
	        xmlStream.leafNode('v', null, model.result);
	        break;

	      case enums.ValueType.Boolean:
	        xmlStream.addAttribute('t', 'b');
	        xmlStream.leafNode('f', attrs, model.formula);
	        xmlStream.leafNode('v', null, model.result ? 1 : 0);
	        break;

	      case enums.ValueType.Error:
	        xmlStream.addAttribute('t', 'e');
	        xmlStream.leafNode('f', attrs, model.formula);
	        xmlStream.leafNode('v', null, model.result.error);
	        break;

	      case enums.ValueType.Date:
	        xmlStream.leafNode('f', attrs, model.formula);
	        xmlStream.leafNode('v', null, utils_1.dateToExcel(model.result, model.date1904));
	        break;

	      // case Enums.ValueType.Hyperlink: // ??
	      // case Enums.ValueType.Formula:
	      default:
	        throw new Error('I could not understand type of value');
	    }
	  }

	  render(xmlStream, model) {
	    if (model.type === enums.ValueType.Null && !model.styleId) {
	      // if null and no style, exit
	      return;
	    }

	    xmlStream.openNode('c');
	    xmlStream.addAttribute('r', model.address);

	    if (model.styleId) {
	      xmlStream.addAttribute('s', model.styleId);
	    }

	    switch (model.type) {
	      case enums.ValueType.Null:
	        break;

	      case enums.ValueType.Number:
	        xmlStream.leafNode('v', null, model.value);
	        break;

	      case enums.ValueType.Boolean:
	        xmlStream.addAttribute('t', 'b');
	        xmlStream.leafNode('v', null, model.value ? '1' : '0');
	        break;

	      case enums.ValueType.Error:
	        xmlStream.addAttribute('t', 'e');
	        xmlStream.leafNode('v', null, model.value.error);
	        break;

	      case enums.ValueType.String:
	      case enums.ValueType.RichText:
	        if (model.ssId !== undefined) {
	          xmlStream.addAttribute('t', 's');
	          xmlStream.leafNode('v', null, model.ssId);
	        } else if (model.value && model.value.richText) {
	          xmlStream.addAttribute('t', 'inlineStr');
	          xmlStream.openNode('is');
	          model.value.richText.forEach(text => {
	            this.richTextXForm.render(xmlStream, text);
	          });
	          xmlStream.closeNode('is');
	        } else {
	          xmlStream.addAttribute('t', 'str');
	          xmlStream.leafNode('v', null, model.value);
	        }
	        break;

	      case enums.ValueType.Date:
	        xmlStream.leafNode('v', null, utils_1.dateToExcel(model.value, model.date1904));
	        break;

	      case enums.ValueType.Hyperlink:
	        if (model.ssId !== undefined) {
	          xmlStream.addAttribute('t', 's');
	          xmlStream.leafNode('v', null, model.ssId);
	        } else {
	          xmlStream.addAttribute('t', 'str');
	          xmlStream.leafNode('v', null, model.text);
	        }
	        break;

	      case enums.ValueType.Formula:
	        this.renderFormula(xmlStream, model);
	        break;

	      case enums.ValueType.Merge:
	        // nothing to add
	        break;
	    }

	    xmlStream.closeNode(); // </c>
	  }

	  parseOpen(node) {
	    if (this.parser) {
	      this.parser.parseOpen(node);
	      return true;
	    }
	    switch (node.name) {
	      case 'c':
	        // const address = colCache.decodeAddress(node.attributes.r);
	        this.model = {
	          address: node.attributes.r,
	        };
	        this.t = node.attributes.t;
	        if (node.attributes.s) {
	          this.model.styleId = parseInt(node.attributes.s, 10);
	        }
	        return true;

	      case 'f':
	        this.currentNode = 'f';
	        this.model.si = node.attributes.si;
	        this.model.shareType = node.attributes.t;
	        this.model.ref = node.attributes.ref;
	        return true;

	      case 'v':
	        this.currentNode = 'v';
	        return true;

	      case 't':
	        this.currentNode = 't';
	        return true;

	      case 'r':
	        this.parser = this.richTextXForm;
	        this.parser.parseOpen(node);
	        return true;

	      default:
	        return false;
	    }
	  }

	  parseText(text) {
	    if (this.parser) {
	      this.parser.parseText(text);
	      return;
	    }
	    switch (this.currentNode) {
	      case 'f':
	        this.model.formula = this.model.formula ? this.model.formula + text : text;
	        break;
	      case 'v':
	      case 't':
	        if (this.model.value && this.model.value.richText) {
	          this.model.value.richText.text = this.model.value.richText.text
	            ? this.model.value.richText.text + text
	            : text;
	        } else {
	          this.model.value = this.model.value ? this.model.value + text : text;
	        }
	        break;
	    }
	  }

	  parseClose(name) {
	    switch (name) {
	      case 'c': {
	        const {model} = this;

	        // first guess on cell type
	        if (model.formula || model.shareType) {
	          model.type = enums.ValueType.Formula;
	          if (model.value) {
	            if (this.t === 'str') {
	              model.result = utils_1.xmlDecode(model.value);
	            } else if (this.t === 'b') {
	              model.result = parseInt(model.value, 10) !== 0;
	            } else if (this.t === 'e') {
	              model.result = {error: model.value};
	            } else {
	              model.result = parseFloat(model.value);
	            }
	            model.value = undefined;
	          }
	        } else if (model.value !== undefined) {
	          switch (this.t) {
	            case 's':
	              model.type = enums.ValueType.String;
	              model.value = parseInt(model.value, 10);
	              break;
	            case 'str':
	              model.type = enums.ValueType.String;
	              model.value = utils_1.xmlDecode(model.value);
	              break;
	            case 'inlineStr':
	              model.type = enums.ValueType.String;
	              break;
	            case 'b':
	              model.type = enums.ValueType.Boolean;
	              model.value = parseInt(model.value, 10) !== 0;
	              break;
	            case 'e':
	              model.type = enums.ValueType.Error;
	              model.value = {error: model.value};
	              break;
	            default:
	              model.type = enums.ValueType.Number;
	              model.value = parseFloat(model.value);
	              break;
	          }
	        } else if (model.styleId) {
	          model.type = enums.ValueType.Null;
	        } else {
	          model.type = enums.ValueType.Merge;
	        }
	        return false;
	      }

	      case 'f':
	      case 'v':
	      case 'is':
	        this.currentNode = undefined;
	        return true;

	      case 't':
	        if (this.parser) {
	          this.parser.parseClose(name);
	          return true;
	        }
	        this.currentNode = undefined;
	        return true;

	      case 'r':
	        this.model.value = this.model.value || {};
	        this.model.value.richText = this.model.value.richText || [];
	        this.model.value.richText.push(this.parser.model);
	        this.parser = undefined;
	        this.currentNode = undefined;
	        return true;

	      default:
	        if (this.parser) {
	          this.parser.parseClose(name);
	          return true;
	        }
	        return false;
	    }
	  }

	  reconcile(model, options) {
	    const style = model.styleId && options.styles && options.styles.getStyleModel(model.styleId);
	    if (style) {
	      model.style = style;
	    }
	    if (model.styleId !== undefined) {
	      model.styleId = undefined;
	    }

	    switch (model.type) {
	      case enums.ValueType.String:
	        if (typeof model.value === 'number') {
	          if (options.sharedStrings) {
	            model.value = options.sharedStrings.getString(model.value);
	          }
	        }
	        if (model.value.richText) {
	          model.type = enums.ValueType.RichText;
	        }
	        break;

	      case enums.ValueType.Number:
	        if (style && utils_1.isDateFmt(style.numFmt)) {
	          model.type = enums.ValueType.Date;
	          model.value = utils_1.excelToDate(model.value, options.date1904);
	        }
	        break;

	      case enums.ValueType.Formula:
	        if (model.result !== undefined && style && utils_1.isDateFmt(style.numFmt)) {
	          model.result = utils_1.excelToDate(model.result, options.date1904);
	        }
	        if (model.shareType === 'shared') {
	          if (model.ref) {
	            // master
	            options.formulae[model.si] = model.address;
	          } else {
	            // slave
	            model.sharedFormula = options.formulae[model.si];
	            delete model.shareType;
	          }
	          delete model.si;
	        }
	        break;
	    }

	    // look for hyperlink
	    const hyperlink = options.hyperlinkMap[model.address];
	    if (hyperlink) {
	      if (model.type === enums.ValueType.Formula) {
	        model.text = model.result;
	        model.result = undefined;
	      } else {
	        model.text = model.value;
	        model.value = undefined;
	      }
	      model.type = enums.ValueType.Hyperlink;
	      model.hyperlink = hyperlink;
	    }

	    const comment = options.commentsMap && options.commentsMap[model.address];
	    if (comment) {
	      model.comment = comment;
	    }
	  }
	}

	var cellXform = CellXform;

	class RowXform extends baseXform {
	  constructor(options) {
	    super();

	    this.maxItems = options && options.maxItems;
	    this.map = {
	      c: new cellXform(),
	    };
	  }

	  get tag() {
	    return 'row';
	  }

	  prepare(model, options) {
	    const styleId = options.styles.addStyleModel(model.style);
	    if (styleId) {
	      model.styleId = styleId;
	    }
	    const cellXform = this.map.c;
	    model.cells.forEach(cellModel => {
	      cellXform.prepare(cellModel, options);
	    });
	  }

	  render(xmlStream, model, options) {
	    xmlStream.openNode('row');
	    xmlStream.addAttribute('r', model.number);
	    if (model.height) {
	      xmlStream.addAttribute('ht', model.height);
	      xmlStream.addAttribute('customHeight', '1');
	    }
	    if (model.hidden) {
	      xmlStream.addAttribute('hidden', '1');
	    }
	    if (model.min > 0 && model.max > 0 && model.min <= model.max) {
	      xmlStream.addAttribute('spans', `${model.min}:${model.max}`);
	    }
	    if (model.styleId) {
	      xmlStream.addAttribute('s', model.styleId);
	      xmlStream.addAttribute('customFormat', '1');
	    }
	    xmlStream.addAttribute('x14ac:dyDescent', '0.25');
	    if (model.outlineLevel) {
	      xmlStream.addAttribute('outlineLevel', model.outlineLevel);
	    }
	    if (model.collapsed) {
	      xmlStream.addAttribute('collapsed', '1');
	    }

	    const cellXform = this.map.c;
	    model.cells.forEach(cellModel => {
	      cellXform.render(xmlStream, cellModel, options);
	    });

	    xmlStream.closeNode();
	  }

	  parseOpen(node) {
	    if (this.parser) {
	      this.parser.parseOpen(node);
	      return true;
	    }
	    if (node.name === 'row') {
	      this.numRowsSeen += 1;
	      const spans = node.attributes.spans
	        ? node.attributes.spans.split(':').map(span => parseInt(span, 10))
	        : [undefined, undefined];
	      const model = (this.model = {
	        number: parseInt(node.attributes.r, 10),
	        min: spans[0],
	        max: spans[1],
	        cells: [],
	      });
	      if (node.attributes.s) {
	        model.styleId = parseInt(node.attributes.s, 10);
	      }
	      if (
	        node.attributes.hidden === true ||
	        node.attributes.hidden === 'true' ||
	        node.attributes.hidden === 1 ||
	        node.attributes.hidden === '1'
	      ) {
	        model.hidden = true;
	      }
	      if (node.attributes.bestFit) {
	        model.bestFit = true;
	      }
	      if (node.attributes.ht) {
	        model.height = parseFloat(node.attributes.ht);
	      }
	      if (node.attributes.outlineLevel) {
	        model.outlineLevel = parseInt(node.attributes.outlineLevel, 10);
	      }
	      if (node.attributes.collapsed) {
	        model.collapsed = true;
	      }
	      return true;
	    }

	    this.parser = this.map[node.name];
	    if (this.parser) {
	      this.parser.parseOpen(node);
	      return true;
	    }
	    return false;
	  }

	  parseText(text) {
	    if (this.parser) {
	      this.parser.parseText(text);
	    }
	  }

	  parseClose(name) {
	    if (this.parser) {
	      if (!this.parser.parseClose(name)) {
	        this.model.cells.push(this.parser.model);
	        if (this.maxItems && this.model.cells.length > this.maxItems) {
	          throw new Error(`Max column count (${this.maxItems}) exceeded`);
	        }
	        this.parser = undefined;
	      }
	      return true;
	    }
	    return false;
	  }

	  reconcile(model, options) {
	    model.style = model.styleId ? options.styles.getStyleModel(model.styleId) : {};
	    if (model.styleId !== undefined) {
	      model.styleId = undefined;
	    }

	    const cellXform = this.map.c;
	    model.cells.forEach(cellModel => {
	      cellXform.reconcile(cellModel, options);
	    });
	  }
	}

	var rowXform = RowXform;

	class ColXform extends baseXform {
	  get tag() {
	    return 'col';
	  }

	  prepare(model, options) {
	    const styleId = options.styles.addStyleModel(model.style || {});
	    if (styleId) {
	      model.styleId = styleId;
	    }
	  }

	  render(xmlStream, model) {
	    xmlStream.openNode('col');
	    xmlStream.addAttribute('min', model.min);
	    xmlStream.addAttribute('max', model.max);
	    if (model.width) {
	      xmlStream.addAttribute('width', model.width);
	    }
	    if (model.styleId) {
	      xmlStream.addAttribute('style', model.styleId);
	    }
	    if (model.hidden) {
	      xmlStream.addAttribute('hidden', '1');
	    }
	    if (model.bestFit) {
	      xmlStream.addAttribute('bestFit', '1');
	    }
	    if (model.outlineLevel) {
	      xmlStream.addAttribute('outlineLevel', model.outlineLevel);
	    }
	    if (model.collapsed) {
	      xmlStream.addAttribute('collapsed', '1');
	    }
	    xmlStream.addAttribute('customWidth', '1');
	    xmlStream.closeNode();
	  }

	  parseOpen(node) {
	    if (node.name === 'col') {
	      const model = (this.model = {
	        min: parseInt(node.attributes.min || '0', 10),
	        max: parseInt(node.attributes.max || '0', 10),
	        width:
	          node.attributes.width === undefined
	            ? undefined
	            : parseFloat(node.attributes.width || '0'),
	      });
	      if (node.attributes.style) {
	        model.styleId = parseInt(node.attributes.style, 10);
	      }
	      if (
	        node.attributes.hidden === true ||
	        node.attributes.hidden === 'true' ||
	        node.attributes.hidden === 1 ||
	        node.attributes.hidden === '1'
	      ) {
	        model.hidden = true;
	      }
	      if (node.attributes.bestFit) {
	        model.bestFit = true;
	      }
	      if (node.attributes.outlineLevel) {
	        model.outlineLevel = parseInt(node.attributes.outlineLevel, 10);
	      }
	      if (node.attributes.collapsed) {
	        model.collapsed = true;
	      }
	      return true;
	    }
	    return false;
	  }

	  parseText() {}

	  parseClose() {
	    return false;
	  }

	  reconcile(model, options) {
	    // reconcile column styles
	    if (model.styleId) {
	      model.style = options.styles.getStyleModel(model.styleId);
	    }
	  }
	}

	var colXform = ColXform;

	class DimensionXform extends baseXform {
	  get tag() {
	    return 'dimension';
	  }

	  render(xmlStream, model) {
	    if (model) {
	      xmlStream.leafNode('dimension', {ref: model});
	    }
	  }

	  parseOpen(node) {
	    if (node.name === 'dimension') {
	      this.model = node.attributes.ref;
	      return true;
	    }
	    return false;
	  }

	  parseText() {}

	  parseClose() {
	    return false;
	  }
	}

	var dimensionXform = DimensionXform;

	class HyperlinkXform extends baseXform {
	  get tag() {
	    return 'hyperlink';
	  }

	  render(xmlStream, model) {
	    xmlStream.leafNode('hyperlink', {
	      ref: model.address,
	      'r:id': model.rId,
	      tooltip: model.tooltip,
	    });
	  }

	  parseOpen(node) {
	    if (node.name === 'hyperlink') {
	      this.model = {
	        address: node.attributes.ref,
	        rId: node.attributes['r:id'],
	        tooltip: node.attributes.tooltip,
	      };
	      return true;
	    }
	    return false;
	  }

	  parseText() {}

	  parseClose() {
	    return false;
	  }
	}

	var hyperlinkXform = HyperlinkXform;

	class MergeCellXform extends baseXform {
	  get tag() {
	    return 'mergeCell';
	  }

	  render(xmlStream, model) {
	    xmlStream.leafNode('mergeCell', {ref: model});
	  }

	  parseOpen(node) {
	    if (node.name === 'mergeCell') {
	      this.model = node.attributes.ref;
	      return true;
	    }
	    return false;
	  }

	  parseText() {}

	  parseClose() {
	    return false;
	  }
	}

	var mergeCellXform = MergeCellXform;

	function assign(definedName, attributes, name, defaultValue) {
	  const value = attributes[name];
	  if (value !== undefined) {
	    definedName[name] = value;
	  } else if (defaultValue !== undefined) {
	    definedName[name] = defaultValue;
	  }
	}
	function parseBool(value) {
	  switch (value) {
	    case '1':
	    case 'true':
	      return true;
	    default:
	      return false;
	  }
	}
	function assignBool(definedName, attributes, name, defaultValue) {
	  const value = attributes[name];
	  if (value !== undefined) {
	    definedName[name] = parseBool(value);
	  } else if (defaultValue !== undefined) {
	    definedName[name] = defaultValue;
	  }
	}

	function optimiseDataValidations(model) {
	  // Squeeze alike data validations together into rectangular ranges
	  // to reduce file size and speed up Excel load time
	  const dvList = underDash.map(model, (dataValidation, address) => ({
	    address,
	    dataValidation,
	    marked: false,
	  })).sort((a, b) => underDash.strcmp(a.address, b.address));
	  const dvMap = underDash.keyBy(dvList, 'address');
	  const matchCol = (addr, height, col) => {
	    for (let i = 0; i < height; i++) {
	      const otherAddress = colCache_1.encodeAddress(addr.row + i, col);
	      if (!model[otherAddress] || !underDash.isEqual(model[addr.address], model[otherAddress])) {
	        return false;
	      }
	    }
	    return true;
	  };
	  return dvList
	    .map(dv => {
	      if (!dv.marked) {
	        const addr = colCache_1.decodeEx(dv.address);
	        if (addr.dimensions) {
	          dvMap[addr.dimensions].marked = true;
	          return {
	            ...dv.dataValidation,
	            sqref: dv.address,
	          };
	        }

	        // iterate downwards - finding matching cells
	        let height = 1;
	        let otherAddress = colCache_1.encodeAddress(addr.row + height, addr.col);
	        while (model[otherAddress] && underDash.isEqual(dv.dataValidation, model[otherAddress])) {
	          height++;
	          otherAddress = colCache_1.encodeAddress(addr.row + height, addr.col);
	        }

	        // iterate rightwards...

	        let width = 1;
	        while (matchCol(addr, height, addr.col + width)) {
	          width++;
	        }

	        // mark all included addresses
	        for (let i = 0; i < height; i++) {
	          for (let j = 0; j < width; j++) {
	            otherAddress = colCache_1.encodeAddress(addr.row + i, addr.col + j);
	            dvMap[otherAddress].marked = true;
	          }
	        }

	        if (height > 1 || width > 1) {
	          const bottom = addr.row + (height - 1);
	          const right = addr.col + (width - 1);
	          return {
	            ...dv.dataValidation,
	            sqref: `${dv.address}:${colCache_1.encodeAddress(bottom, right)}`,
	          };
	        }
	        return {
	          ...dv.dataValidation,
	          sqref: dv.address,
	        };
	      }
	      return null;
	    })
	    .filter(Boolean);
	}

	class DataValidationsXform extends baseXform {
	  get tag() {
	    return 'dataValidations';
	  }

	  render(xmlStream, model) {
	    const optimizedModel = optimiseDataValidations(model);
	    if (optimizedModel.length) {
	      xmlStream.openNode('dataValidations', {count: optimizedModel.length});

	      optimizedModel.forEach(value => {
	        xmlStream.openNode('dataValidation');

	        if (value.type !== 'any') {
	          xmlStream.addAttribute('type', value.type);

	          if (value.operator && value.type !== 'list' && value.operator !== 'between') {
	            xmlStream.addAttribute('operator', value.operator);
	          }
	          if (value.allowBlank) {
	            xmlStream.addAttribute('allowBlank', '1');
	          }
	        }
	        if (value.showInputMessage) {
	          xmlStream.addAttribute('showInputMessage', '1');
	        }
	        if (value.promptTitle) {
	          xmlStream.addAttribute('promptTitle', value.promptTitle);
	        }
	        if (value.prompt) {
	          xmlStream.addAttribute('prompt', value.prompt);
	        }
	        if (value.showErrorMessage) {
	          xmlStream.addAttribute('showErrorMessage', '1');
	        }
	        if (value.errorStyle) {
	          xmlStream.addAttribute('errorStyle', value.errorStyle);
	        }
	        if (value.errorTitle) {
	          xmlStream.addAttribute('errorTitle', value.errorTitle);
	        }
	        if (value.error) {
	          xmlStream.addAttribute('error', value.error);
	        }
	        xmlStream.addAttribute('sqref', value.sqref);
	        (value.formulae || []).forEach((formula, index) => {
	          xmlStream.openNode(`formula${index + 1}`);
	          if (value.type === 'date') {
	            xmlStream.writeText(utils_1.dateToExcel(new Date(formula)));
	          } else {
	            xmlStream.writeText(formula);
	          }
	          xmlStream.closeNode();
	        });
	        xmlStream.closeNode();
	      });
	      xmlStream.closeNode();
	    }
	  }

	  parseOpen(node) {
	    switch (node.name) {
	      case 'dataValidations':
	        this.model = {};
	        return true;

	      case 'dataValidation': {
	        this._address = node.attributes.sqref;
	        const dataValidation = {type: node.attributes.type || 'any', formulae: []};

	        if (node.attributes.type) {
	          assignBool(dataValidation, node.attributes, 'allowBlank');
	        }
	        assignBool(dataValidation, node.attributes, 'showInputMessage');
	        assignBool(dataValidation, node.attributes, 'showErrorMessage');

	        switch (dataValidation.type) {
	          case 'any':
	          case 'list':
	          case 'custom':
	            break;
	          default:
	            assign(dataValidation, node.attributes, 'operator', 'between');
	            break;
	        }
	        assign(dataValidation, node.attributes, 'promptTitle');
	        assign(dataValidation, node.attributes, 'prompt');
	        assign(dataValidation, node.attributes, 'errorStyle');
	        assign(dataValidation, node.attributes, 'errorTitle');
	        assign(dataValidation, node.attributes, 'error');

	        this._dataValidation = dataValidation;
	        return true;
	      }

	      case 'formula1':
	      case 'formula2':
	        this._formula = [];
	        return true;

	      default:
	        return false;
	    }
	  }

	  parseText(text) {
	    if (this._formula) {
	      this._formula.push(text);
	    }
	  }

	  parseClose(name) {
	    switch (name) {
	      case 'dataValidations':
	        return false;
	      case 'dataValidation': {
	        if (!this._dataValidation.formulae || !this._dataValidation.formulae.length) {
	          delete this._dataValidation.formulae;
	          delete this._dataValidation.operator;
	        }
	        // The four known cases: 1. E4:L9 N4:U9  2.E4 L9  3. N4:U9  4. E4
	        const list = this._address.split(/\s+/g) || [];
	        list.forEach(addr => {
	          if (addr.includes(':')) {
	            const range$1 = new range(addr);
	            range$1.forEachAddress(address => {
	              this.model[address] = this._dataValidation;
	            });
	          } else {
	            this.model[addr] = this._dataValidation;
	          }
	        });
	        return true;
	      }
	      case 'formula1':
	      case 'formula2': {
	        let formula = this._formula.join('');
	        switch (this._dataValidation.type) {
	          case 'whole':
	          case 'textLength':
	            formula = parseInt(formula, 10);
	            break;
	          case 'decimal':
	            formula = parseFloat(formula);
	            break;
	          case 'date':
	            formula = utils_1.excelToDate(parseFloat(formula));
	            break;
	        }
	        this._dataValidation.formulae.push(formula);
	        this._formula = undefined;
	        return true;
	      }
	      default:
	        return true;
	    }
	  }
	}

	var dataValidationsXform = DataValidationsXform;

	class PageSetupPropertiesXform extends baseXform {
	  get tag() {
	    return 'pageSetUpPr';
	  }

	  render(xmlStream, model) {
	    if (model && model.fitToPage) {
	      xmlStream.leafNode(this.tag, {
	        fitToPage: model.fitToPage ? '1' : undefined,
	      });
	      return true;
	    }
	    return false;
	  }

	  parseOpen(node) {
	    if (node.name === this.tag) {
	      this.model = {
	        fitToPage: node.attributes.fitToPage === '1',
	      };
	      return true;
	    }
	    return false;
	  }

	  parseText() {}

	  parseClose() {
	    return false;
	  }
	}

	var pageSetupPropertiesXform = PageSetupPropertiesXform;

	const isDefined = attr => typeof attr !== 'undefined';

	class OutlinePropertiesXform extends baseXform {
	  get tag() {
	    return 'outlinePr';
	  }

	  render(xmlStream, model) {
	    if (model && (isDefined(model.summaryBelow) || isDefined(model.summaryRight))) {
	      xmlStream.leafNode(this.tag, {
	        summaryBelow: isDefined(model.summaryBelow) ? Number(model.summaryBelow) : undefined,
	        summaryRight: isDefined(model.summaryRight) ? Number(model.summaryRight) : undefined,
	      });
	      return true;
	    }
	    return false;
	  }

	  parseOpen(node) {
	    if (node.name === this.tag) {
	      this.model = {
	        summaryBelow: isDefined(node.attributes.summaryBelow)
	          ? Boolean(Number(node.attributes.summaryBelow))
	          : undefined,
	        summaryRight: isDefined(node.attributes.summaryRight)
	          ? Boolean(Number(node.attributes.summaryRight))
	          : undefined,
	      };
	      return true;
	    }
	    return false;
	  }

	  parseText() {}

	  parseClose() {
	    return false;
	  }
	}

	var outlinePropertiesXform = OutlinePropertiesXform;

	class SheetPropertiesXform extends baseXform {
	  constructor() {
	    super();

	    this.map = {
	      tabColor: new colorXform('tabColor'),
	      pageSetUpPr: new pageSetupPropertiesXform(),
	      outlinePr: new outlinePropertiesXform(),
	    };
	  }

	  get tag() {
	    return 'sheetPr';
	  }

	  render(xmlStream, model) {
	    if (model) {
	      xmlStream.addRollback();
	      xmlStream.openNode('sheetPr');

	      let inner = false;
	      inner = this.map.tabColor.render(xmlStream, model.tabColor) || inner;
	      inner = this.map.pageSetUpPr.render(xmlStream, model.pageSetup) || inner;
	      inner = this.map.outlinePr.render(xmlStream, model.outlineProperties) || inner;

	      if (inner) {
	        xmlStream.closeNode();
	        xmlStream.commit();
	      } else {
	        xmlStream.rollback();
	      }
	    }
	  }

	  parseOpen(node) {
	    if (this.parser) {
	      this.parser.parseOpen(node);
	      return true;
	    }
	    if (node.name === this.tag) {
	      this.reset();
	      return true;
	    }
	    if (this.map[node.name]) {
	      this.parser = this.map[node.name];
	      this.parser.parseOpen(node);
	      return true;
	    }
	    return false;
	  }

	  parseText(text) {
	    if (this.parser) {
	      this.parser.parseText(text);
	      return true;
	    }
	    return false;
	  }

	  parseClose(name) {
	    if (this.parser) {
	      if (!this.parser.parseClose(name)) {
	        this.parser = undefined;
	      }
	      return true;
	    }
	    if (this.map.tabColor.model || this.map.pageSetUpPr.model || this.map.outlinePr.model) {
	      this.model = {};
	      if (this.map.tabColor.model) {
	        this.model.tabColor = this.map.tabColor.model;
	      }
	      if (this.map.pageSetUpPr.model) {
	        this.model.pageSetup = this.map.pageSetUpPr.model;
	      }
	      if (this.map.outlinePr.model) {
	        this.model.outlineProperties = this.map.outlinePr.model;
	      }
	    } else {
	      this.model = null;
	    }
	    return false;
	  }
	}

	var sheetPropertiesXform = SheetPropertiesXform;

	class SheetFormatPropertiesXform extends baseXform {
	  get tag() {
	    return 'sheetFormatPr';
	  }

	  render(xmlStream, model) {
	    if (model) {
	      const attributes = {
	        defaultRowHeight: model.defaultRowHeight,
	        outlineLevelRow: model.outlineLevelRow,
	        outlineLevelCol: model.outlineLevelCol,
	        'x14ac:dyDescent': model.dyDescent,
	      };
	      if (model.defaultColWidth) {
	        attributes.defaultColWidth = model.defaultColWidth;
	      }

	      // default value for 'defaultRowHeight' is 15, this should not be 'custom'
	      if (!model.defaultRowHeight || model.defaultRowHeight !== 15) {
	        attributes.customHeight = '1';
	      }

	      if (underDash.some(attributes, value => value !== undefined)) {
	        xmlStream.leafNode('sheetFormatPr', attributes);
	      }
	    }
	  }

	  parseOpen(node) {
	    if (node.name === 'sheetFormatPr') {
	      this.model = {
	        defaultRowHeight: parseFloat(node.attributes.defaultRowHeight || '0'),
	        dyDescent: parseFloat(node.attributes['x14ac:dyDescent'] || '0'),
	        outlineLevelRow: parseInt(node.attributes.outlineLevelRow || '0', 10),
	        outlineLevelCol: parseInt(node.attributes.outlineLevelCol || '0', 10),
	      };
	      if (node.attributes.defaultColWidth) {
	        this.model.defaultColWidth = parseFloat(node.attributes.defaultColWidth);
	      }
	      return true;
	    }
	    return false;
	  }

	  parseText() {}

	  parseClose() {
	    return false;
	  }
	}

	var sheetFormatPropertiesXform = SheetFormatPropertiesXform;

	const VIEW_STATES = {
	  frozen: 'frozen',
	  frozenSplit: 'frozen',
	  split: 'split',
	};

	class SheetViewXform extends baseXform {
	  get tag() {
	    return 'sheetView';
	  }

	  prepare(model) {
	    switch (model.state) {
	      case 'frozen':
	      case 'split':
	        break;
	      default:
	        model.state = 'normal';
	        break;
	    }
	  }

	  render(xmlStream, model) {
	    xmlStream.openNode('sheetView', {
	      workbookViewId: model.workbookViewId || 0,
	    });
	    const add = function(name, value, included) {
	      if (included) {
	        xmlStream.addAttribute(name, value);
	      }
	    };
	    add('rightToLeft', '1', model.rightToLeft === true);
	    add('tabSelected', '1', model.tabSelected);
	    add('showRuler', '0', model.showRuler === false);
	    add('showRowColHeaders', '0', model.showRowColHeaders === false);
	    add('showGridLines', '0', model.showGridLines === false);
	    add('zoomScale', model.zoomScale, model.zoomScale);
	    add('zoomScaleNormal', model.zoomScaleNormal, model.zoomScaleNormal);
	    add('view', model.style, model.style);

	    let topLeftCell;
	    let xSplit;
	    let ySplit;
	    let activePane;
	    switch (model.state) {
	      case 'frozen':
	        xSplit = model.xSplit || 0;
	        ySplit = model.ySplit || 0;
	        topLeftCell = model.topLeftCell || colCache_1.getAddress(ySplit + 1, xSplit + 1).address;
	        activePane =
	          (model.xSplit && model.ySplit && 'bottomRight') ||
	          (model.xSplit && 'topRight') ||
	          'bottomLeft';

	        xmlStream.leafNode('pane', {
	          xSplit: model.xSplit || undefined,
	          ySplit: model.ySplit || undefined,
	          topLeftCell,
	          activePane,
	          state: 'frozen',
	        });
	        xmlStream.leafNode('selection', {
	          pane: activePane,
	          activeCell: model.activeCell,
	          sqref: model.activeCell,
	        });
	        break;
	      case 'split':
	        if (model.activePane === 'topLeft') {
	          model.activePane = undefined;
	        }
	        xmlStream.leafNode('pane', {
	          xSplit: model.xSplit || undefined,
	          ySplit: model.ySplit || undefined,
	          topLeftCell: model.topLeftCell,
	          activePane: model.activePane,
	        });
	        xmlStream.leafNode('selection', {
	          pane: model.activePane,
	          activeCell: model.activeCell,
	          sqref: model.activeCell,
	        });
	        break;
	      case 'normal':
	        if (model.activeCell) {
	          xmlStream.leafNode('selection', {
	            activeCell: model.activeCell,
	            sqref: model.activeCell,
	          });
	        }
	        break;
	    }
	    xmlStream.closeNode();
	  }

	  parseOpen(node) {
	    switch (node.name) {
	      case 'sheetView':
	        this.sheetView = {
	          workbookViewId: parseInt(node.attributes.workbookViewId, 10),
	          rightToLeft: node.attributes.rightToLeft === '1',
	          tabSelected: node.attributes.tabSelected === '1',
	          showRuler: !(node.attributes.showRuler === '0'),
	          showRowColHeaders: !(node.attributes.showRowColHeaders === '0'),
	          showGridLines: !(node.attributes.showGridLines === '0'),
	          zoomScale: parseInt(node.attributes.zoomScale || '100', 10),
	          zoomScaleNormal: parseInt(node.attributes.zoomScaleNormal || '100', 10),
	          style: node.attributes.view,
	        };
	        this.pane = undefined;
	        this.selections = {};
	        return true;

	      case 'pane':
	        this.pane = {
	          xSplit: parseInt(node.attributes.xSplit || '0', 10),
	          ySplit: parseInt(node.attributes.ySplit || '0', 10),
	          topLeftCell: node.attributes.topLeftCell,
	          activePane: node.attributes.activePane || 'topLeft',
	          state: node.attributes.state,
	        };
	        return true;

	      case 'selection': {
	        const name = node.attributes.pane || 'topLeft';
	        this.selections[name] = {
	          pane: name,
	          activeCell: node.attributes.activeCell,
	        };
	        return true;
	      }

	      default:
	        return false;
	    }
	  }

	  parseText() {}

	  parseClose(name) {
	    let model;
	    let selection;
	    switch (name) {
	      case 'sheetView':
	        if (this.sheetView && this.pane) {
	          model = this.model = {
	            workbookViewId: this.sheetView.workbookViewId,
	            rightToLeft: this.sheetView.rightToLeft,
	            state: VIEW_STATES[this.pane.state] || 'split', // split is default
	            xSplit: this.pane.xSplit,
	            ySplit: this.pane.ySplit,
	            topLeftCell: this.pane.topLeftCell,
	            showRuler: this.sheetView.showRuler,
	            showRowColHeaders: this.sheetView.showRowColHeaders,
	            showGridLines: this.sheetView.showGridLines,
	            zoomScale: this.sheetView.zoomScale,
	            zoomScaleNormal: this.sheetView.zoomScaleNormal,
	          };
	          if (this.model.state === 'split') {
	            model.activePane = this.pane.activePane;
	          }
	          selection = this.selections[this.pane.activePane];
	          if (selection && selection.activeCell) {
	            model.activeCell = selection.activeCell;
	          }
	          if (this.sheetView.style) {
	            model.style = this.sheetView.style;
	          }
	        } else {
	          model = this.model = {
	            workbookViewId: this.sheetView.workbookViewId,
	            rightToLeft: this.sheetView.rightToLeft,
	            state: 'normal',
	            showRuler: this.sheetView.showRuler,
	            showRowColHeaders: this.sheetView.showRowColHeaders,
	            showGridLines: this.sheetView.showGridLines,
	            zoomScale: this.sheetView.zoomScale,
	            zoomScaleNormal: this.sheetView.zoomScaleNormal,
	          };
	          selection = this.selections.topLeft;
	          if (selection && selection.activeCell) {
	            model.activeCell = selection.activeCell;
	          }
	          if (this.sheetView.style) {
	            model.style = this.sheetView.style;
	          }
	        }
	        return false;
	      default:
	        return true;
	    }
	  }

	  reconcile() {}
	}

	var sheetViewXform = SheetViewXform;

	function booleanToXml(model, value) {
	  return model ? value : undefined;
	}

	function xmlToBoolean(value, equals) {
	  return value === equals ? true : undefined;
	}

	class SheetProtectionXform extends baseXform {
	  get tag() {
	    return 'sheetProtection';
	  }

	  render(xmlStream, model) {
	    if (model) {
	      const attributes = {
	        sheet: booleanToXml(model.sheet, '1'),
	        selectLockedCells: model.selectLockedCells === false ? '1' : undefined,
	        selectUnlockedCells: model.selectUnlockedCells === false ? '1' : undefined,
	        formatCells: booleanToXml(model.formatCells, '0'),
	        formatColumns: booleanToXml(model.formatColumns, '0'),
	        formatRows: booleanToXml(model.formatRows, '0'),
	        insertColumns: booleanToXml(model.insertColumns, '0'),
	        insertRows: booleanToXml(model.insertRows, '0'),
	        insertHyperlinks: booleanToXml(model.insertHyperlinks, '0'),
	        deleteColumns: booleanToXml(model.deleteColumns, '0'),
	        deleteRows: booleanToXml(model.deleteRows, '0'),
	        sort: booleanToXml(model.sort, '0'),
	        autoFilter: booleanToXml(model.autoFilter, '0'),
	        pivotTables: booleanToXml(model.pivotTables, '0'),
	      };
	      if (model.sheet) {
	        attributes.algorithmName = model.algorithmName;
	        attributes.hashValue = model.hashValue;
	        attributes.saltValue = model.saltValue;
	        attributes.spinCount = model.spinCount;
	        attributes.objects = booleanToXml(model.objects === false, '1');
	        attributes.scenarios = booleanToXml(model.scenarios === false, '1');
	      }
	      if (underDash.some(attributes, value => value !== undefined)) {
	        xmlStream.leafNode(this.tag, attributes);
	      }
	    }
	  }

	  parseOpen(node) {
	    switch (node.name) {
	      case this.tag:
	        this.model = {
	          sheet: xmlToBoolean(node.attributes.sheet, '1'),
	          objects: node.attributes.objects === '1' ? false : undefined,
	          scenarios: node.attributes.scenarios === '1' ? false : undefined,
	          selectLockedCells: node.attributes.selectLockedCells === '1' ? false : undefined,
	          selectUnlockedCells: node.attributes.selectUnlockedCells === '1' ? false : undefined,
	          formatCells: xmlToBoolean(node.attributes.formatCells, '0'),
	          formatColumns: xmlToBoolean(node.attributes.formatColumns, '0'),
	          formatRows: xmlToBoolean(node.attributes.formatRows, '0'),
	          insertColumns: xmlToBoolean(node.attributes.insertColumns, '0'),
	          insertRows: xmlToBoolean(node.attributes.insertRows, '0'),
	          insertHyperlinks: xmlToBoolean(node.attributes.insertHyperlinks, '0'),
	          deleteColumns: xmlToBoolean(node.attributes.deleteColumns, '0'),
	          deleteRows: xmlToBoolean(node.attributes.deleteRows, '0'),
	          sort: xmlToBoolean(node.attributes.sort, '0'),
	          autoFilter: xmlToBoolean(node.attributes.autoFilter, '0'),
	          pivotTables: xmlToBoolean(node.attributes.pivotTables, '0'),
	        };
	        if (node.attributes.algorithmName) {
	          this.model.algorithmName = node.attributes.algorithmName;
	          this.model.hashValue = node.attributes.hashValue;
	          this.model.saltValue = node.attributes.saltValue;
	          this.model.spinCount = parseInt(node.attributes.spinCount, 10);
	        }
	        return true;
	      default:
	        return false;
	    }
	  }

	  parseText() {}

	  parseClose() {
	    return false;
	  }
	}

	var sheetProtectionXform = SheetProtectionXform;

	class PageMarginsXform extends baseXform {
	  get tag() {
	    return 'pageMargins';
	  }

	  render(xmlStream, model) {
	    if (model) {
	      const attributes = {
	        left: model.left,
	        right: model.right,
	        top: model.top,
	        bottom: model.bottom,
	        header: model.header,
	        footer: model.footer,
	      };
	      if (underDash.some(attributes, value => value !== undefined)) {
	        xmlStream.leafNode(this.tag, attributes);
	      }
	    }
	  }

	  parseOpen(node) {
	    switch (node.name) {
	      case this.tag:
	        this.model = {
	          left: parseFloat(node.attributes.left || 0.7),
	          right: parseFloat(node.attributes.right || 0.7),
	          top: parseFloat(node.attributes.top || 0.75),
	          bottom: parseFloat(node.attributes.bottom || 0.75),
	          header: parseFloat(node.attributes.header || 0.3),
	          footer: parseFloat(node.attributes.footer || 0.3),
	        };
	        return true;
	      default:
	        return false;
	    }
	  }

	  parseText() {}

	  parseClose() {
	    return false;
	  }
	}

	var pageMarginsXform = PageMarginsXform;

	function booleanToXml$1(model) {
	  return model ? '1' : undefined;
	}
	function pageOrderToXml(model) {
	  switch (model) {
	    case 'overThenDown':
	      return model;
	    default:
	      return undefined;
	  }
	}
	function cellCommentsToXml(model) {
	  switch (model) {
	    case 'atEnd':
	    case 'asDisplyed':
	      return model;
	    default:
	      return undefined;
	  }
	}
	function errorsToXml(model) {
	  switch (model) {
	    case 'dash':
	    case 'blank':
	    case 'NA':
	      return model;
	    default:
	      return undefined;
	  }
	}
	function pageSizeToModel(value) {
	  return value !== undefined ? parseInt(value, 10) : undefined;
	}

	class PageSetupXform extends baseXform {
	  get tag() {
	    return 'pageSetup';
	  }

	  render(xmlStream, model) {
	    if (model) {
	      const attributes = {
	        paperSize: model.paperSize,
	        orientation: model.orientation,
	        horizontalDpi: model.horizontalDpi,
	        verticalDpi: model.verticalDpi,
	        pageOrder: pageOrderToXml(model.pageOrder),
	        blackAndWhite: booleanToXml$1(model.blackAndWhite),
	        draft: booleanToXml$1(model.draft),
	        cellComments: cellCommentsToXml(model.cellComments),
	        errors: errorsToXml(model.errors),
	        scale: model.scale,
	        fitToWidth: model.fitToWidth,
	        fitToHeight: model.fitToHeight,
	        firstPageNumber: model.firstPageNumber,
	        useFirstPageNumber: booleanToXml$1(model.firstPageNumber),
	        usePrinterDefaults: booleanToXml$1(model.usePrinterDefaults),
	        copies: model.copies,
	      };
	      if (underDash.some(attributes, value => value !== undefined)) {
	        xmlStream.leafNode(this.tag, attributes);
	      }
	    }
	  }

	  parseOpen(node) {
	    switch (node.name) {
	      case this.tag:
	        this.model = {
	          paperSize: pageSizeToModel(node.attributes.paperSize),
	          orientation: node.attributes.orientation || 'portrait',
	          horizontalDpi: parseInt(node.attributes.horizontalDpi || '4294967295', 10),
	          verticalDpi: parseInt(node.attributes.verticalDpi || '4294967295', 10),
	          pageOrder: node.attributes.pageOrder || 'downThenOver',
	          blackAndWhite: node.attributes.blackAndWhite === '1',
	          draft: node.attributes.draft === '1',
	          cellComments: node.attributes.cellComments || 'None',
	          errors: node.attributes.errors || 'displayed',
	          scale: parseInt(node.attributes.scale || '100', 10),
	          fitToWidth: parseInt(node.attributes.fitToWidth || '1', 10),
	          fitToHeight: parseInt(node.attributes.fitToHeight || '1', 10),
	          firstPageNumber: parseInt(node.attributes.firstPageNumber || '1', 10),
	          useFirstPageNumber: node.attributes.useFirstPageNumber === '1',
	          usePrinterDefaults: node.attributes.usePrinterDefaults === '1',
	          copies: parseInt(node.attributes.copies || '1', 10),
	        };
	        return true;
	      default:
	        return false;
	    }
	  }

	  parseText() {}

	  parseClose() {
	    return false;
	  }
	}

	var pageSetupXform = PageSetupXform;

	function booleanToXml$2(model) {
	  return model ? '1' : undefined;
	}

	class PrintOptionsXform extends baseXform {
	  get tag() {
	    return 'printOptions';
	  }

	  render(xmlStream, model) {
	    if (model) {
	      const attributes = {
	        headings: booleanToXml$2(model.showRowColHeaders),
	        gridLines: booleanToXml$2(model.showGridLines),
	        horizontalCentered: booleanToXml$2(model.horizontalCentered),
	        verticalCentered: booleanToXml$2(model.verticalCentered),
	      };
	      if (underDash.some(attributes, value => value !== undefined)) {
	        xmlStream.leafNode(this.tag, attributes);
	      }
	    }
	  }

	  parseOpen(node) {
	    switch (node.name) {
	      case this.tag:
	        this.model = {
	          showRowColHeaders: node.attributes.headings === '1',
	          showGridLines: node.attributes.gridLines === '1',
	          horizontalCentered: node.attributes.horizontalCentered === '1',
	          verticalCentered: node.attributes.verticalCentered === '1',
	        };
	        return true;
	      default:
	        return false;
	    }
	  }

	  parseText() {}

	  parseClose() {
	    return false;
	  }
	}

	var printOptionsXform = PrintOptionsXform;

	class AutoFilterXform extends baseXform {
	  get tag() {
	    return 'autoFilter';
	  }

	  render(xmlStream, model) {
	    if (model) {
	      if (typeof model === 'string') {
	        // assume range
	        xmlStream.leafNode('autoFilter', {ref: model});
	      } else {
	        const getAddress = function(addr) {
	          if (typeof addr === 'string') {
	            return addr;
	          }
	          return colCache_1.getAddress(addr.row, addr.column).address;
	        };

	        const firstAddress = getAddress(model.from);
	        const secondAddress = getAddress(model.to);
	        if (firstAddress && secondAddress) {
	          xmlStream.leafNode('autoFilter', {ref: `${firstAddress}:${secondAddress}`});
	        }
	      }
	    }
	  }

	  parseOpen(node) {
	    if (node.name === 'autoFilter') {
	      this.model = node.attributes.ref;
	    }
	  }
	}

	var autoFilterXform = AutoFilterXform;

	class PictureXform extends baseXform {
	  get tag() {
	    return 'picture';
	  }

	  render(xmlStream, model) {
	    if (model) {
	      xmlStream.leafNode(this.tag, {'r:id': model.rId});
	    }
	  }

	  parseOpen(node) {
	    switch (node.name) {
	      case this.tag:
	        this.model = {
	          rId: node.attributes['r:id'],
	        };
	        return true;
	      default:
	        return false;
	    }
	  }

	  parseText() {}

	  parseClose() {
	    return false;
	  }
	}

	var pictureXform = PictureXform;

	class DrawingXform extends baseXform {
	  get tag() {
	    return 'drawing';
	  }

	  render(xmlStream, model) {
	    if (model) {
	      xmlStream.leafNode(this.tag, {'r:id': model.rId});
	    }
	  }

	  parseOpen(node) {
	    switch (node.name) {
	      case this.tag:
	        this.model = {
	          rId: node.attributes['r:id'],
	        };
	        return true;
	      default:
	        return false;
	    }
	  }

	  parseText() {}

	  parseClose() {
	    return false;
	  }
	}

	var drawingXform = DrawingXform;

	class TablePartXform extends baseXform {
	  get tag() {
	    return 'tablePart';
	  }

	  render(xmlStream, model) {
	    if (model) {
	      xmlStream.leafNode(this.tag, {'r:id': model.rId});
	    }
	  }

	  parseOpen(node) {
	    switch (node.name) {
	      case this.tag:
	        this.model = {
	          rId: node.attributes['r:id'],
	        };
	        return true;
	      default:
	        return false;
	    }
	  }

	  parseText() {}

	  parseClose() {
	    return false;
	  }
	}

	var tablePartXform = TablePartXform;

	class PageBreaksXform extends baseXform {
	  get tag() {
	    return 'brk';
	  }

	  render(xmlStream, model) {
	    xmlStream.leafNode('brk', model);
	  }

	  parseOpen(node) {
	    if (node.name === 'brk') {
	      this.model = node.attributes.ref;
	      return true;
	    }
	    return false;
	  }

	  parseText() {}

	  parseClose() {
	    return false;
	  }
	}

	var pageBreaksXform = PageBreaksXform;

	class RowBreaksXform extends listXform {
	  constructor() {
	    const options = {
	      tag: 'rowBreaks',
	      count: true,
	      childXform: new pageBreaksXform(),
	    };
	    super(options);
	  }

	  // get tag() { return 'rowBreaks'; }

	  render(xmlStream, model) {
	    if (model && model.length) {
	      xmlStream.openNode(this.tag, this.$);
	      if (this.count) {
	        xmlStream.addAttribute(this.$count, model.length);
	        xmlStream.addAttribute('manualBreakCount', model.length);
	      }

	      const {childXform} = this;
	      model.forEach(childModel => {
	        childXform.render(xmlStream, childModel);
	      });

	      xmlStream.closeNode();
	    } else if (this.empty) {
	      xmlStream.leafNode(this.tag);
	    }
	  }
	}

	var rowBreaksXform = RowBreaksXform;

	class HeaderFooterXform extends baseXform {
	  get tag() {
	    return 'headerFooter';
	  }

	  render(xmlStream, model) {
	    if (model) {
	      xmlStream.addRollback();

	      let createTag = false;

	      xmlStream.openNode('headerFooter');
	      if (model.differentFirst) {
	        xmlStream.addAttribute('differentFirst', '1');
	        createTag = true;
	      }
	      if (model.differentOddEven) {
	        xmlStream.addAttribute('differentOddEven', '1');
	        createTag = true;
	      }
	      if (model.oddHeader && typeof model.oddHeader === 'string') {
	        xmlStream.leafNode('oddHeader', null, model.oddHeader);
	        createTag = true;
	      }
	      if (model.oddFooter && typeof model.oddFooter === 'string') {
	        xmlStream.leafNode('oddFooter', null, model.oddFooter);
	        createTag = true;
	      }
	      if (model.evenHeader && typeof model.evenHeader === 'string') {
	        xmlStream.leafNode('evenHeader', null, model.evenHeader);
	        createTag = true;
	      }
	      if (model.evenFooter && typeof model.evenFooter === 'string') {
	        xmlStream.leafNode('evenFooter', null, model.evenFooter);
	        createTag = true;
	      }
	      if (model.firstHeader && typeof model.firstHeader === 'string') {
	        xmlStream.leafNode('firstHeader', null, model.firstHeader);
	        createTag = true;
	      }
	      if (model.firstFooter && typeof model.firstFooter === 'string') {
	        xmlStream.leafNode('firstFooter', null, model.firstFooter);
	        createTag = true;
	      }

	      if (createTag) {
	        xmlStream.closeNode();
	        xmlStream.commit();
	      } else {
	        xmlStream.rollback();
	      }
	    }
	  }

	  parseOpen(node) {
	    switch (node.name) {
	      case 'headerFooter':
	        this.model = {};
	        if (node.attributes.differentFirst) {
	          this.model.differentFirst = parseInt(node.attributes.differentFirst, 0) === 1;
	        }
	        if (node.attributes.differentOddEven) {
	          this.model.differentOddEven = parseInt(node.attributes.differentOddEven, 0) === 1;
	        }
	        return true;

	      case 'oddHeader':
	        this.currentNode = 'oddHeader';
	        return true;

	      case 'oddFooter':
	        this.currentNode = 'oddFooter';
	        return true;

	      case 'evenHeader':
	        this.currentNode = 'evenHeader';
	        return true;

	      case 'evenFooter':
	        this.currentNode = 'evenFooter';
	        return true;

	      case 'firstHeader':
	        this.currentNode = 'firstHeader';
	        return true;

	      case 'firstFooter':
	        this.currentNode = 'firstFooter';
	        return true;

	      default:
	        return false;
	    }
	  }

	  parseText(text) {
	    switch (this.currentNode) {
	      case 'oddHeader':
	        this.model.oddHeader = text;
	        break;

	      case 'oddFooter':
	        this.model.oddFooter = text;
	        break;

	      case 'evenHeader':
	        this.model.evenHeader = text;
	        break;

	      case 'evenFooter':
	        this.model.evenFooter = text;
	        break;

	      case 'firstHeader':
	        this.model.firstHeader = text;
	        break;

	      case 'firstFooter':
	        this.model.firstFooter = text;
	        break;
	    }
	  }

	  parseClose() {
	    switch (this.currentNode) {
	      case 'oddHeader':
	      case 'oddFooter':
	      case 'evenHeader':
	      case 'evenFooter':
	      case 'firstHeader':
	      case 'firstFooter':
	        this.currentNode = undefined;
	        return true;

	      default:
	        return false;
	    }
	  }
	}

	var headerFooterXform = HeaderFooterXform;

	/* 'virtual' methods used as a form of documentation */
	/* eslint-disable class-methods-use-this */

	// base class for xforms that are composed of other xforms
	// offers some default implementations
	class CompositeXform extends baseXform {
	  createNewModel(node) {
	    return {};
	  }

	  parseOpen(node) {
	    // Typical pattern for composite xform
	    this.parser = this.parser || this.map[node.name];
	    if (this.parser) {
	      this.parser.parseOpen(node);
	      return true;
	    }

	    if (node.name === this.tag) {
	      this.model = this.createNewModel(node);
	      return true;
	    }

	    return false;
	  }

	  parseText(text) {
	    // Default implementation. Send text to child parser
	    if (this.parser) {
	      this.parser.parseText(text);
	    }
	  }

	  onParserClose(name, parser) {
	    // parseClose has seen a child parser close
	    // now need to incorporate into this.model somehow
	    this.model[name] = parser.model;
	  }

	  parseClose(name) {
	    // Default implementation
	    if (this.parser) {
	      if (!this.parser.parseClose(name)) {
	        this.onParserClose(name, this.parser);
	        this.parser = undefined;
	      }
	      return true;
	    }

	    return name !== this.tag;
	  }
	}

	var compositeXform = CompositeXform;

	class CfvoXform extends baseXform {
	  get tag() {
	    return 'cfvo';
	  }

	  render(xmlStream, model) {
	    xmlStream.leafNode(this.tag, {
	      type: model.type,
	      val: model.value,
	    });
	  }

	  parseOpen(node) {
	    this.model = {
	      type: node.attributes.type,
	      value: baseXform.toFloatValue(node.attributes.val),
	    };
	  }

	  parseClose(name) {
	    return name !== this.tag;
	  }
	}

	var cfvoXform = CfvoXform;

	class DatabarXform extends compositeXform {
	  constructor() {
	    super();

	    this.map = {
	      cfvo: (this.cfvoXform = new cfvoXform()),
	      color: (this.colorXform = new colorXform()),
	    };
	  }

	  get tag() {
	    return 'dataBar';
	  }

	  render(xmlStream, model) {
	    xmlStream.openNode(this.tag);

	    model.cfvo.forEach(cfvo => {
	      this.cfvoXform.render(xmlStream, cfvo);
	    });
	    this.colorXform.render(xmlStream, model.color);

	    xmlStream.closeNode();
	  }

	  createNewModel() {
	    return {
	      cfvo: [],
	    };
	  }

	  onParserClose(name, parser) {
	    switch (name) {
	      case 'cfvo':
	        this.model.cfvo.push(parser.model);
	        break;
	      case 'color':
	        this.model.color = parser.model;
	        break;
	    }
	  }
	}

	var databarXform = DatabarXform;

	/* eslint-disable max-classes-per-file */



	class X14IdXform extends baseXform {
	  get tag() {
	    return 'x14:id';
	  }

	  render(xmlStream, model) {
	    xmlStream.leafNode(this.tag, null, model);
	  }

	  parseOpen() {
	    this.model = '';
	  }

	  parseText(text) {
	    this.model += text;
	  }

	  parseClose(name) {
	    return name !== this.tag;
	  }
	}

	class ExtXform extends compositeXform {
	  constructor() {
	    super();

	    this.map = {
	      'x14:id': (this.idXform = new X14IdXform()),
	    };
	  }

	  get tag() {
	    return 'ext';
	  }

	  render(xmlStream, model) {
	    xmlStream.openNode(this.tag, {
	      uri: '{B025F937-C7B1-47D3-B67F-A62EFF666E3E}',
	      'xmlns:x14': 'http://schemas.microsoft.com/office/spreadsheetml/2009/9/main',
	    });

	    this.idXform.render(xmlStream, model.x14Id);

	    xmlStream.closeNode();
	  }

	  createNewModel() {
	    return {};
	  }

	  onParserClose(name, parser) {
	    this.model.x14Id = parser.model;
	  }
	}

	class ExtLstRefXform extends compositeXform {
	  constructor() {
	    super();
	    this.map = {
	      ext: new ExtXform(),
	    };
	  }

	  get tag() {
	    return 'extLst';
	  }

	  render(xmlStream, model) {
	    xmlStream.openNode(this.tag);
	    this.map.ext.render(xmlStream, model);
	    xmlStream.closeNode();
	  }

	  createNewModel() {
	    return {};
	  }

	  onParserClose(name, parser) {
	    Object.assign(this.model, parser.model);
	  }
	}

	var extLstRefXform = ExtLstRefXform;

	class FormulaXform extends baseXform {
	  get tag() {
	    return 'formula';
	  }

	  render(xmlStream, model) {
	    xmlStream.leafNode(this.tag, null, model);
	  }

	  parseOpen() {
	    this.model = '';
	  }

	  parseText(text) {
	    this.model += text;
	  }

	  parseClose(name) {
	    return name !== this.tag;
	  }
	}

	var formulaXform = FormulaXform;

	class ColorScaleXform extends compositeXform {
	  constructor() {
	    super();

	    this.map = {
	      cfvo: (this.cfvoXform = new cfvoXform()),
	      color: (this.colorXform = new colorXform()),
	    };
	  }

	  get tag() {
	    return 'colorScale';
	  }

	  render(xmlStream, model) {
	    xmlStream.openNode(this.tag);

	    model.cfvo.forEach(cfvo => {
	      this.cfvoXform.render(xmlStream, cfvo);
	    });
	    model.color.forEach(color => {
	      this.colorXform.render(xmlStream, color);
	    });

	    xmlStream.closeNode();
	  }

	  createNewModel(node) {
	    return {
	      cfvo: [],
	      color: [],
	    };
	  }

	  onParserClose(name, parser) {
	    this.model[name].push(parser.model);
	  }
	}

	var colorScaleXform = ColorScaleXform;

	class IconSetXform extends compositeXform {
	  constructor() {
	    super();

	    this.map = {
	      cfvo: (this.cfvoXform = new cfvoXform()),
	    };
	  }

	  get tag() {
	    return 'iconSet';
	  }

	  render(xmlStream, model) {
	    xmlStream.openNode(this.tag, {
	      iconSet: baseXform.toStringAttribute(model.iconSet, '3TrafficLights'),
	      reverse: baseXform.toBoolAttribute(model.reverse, false),
	      showValue: baseXform.toBoolAttribute(model.showValue, true),
	    });

	    model.cfvo.forEach(cfvo => {
	      this.cfvoXform.render(xmlStream, cfvo);
	    });

	    xmlStream.closeNode();
	  }

	  createNewModel({attributes}) {
	    return {
	      iconSet: baseXform.toStringValue(attributes.iconSet, '3TrafficLights'),
	      reverse: baseXform.toBoolValue(attributes.reverse),
	      showValue: baseXform.toBoolValue(attributes.showValue),
	      cfvo: [],
	    };
	  }

	  onParserClose(name, parser) {
	    this.model[name].push(parser.model);
	  }
	}

	var iconSetXform = IconSetXform;

	const extIcons = {
	  '3Triangles': true,
	  '3Stars': true,
	  '5Boxes': true,
	};

	const getTextFormula = model => {
	  if (model.formulae && model.formulae[0]) {
	    return model.formulae[0];
	  }

	  const range$1 = new range(model.ref);
	  const {tl} = range$1;
	  switch (model.operator) {
	    case 'containsText':
	      return `NOT(ISERROR(SEARCH("${model.text}",${tl})))`;
	    case 'containsBlanks':
	      return `LEN(TRIM(${tl}))=0`;
	    case 'notContainsBlanks':
	      return `LEN(TRIM(${tl}))>0`;
	    case 'containsErrors':
	      return `ISERROR(${tl})`;
	    case 'notContainsErrors':
	      return `NOT(ISERROR(${tl}))`;
	    default:
	      return undefined;
	  }
	};

	const getTimePeriodFormula = model => {
	  if (model.formulae && model.formulae[0]) {
	    return model.formulae[0];
	  }

	  const range$1 = new range(model.ref);
	  const {tl} = range$1;
	  switch (model.timePeriod) {
	    case 'thisWeek':
	      return `AND(TODAY()-ROUNDDOWN(${tl},0)<=WEEKDAY(TODAY())-1,ROUNDDOWN(${tl},0)-TODAY()<=7-WEEKDAY(TODAY()))`;
	    case 'lastWeek':
	      return `AND(TODAY()-ROUNDDOWN(${tl},0)>=(WEEKDAY(TODAY())),TODAY()-ROUNDDOWN(${tl},0)<(WEEKDAY(TODAY())+7))`;
	    case 'nextWeek':
	      return `AND(ROUNDDOWN(${tl},0)-TODAY()>(7-WEEKDAY(TODAY())),ROUNDDOWN(${tl},0)-TODAY()<(15-WEEKDAY(TODAY())))`;
	    case 'yesterday':
	      return `FLOOR(${tl},1)=TODAY()-1`;
	    case 'today':
	      return `FLOOR(${tl},1)=TODAY()`;
	    case 'tomorrow':
	      return `FLOOR(${tl},1)=TODAY()+1`;
	    case 'last7Days':
	      return `AND(TODAY()-FLOOR(${tl},1)<=6,FLOOR(${tl},1)<=TODAY())`;
	    case 'lastMonth':
	      return `AND(MONTH(${tl})=MONTH(EDATE(TODAY(),0-1)),YEAR(${tl})=YEAR(EDATE(TODAY(),0-1)))`;
	    case 'thisMonth':
	      return `AND(MONTH(${tl})=MONTH(TODAY()),YEAR(${tl})=YEAR(TODAY()))`;
	    case 'nextMonth':
	      return `AND(MONTH(${tl})=MONTH(EDATE(TODAY(),0+1)),YEAR(${tl})=YEAR(EDATE(TODAY(),0+1)))`;
	    default:
	      return undefined;
	  }
	};

	const opType = attributes => {
	  const {type, operator} = attributes;
	  switch (type) {
	    case 'containsText':
	    case 'containsBlanks':
	    case 'notContainsBlanks':
	    case 'containsErrors':
	    case 'notContainsErrors':
	      return {
	        type: 'containsText',
	        operator: type,
	      };

	    default:
	      return {type, operator};
	  }
	};

	class CfRuleXform extends compositeXform {
	  constructor() {
	    super();

	    this.map = {
	      dataBar: (this.databarXform = new databarXform()),
	      extLst: (this.extLstRefXform = new extLstRefXform()),
	      formula: (this.formulaXform = new formulaXform()),
	      colorScale: (this.colorScaleXform = new colorScaleXform()),
	      iconSet: (this.iconSetXform = new iconSetXform()),
	    };
	  }

	  get tag() {
	    return 'cfRule';
	  }

	  static isPrimitive(rule) {
	    // is this rule primitive?
	    if (rule.type === 'iconSet') {
	      if (rule.custom || extIcons[rule.iconSet]) {
	        return false;
	      }
	    }
	    return true;
	  }

	  render(xmlStream, model) {
	    switch (model.type) {
	      case 'expression':
	        this.renderExpression(xmlStream, model);
	        break;
	      case 'cellIs':
	        this.renderCellIs(xmlStream, model);
	        break;
	      case 'top10':
	        this.renderTop10(xmlStream, model);
	        break;
	      case 'aboveAverage':
	        this.renderAboveAverage(xmlStream, model);
	        break;
	      case 'dataBar':
	        this.renderDataBar(xmlStream, model);
	        break;
	      case 'colorScale':
	        this.renderColorScale(xmlStream, model);
	        break;
	      case 'iconSet':
	        this.renderIconSet(xmlStream, model);
	        break;
	      case 'containsText':
	        this.renderText(xmlStream, model);
	        break;
	      case 'timePeriod':
	        this.renderTimePeriod(xmlStream, model);
	        break;
	    }
	  }

	  renderExpression(xmlStream, model) {
	    xmlStream.openNode(this.tag, {
	      type: 'expression',
	      dxfId: model.dxfId,
	      priority: model.priority,
	    });

	    this.formulaXform.render(xmlStream, model.formulae[0]);

	    xmlStream.closeNode();
	  }

	  renderCellIs(xmlStream, model) {
	    xmlStream.openNode(this.tag, {
	      type: 'cellIs',
	      dxfId: model.dxfId,
	      priority: model.priority,
	      operator: model.operator,
	    });

	    model.formulae.forEach(formula => {
	      this.formulaXform.render(xmlStream, formula);
	    });

	    xmlStream.closeNode();
	  }

	  renderTop10(xmlStream, model) {
	    xmlStream.leafNode(this.tag, {
	      type: 'top10',
	      dxfId: model.dxfId,
	      priority: model.priority,
	      percent: baseXform.toBoolAttribute(model.percent, false),
	      bottom: baseXform.toBoolAttribute(model.bottom, false),
	      rank: baseXform.toIntValue(model.rank, 10, true),
	    });
	  }

	  renderAboveAverage(xmlStream, model) {
	    xmlStream.leafNode(this.tag, {
	      type: 'aboveAverage',
	      dxfId: model.dxfId,
	      priority: model.priority,
	      aboveAverage: baseXform.toBoolAttribute(model.aboveAverage, true),
	    });
	  }

	  renderDataBar(xmlStream, model) {
	    xmlStream.openNode(this.tag, {
	      type: 'dataBar',
	      priority: model.priority,
	    });

	    this.databarXform.render(xmlStream, model);
	    this.extLstRefXform.render(xmlStream, model);

	    xmlStream.closeNode();
	  }

	  renderColorScale(xmlStream, model) {
	    xmlStream.openNode(this.tag, {
	      type: 'colorScale',
	      priority: model.priority,
	    });

	    this.colorScaleXform.render(xmlStream, model);

	    xmlStream.closeNode();
	  }

	  renderIconSet(xmlStream, model) {
	    // iconset is all primitive or all extLst
	    if (!CfRuleXform.isPrimitive(model)) {
	      return;
	    }

	    xmlStream.openNode(this.tag, {
	      type: 'iconSet',
	      priority: model.priority,
	    });

	    this.iconSetXform.render(xmlStream, model);

	    xmlStream.closeNode();
	  }

	  renderText(xmlStream, model) {
	    xmlStream.openNode(this.tag, {
	      type: model.operator,
	      dxfId: model.dxfId,
	      priority: model.priority,
	      operator: baseXform.toStringAttribute(model.operator, 'containsText'),
	    });

	    const formula = getTextFormula(model);
	    if (formula) {
	      this.formulaXform.render(xmlStream, formula);
	    }

	    xmlStream.closeNode();
	  }

	  renderTimePeriod(xmlStream, model) {
	    xmlStream.openNode(this.tag, {
	      type: 'timePeriod',
	      dxfId: model.dxfId,
	      priority: model.priority,
	      timePeriod: model.timePeriod,
	    });

	    const formula = getTimePeriodFormula(model);
	    if (formula) {
	      this.formulaXform.render(xmlStream, formula);
	    }

	    xmlStream.closeNode();
	  }

	  createNewModel({attributes}) {
	    return {
	      ...opType(attributes),
	      dxfId: baseXform.toIntValue(attributes.dxfId),
	      priority: baseXform.toIntValue(attributes.priority),
	      timePeriod: attributes.timePeriod,
	      percent: baseXform.toBoolValue(attributes.percent),
	      bottom: baseXform.toBoolValue(attributes.bottom),
	      rank: baseXform.toIntValue(attributes.rank),
	      aboveAverage: baseXform.toBoolValue(attributes.aboveAverage),
	    };
	  }

	  onParserClose(name, parser) {
	    switch (name) {
	      case 'dataBar':
	      case 'extLst':
	      case 'colorScale':
	      case 'iconSet':
	        // merge parser model with ours
	        Object.assign(this.model, parser.model);
	        break;

	      case 'formula':
	        // except - formula is a string and appends to formulae
	        this.model.formulae = this.model.formulae || [];
	        this.model.formulae.push(parser.model);
	        break;
	    }
	  }
	}

	var cfRuleXform = CfRuleXform;

	class ConditionalFormattingXform extends compositeXform {
	  constructor() {
	    super();

	    this.map = {
	      cfRule: new cfRuleXform(),
	    };
	  }

	  get tag() {
	    return 'conditionalFormatting';
	  }

	  render(xmlStream, model) {
	    // if there are no primitive rules, exit now
	    if (!model.rules.some(cfRuleXform.isPrimitive)) {
	      return;
	    }

	    xmlStream.openNode(this.tag, {sqref: model.ref});

	    model.rules.forEach(rule => {
	      if (cfRuleXform.isPrimitive(rule)) {
	        rule.ref = model.ref;
	        this.map.cfRule.render(xmlStream, rule);
	      }
	    });

	    xmlStream.closeNode();
	  }

	  createNewModel({attributes}) {
	    return {
	      ref: attributes.sqref,
	      rules: [],
	    };
	  }

	  onParserClose(name, parser) {
	    this.model.rules.push(parser.model);
	  }
	}

	var conditionalFormattingXform = ConditionalFormattingXform;

	class ConditionalFormattingsXform extends baseXform {
	  constructor() {
	    super();

	    this.cfXform = new conditionalFormattingXform();
	  }

	  get tag() {
	    return 'conditionalFormatting';
	  }

	  reset() {
	    this.model = [];
	  }

	  prepare(model, options) {
	    // ensure each rule has a priority value
	    let nextPriority = model.reduce(
	      (p, cf) => Math.max(p, ...cf.rules.map(rule => rule.priority || 0)),
	      1
	    );
	    model.forEach(cf => {
	      cf.rules.forEach(rule => {
	        if (!rule.priority) {
	          rule.priority = nextPriority++;
	        }

	        if (rule.style) {
	          rule.dxfId = options.styles.addDxfStyle(rule.style);
	        }
	      });
	    });
	  }

	  render(xmlStream, model) {
	    model.forEach(cf => {
	      this.cfXform.render(xmlStream, cf);
	    });
	  }

	  parseOpen(node) {
	    if (this.parser) {
	      this.parser.parseOpen(node);
	      return true;
	    }

	    switch (node.name) {
	      case 'conditionalFormatting':
	        this.parser = this.cfXform;
	        this.parser.parseOpen(node);
	        return true;

	      default:
	        return false;
	    }
	  }

	  parseText(text) {
	    if (this.parser) {
	      this.parser.parseText(text);
	    }
	  }

	  parseClose(name) {
	    if (this.parser) {
	      if (!this.parser.parseClose(name)) {
	        this.model.push(this.parser.model);
	        this.parser = undefined;
	        return false;
	      }
	      return true;
	    }
	    return false;
	  }

	  reconcile(model, options) {
	    model.forEach(cf => {
	      cf.rules.forEach(rule => {
	        if (rule.dxfId !== undefined) {
	          rule.style = options.styles.getDxfStyle(rule.dxfId);
	          delete rule.dxfId;
	        }
	      });
	    });
	  }
	}

	var conditionalFormattingsXform = ConditionalFormattingsXform;

	// Unique ID creation requires a high quality random # generator. In the browser we therefore
	// require the crypto API and do not support built-in fallback to lower quality random number
	// generators (like Math.random()).
	var getRandomValues;
	var rnds8 = new Uint8Array(16);
	function rng() {
	  // lazy load so that environments that need to polyfill have a chance to do so
	  if (!getRandomValues) {
	    // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation. Also,
	    // find the complete implementation of crypto (msCrypto) on IE11.
	    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== 'undefined' && typeof msCrypto.getRandomValues === 'function' && msCrypto.getRandomValues.bind(msCrypto);

	    if (!getRandomValues) {
	      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
	    }
	  }

	  return getRandomValues(rnds8);
	}

	var REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;

	function validate(uuid) {
	  return typeof uuid === 'string' && REGEX.test(uuid);
	}

	/**
	 * Convert array of 16 byte values to UUID string format of the form:
	 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
	 */

	var byteToHex = [];

	for (var i = 0; i < 256; ++i) {
	  byteToHex.push((i + 0x100).toString(16).substr(1));
	}

	function stringify(arr) {
	  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
	  // Note: Be careful editing this code!  It's been tuned for performance
	  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
	  var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one
	  // of the following:
	  // - One or more input array values don't map to a hex octet (leading to
	  // "undefined" in the uuid)
	  // - Invalid input values for the RFC `version` or `variant` fields

	  if (!validate(uuid)) {
	    throw TypeError('Stringified UUID is invalid');
	  }

	  return uuid;
	}

	//
	// Inspired by https://github.com/LiosK/UUID.js
	// and http://docs.python.org/library/uuid.html

	var _nodeId;

	var _clockseq; // Previous uuid creation time


	var _lastMSecs = 0;
	var _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details

	function v1(options, buf, offset) {
	  var i = buf && offset || 0;
	  var b = buf || new Array(16);
	  options = options || {};
	  var node = options.node || _nodeId;
	  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not
	  // specified.  We do this lazily to minimize issues related to insufficient
	  // system entropy.  See #189

	  if (node == null || clockseq == null) {
	    var seedBytes = options.random || (options.rng || rng)();

	    if (node == null) {
	      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
	      node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
	    }

	    if (clockseq == null) {
	      // Per 4.2.2, randomize (14 bit) clockseq
	      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
	    }
	  } // UUID timestamps are 100 nano-second units since the Gregorian epoch,
	  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
	  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
	  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.


	  var msecs = options.msecs !== undefined ? options.msecs : Date.now(); // Per 4.2.1.2, use count of uuid's generated during the current clock
	  // cycle to simulate higher resolution clock

	  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)

	  var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression

	  if (dt < 0 && options.clockseq === undefined) {
	    clockseq = clockseq + 1 & 0x3fff;
	  } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
	  // time interval


	  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
	    nsecs = 0;
	  } // Per 4.2.1.2 Throw error if too many uuids are requested


	  if (nsecs >= 10000) {
	    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
	  }

	  _lastMSecs = msecs;
	  _lastNSecs = nsecs;
	  _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch

	  msecs += 12219292800000; // `time_low`

	  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
	  b[i++] = tl >>> 24 & 0xff;
	  b[i++] = tl >>> 16 & 0xff;
	  b[i++] = tl >>> 8 & 0xff;
	  b[i++] = tl & 0xff; // `time_mid`

	  var tmh = msecs / 0x100000000 * 10000 & 0xfffffff;
	  b[i++] = tmh >>> 8 & 0xff;
	  b[i++] = tmh & 0xff; // `time_high_and_version`

	  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version

	  b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)

	  b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`

	  b[i++] = clockseq & 0xff; // `node`

	  for (var n = 0; n < 6; ++n) {
	    b[i + n] = node[n];
	  }

	  return buf || stringify(b);
	}

	function parse(uuid) {
	  if (!validate(uuid)) {
	    throw TypeError('Invalid UUID');
	  }

	  var v;
	  var arr = new Uint8Array(16); // Parse ########-....-....-....-............

	  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
	  arr[1] = v >>> 16 & 0xff;
	  arr[2] = v >>> 8 & 0xff;
	  arr[3] = v & 0xff; // Parse ........-####-....-....-............

	  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
	  arr[5] = v & 0xff; // Parse ........-....-####-....-............

	  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
	  arr[7] = v & 0xff; // Parse ........-....-....-####-............

	  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
	  arr[9] = v & 0xff; // Parse ........-....-....-....-############
	  // (Use "/" to avoid 32-bit truncation when bit-shifting high-order bytes)

	  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;
	  arr[11] = v / 0x100000000 & 0xff;
	  arr[12] = v >>> 24 & 0xff;
	  arr[13] = v >>> 16 & 0xff;
	  arr[14] = v >>> 8 & 0xff;
	  arr[15] = v & 0xff;
	  return arr;
	}

	function stringToBytes(str) {
	  str = unescape(encodeURIComponent(str)); // UTF8 escape

	  var bytes = [];

	  for (var i = 0; i < str.length; ++i) {
	    bytes.push(str.charCodeAt(i));
	  }

	  return bytes;
	}

	var DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';
	var URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';
	function v35 (name, version, hashfunc) {
	  function generateUUID(value, namespace, buf, offset) {
	    if (typeof value === 'string') {
	      value = stringToBytes(value);
	    }

	    if (typeof namespace === 'string') {
	      namespace = parse(namespace);
	    }

	    if (namespace.length !== 16) {
	      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');
	    } // Compute hash of namespace and value, Per 4.3
	    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =
	    // hashfunc([...namespace, ... value])`


	    var bytes = new Uint8Array(16 + value.length);
	    bytes.set(namespace);
	    bytes.set(value, namespace.length);
	    bytes = hashfunc(bytes);
	    bytes[6] = bytes[6] & 0x0f | version;
	    bytes[8] = bytes[8] & 0x3f | 0x80;

	    if (buf) {
	      offset = offset || 0;

	      for (var i = 0; i < 16; ++i) {
	        buf[offset + i] = bytes[i];
	      }

	      return buf;
	    }

	    return stringify(bytes);
	  } // Function#name is not settable on some platforms (#270)


	  try {
	    generateUUID.name = name; // eslint-disable-next-line no-empty
	  } catch (err) {} // For CommonJS default export support


	  generateUUID.DNS = DNS;
	  generateUUID.URL = URL;
	  return generateUUID;
	}

	/*
	 * Browser-compatible JavaScript MD5
	 *
	 * Modification of JavaScript MD5
	 * https://github.com/blueimp/JavaScript-MD5
	 *
	 * Copyright 2011, Sebastian Tschan
	 * https://blueimp.net
	 *
	 * Licensed under the MIT license:
	 * https://opensource.org/licenses/MIT
	 *
	 * Based on
	 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
	 * Digest Algorithm, as defined in RFC 1321.
	 * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009
	 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
	 * Distributed under the BSD License
	 * See http://pajhome.org.uk/crypt/md5 for more info.
	 */
	function md5(bytes) {
	  if (typeof bytes === 'string') {
	    var msg = unescape(encodeURIComponent(bytes)); // UTF8 escape

	    bytes = new Uint8Array(msg.length);

	    for (var i = 0; i < msg.length; ++i) {
	      bytes[i] = msg.charCodeAt(i);
	    }
	  }

	  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
	}
	/*
	 * Convert an array of little-endian words to an array of bytes
	 */


	function md5ToHexEncodedArray(input) {
	  var output = [];
	  var length32 = input.length * 32;
	  var hexTab = '0123456789abcdef';

	  for (var i = 0; i < length32; i += 8) {
	    var x = input[i >> 5] >>> i % 32 & 0xff;
	    var hex = parseInt(hexTab.charAt(x >>> 4 & 0x0f) + hexTab.charAt(x & 0x0f), 16);
	    output.push(hex);
	  }

	  return output;
	}
	/**
	 * Calculate output length with padding and bit length
	 */


	function getOutputLength(inputLength8) {
	  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
	}
	/*
	 * Calculate the MD5 of an array of little-endian words, and a bit length.
	 */


	function wordsToMd5(x, len) {
	  /* append padding */
	  x[len >> 5] |= 0x80 << len % 32;
	  x[getOutputLength(len) - 1] = len;
	  var a = 1732584193;
	  var b = -271733879;
	  var c = -1732584194;
	  var d = 271733878;

	  for (var i = 0; i < x.length; i += 16) {
	    var olda = a;
	    var oldb = b;
	    var oldc = c;
	    var oldd = d;
	    a = md5ff(a, b, c, d, x[i], 7, -680876936);
	    d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
	    c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
	    b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
	    a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
	    d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
	    c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
	    b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
	    a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
	    d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
	    c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
	    b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
	    a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
	    d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
	    c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
	    b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
	    a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
	    d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
	    c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
	    b = md5gg(b, c, d, a, x[i], 20, -373897302);
	    a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
	    d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
	    c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
	    b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
	    a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
	    d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
	    c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
	    b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
	    a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
	    d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
	    c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
	    b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
	    a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
	    d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
	    c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
	    b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
	    a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
	    d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
	    c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
	    b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
	    a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
	    d = md5hh(d, a, b, c, x[i], 11, -358537222);
	    c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
	    b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
	    a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
	    d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
	    c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
	    b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
	    a = md5ii(a, b, c, d, x[i], 6, -198630844);
	    d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
	    c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
	    b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
	    a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
	    d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
	    c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
	    b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
	    a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
	    d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
	    c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
	    b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
	    a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
	    d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
	    c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
	    b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
	    a = safeAdd(a, olda);
	    b = safeAdd(b, oldb);
	    c = safeAdd(c, oldc);
	    d = safeAdd(d, oldd);
	  }

	  return [a, b, c, d];
	}
	/*
	 * Convert an array bytes to an array of little-endian words
	 * Characters >255 have their high-byte silently ignored.
	 */


	function bytesToWords(input) {
	  if (input.length === 0) {
	    return [];
	  }

	  var length8 = input.length * 8;
	  var output = new Uint32Array(getOutputLength(length8));

	  for (var i = 0; i < length8; i += 8) {
	    output[i >> 5] |= (input[i / 8] & 0xff) << i % 32;
	  }

	  return output;
	}
	/*
	 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
	 * to work around bugs in some JS interpreters.
	 */


	function safeAdd(x, y) {
	  var lsw = (x & 0xffff) + (y & 0xffff);
	  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
	  return msw << 16 | lsw & 0xffff;
	}
	/*
	 * Bitwise rotate a 32-bit number to the left.
	 */


	function bitRotateLeft(num, cnt) {
	  return num << cnt | num >>> 32 - cnt;
	}
	/*
	 * These functions implement the four basic operations the algorithm uses.
	 */


	function md5cmn(q, a, b, x, s, t) {
	  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
	}

	function md5ff(a, b, c, d, x, s, t) {
	  return md5cmn(b & c | ~b & d, a, b, x, s, t);
	}

	function md5gg(a, b, c, d, x, s, t) {
	  return md5cmn(b & d | c & ~d, a, b, x, s, t);
	}

	function md5hh(a, b, c, d, x, s, t) {
	  return md5cmn(b ^ c ^ d, a, b, x, s, t);
	}

	function md5ii(a, b, c, d, x, s, t) {
	  return md5cmn(c ^ (b | ~d), a, b, x, s, t);
	}

	var v3 = v35('v3', 0x30, md5);

	function v4(options, buf, offset) {
	  options = options || {};
	  var rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`

	  rnds[6] = rnds[6] & 0x0f | 0x40;
	  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

	  if (buf) {
	    offset = offset || 0;

	    for (var i = 0; i < 16; ++i) {
	      buf[offset + i] = rnds[i];
	    }

	    return buf;
	  }

	  return stringify(rnds);
	}

	// Adapted from Chris Veness' SHA1 code at
	// http://www.movable-type.co.uk/scripts/sha1.html
	function f$8(s, x, y, z) {
	  switch (s) {
	    case 0:
	      return x & y ^ ~x & z;

	    case 1:
	      return x ^ y ^ z;

	    case 2:
	      return x & y ^ x & z ^ y & z;

	    case 3:
	      return x ^ y ^ z;
	  }
	}

	function ROTL(x, n) {
	  return x << n | x >>> 32 - n;
	}

	function sha1(bytes) {
	  var K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6];
	  var H = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];

	  if (typeof bytes === 'string') {
	    var msg = unescape(encodeURIComponent(bytes)); // UTF8 escape

	    bytes = [];

	    for (var i = 0; i < msg.length; ++i) {
	      bytes.push(msg.charCodeAt(i));
	    }
	  } else if (!Array.isArray(bytes)) {
	    // Convert Array-like to Array
	    bytes = Array.prototype.slice.call(bytes);
	  }

	  bytes.push(0x80);
	  var l = bytes.length / 4 + 2;
	  var N = Math.ceil(l / 16);
	  var M = new Array(N);

	  for (var _i = 0; _i < N; ++_i) {
	    var arr = new Uint32Array(16);

	    for (var j = 0; j < 16; ++j) {
	      arr[j] = bytes[_i * 64 + j * 4] << 24 | bytes[_i * 64 + j * 4 + 1] << 16 | bytes[_i * 64 + j * 4 + 2] << 8 | bytes[_i * 64 + j * 4 + 3];
	    }

	    M[_i] = arr;
	  }

	  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
	  M[N - 1][14] = Math.floor(M[N - 1][14]);
	  M[N - 1][15] = (bytes.length - 1) * 8 & 0xffffffff;

	  for (var _i2 = 0; _i2 < N; ++_i2) {
	    var W = new Uint32Array(80);

	    for (var t = 0; t < 16; ++t) {
	      W[t] = M[_i2][t];
	    }

	    for (var _t = 16; _t < 80; ++_t) {
	      W[_t] = ROTL(W[_t - 3] ^ W[_t - 8] ^ W[_t - 14] ^ W[_t - 16], 1);
	    }

	    var a = H[0];
	    var b = H[1];
	    var c = H[2];
	    var d = H[3];
	    var e = H[4];

	    for (var _t2 = 0; _t2 < 80; ++_t2) {
	      var s = Math.floor(_t2 / 20);
	      var T = ROTL(a, 5) + f$8(s, b, c, d) + e + K[s] + W[_t2] >>> 0;
	      e = d;
	      d = c;
	      c = ROTL(b, 30) >>> 0;
	      b = a;
	      a = T;
	    }

	    H[0] = H[0] + a >>> 0;
	    H[1] = H[1] + b >>> 0;
	    H[2] = H[2] + c >>> 0;
	    H[3] = H[3] + d >>> 0;
	    H[4] = H[4] + e >>> 0;
	  }

	  return [H[0] >> 24 & 0xff, H[0] >> 16 & 0xff, H[0] >> 8 & 0xff, H[0] & 0xff, H[1] >> 24 & 0xff, H[1] >> 16 & 0xff, H[1] >> 8 & 0xff, H[1] & 0xff, H[2] >> 24 & 0xff, H[2] >> 16 & 0xff, H[2] >> 8 & 0xff, H[2] & 0xff, H[3] >> 24 & 0xff, H[3] >> 16 & 0xff, H[3] >> 8 & 0xff, H[3] & 0xff, H[4] >> 24 & 0xff, H[4] >> 16 & 0xff, H[4] >> 8 & 0xff, H[4] & 0xff];
	}

	var v5 = v35('v5', 0x50, sha1);

	var nil = '00000000-0000-0000-0000-000000000000';

	function version$1(uuid) {
	  if (!validate(uuid)) {
	    throw TypeError('Invalid UUID');
	  }

	  return parseInt(uuid.substr(14, 1), 16);
	}

	var esmBrowser = /*#__PURE__*/Object.freeze({
		__proto__: null,
		v1: v1,
		v3: v3,
		v4: v4,
		v5: v5,
		NIL: nil,
		version: version$1,
		validate: validate,
		stringify: stringify,
		parse: parse
	});

	class FExtXform extends baseXform {
	  get tag() {
	    return 'xm:f';
	  }

	  render(xmlStream, model) {
	    xmlStream.leafNode(this.tag, null, model);
	  }

	  parseOpen() {
	    this.model = '';
	  }

	  parseText(text) {
	    this.model += text;
	  }

	  parseClose(name) {
	    return name !== this.tag;
	  }
	}

	var fExtXform = FExtXform;

	class CfvoExtXform extends compositeXform {
	  constructor() {
	    super();

	    this.map = {
	      'xm:f': (this.fExtXform = new fExtXform()),
	    };
	  }

	  get tag() {
	    return 'x14:cfvo';
	  }

	  render(xmlStream, model) {
	    xmlStream.openNode(this.tag, {
	      type: model.type,
	    });
	    if (model.value !== undefined) {
	      this.fExtXform.render(xmlStream, model.value);
	    }
	    xmlStream.closeNode();
	  }

	  createNewModel(node) {
	    return {
	      type: node.attributes.type,
	    };
	  }

	  onParserClose(name, parser) {
	    switch (name) {
	      case 'xm:f':
	        this.model.value = parser.model ? parseFloat(parser.model) : 0;
	        break;
	    }
	  }
	}

	var cfvoExtXform = CfvoExtXform;

	class DatabarExtXform extends compositeXform {
	  constructor() {
	    super();

	    this.map = {
	      'x14:cfvo': (this.cfvoXform = new cfvoExtXform()),
	      'x14:borderColor': (this.borderColorXform = new colorXform('x14:borderColor')),
	      'x14:negativeBorderColor': (this.negativeBorderColorXform = new colorXform(
	        'x14:negativeBorderColor'
	      )),
	      'x14:negativeFillColor': (this.negativeFillColorXform = new colorXform(
	        'x14:negativeFillColor'
	      )),
	      'x14:axisColor': (this.axisColorXform = new colorXform('x14:axisColor')),
	    };
	  }

	  static isExt(rule) {
	    // not all databars need ext
	    // TODO: refine this
	    return !rule.gradient;
	  }

	  get tag() {
	    return 'x14:dataBar';
	  }

	  render(xmlStream, model) {
	    xmlStream.openNode(this.tag, {
	      minLength: baseXform.toIntAttribute(model.minLength, 0, true),
	      maxLength: baseXform.toIntAttribute(model.maxLength, 100, true),
	      border: baseXform.toBoolAttribute(model.border, false),
	      gradient: baseXform.toBoolAttribute(model.gradient, true),
	      negativeBarColorSameAsPositive: baseXform.toBoolAttribute(
	        model.negativeBarColorSameAsPositive,
	        true
	      ),
	      negativeBarBorderColorSameAsPositive: baseXform.toBoolAttribute(
	        model.negativeBarBorderColorSameAsPositive,
	        true
	      ),
	      axisPosition: baseXform.toAttribute(model.axisPosition, 'auto'),
	      direction: baseXform.toAttribute(model.direction, 'leftToRight'),
	    });

	    model.cfvo.forEach(cfvo => {
	      this.cfvoXform.render(xmlStream, cfvo);
	    });

	    this.borderColorXform.render(xmlStream, model.borderColor);
	    this.negativeBorderColorXform.render(xmlStream, model.negativeBorderColor);
	    this.negativeFillColorXform.render(xmlStream, model.negativeFillColor);
	    this.axisColorXform.render(xmlStream, model.axisColor);

	    xmlStream.closeNode();
	  }

	  createNewModel({attributes}) {
	    return {
	      cfvo: [],
	      minLength: baseXform.toIntValue(attributes.minLength, 0),
	      maxLength: baseXform.toIntValue(attributes.maxLength, 100),
	      border: baseXform.toBoolValue(attributes.border, false),
	      gradient: baseXform.toBoolValue(attributes.gradient, true),
	      negativeBarColorSameAsPositive: baseXform.toBoolValue(
	        attributes.negativeBarColorSameAsPositive,
	        true
	      ),
	      negativeBarBorderColorSameAsPositive: baseXform.toBoolValue(
	        attributes.negativeBarBorderColorSameAsPositive,
	        true
	      ),
	      axisPosition: baseXform.toStringValue(attributes.axisPosition, 'auto'),
	      direction: baseXform.toStringValue(attributes.direction, 'leftToRight'),
	    };
	  }

	  onParserClose(name, parser) {
	    const [, prop] = name.split(':');
	    switch (prop) {
	      case 'cfvo':
	        this.model.cfvo.push(parser.model);
	        break;

	      default:
	        this.model[prop] = parser.model;
	        break;
	    }
	  }
	}

	var databarExtXform = DatabarExtXform;

	class CfIconExtXform extends baseXform {
	  get tag() {
	    return 'x14:cfIcon';
	  }

	  render(xmlStream, model) {
	    xmlStream.leafNode(this.tag, {
	      iconSet: model.iconSet,
	      iconId: model.iconId,
	    });
	  }

	  parseOpen({attributes}) {
	    this.model = {
	      iconSet: attributes.iconSet,
	      iconId: baseXform.toIntValue(attributes.iconId),
	    };
	  }

	  parseClose(name) {
	    return name !== this.tag;
	  }
	}

	var cfIconExtXform = CfIconExtXform;

	class IconSetExtXform extends compositeXform {
	  constructor() {
	    super();

	    this.map = {
	      'x14:cfvo': (this.cfvoXform = new cfvoExtXform()),
	      'x14:cfIcon': (this.cfIconXform = new cfIconExtXform()),
	    };
	  }

	  get tag() {
	    return 'x14:iconSet';
	  }

	  render(xmlStream, model) {
	    xmlStream.openNode(this.tag, {
	      iconSet: baseXform.toStringAttribute(model.iconSet),
	      reverse: baseXform.toBoolAttribute(model.reverse, false),
	      showValue: baseXform.toBoolAttribute(model.showValue, true),
	      custom: baseXform.toBoolAttribute(model.icons, false),
	    });

	    model.cfvo.forEach(cfvo => {
	      this.cfvoXform.render(xmlStream, cfvo);
	    });

	    if (model.icons) {
	      model.icons.forEach((icon, i) => {
	        icon.iconId = i;
	        this.cfIconXform.render(xmlStream, icon);
	      });
	    }

	    xmlStream.closeNode();
	  }

	  createNewModel({attributes}) {
	    return {
	      cfvo: [],
	      iconSet: baseXform.toStringValue(attributes.iconSet, '3TrafficLights'),
	      reverse: baseXform.toBoolValue(attributes.reverse, false),
	      showValue: baseXform.toBoolValue(attributes.showValue, true),
	    };
	  }

	  onParserClose(name, parser) {
	    const [, prop] = name.split(':');
	    switch (prop) {
	      case 'cfvo':
	        this.model.cfvo.push(parser.model);
	        break;

	      case 'cfIcon':
	        if (!this.model.icons) {
	          this.model.icons = [];
	        }
	        this.model.icons.push(parser.model);
	        break;

	      default:
	        this.model[prop] = parser.model;
	        break;
	    }
	  }
	}

	var iconSetExtXform = IconSetExtXform;

	const {v4: uuidv4} = esmBrowser;






	const extIcons$1 = {
	  '3Triangles': true,
	  '3Stars': true,
	  '5Boxes': true,
	};

	class CfRuleExtXform extends compositeXform {
	  constructor() {
	    super();

	    this.map = {
	      'x14:dataBar': (this.databarXform = new databarExtXform()),
	      'x14:iconSet': (this.iconSetXform = new iconSetExtXform()),
	    };
	  }

	  get tag() {
	    return 'x14:cfRule';
	  }

	  static isExt(rule) {
	    // is this rule primitive?
	    if (rule.type === 'dataBar') {
	      return databarExtXform.isExt(rule);
	    }
	    if (rule.type === 'iconSet') {
	      if (rule.custom || extIcons$1[rule.iconSet]) {
	        return true;
	      }
	    }
	    return false;
	  }

	  prepare(model) {
	    if (CfRuleExtXform.isExt(model)) {
	      model.x14Id = `{${uuidv4()}}`.toUpperCase();
	    }
	  }

	  render(xmlStream, model) {
	    if (!CfRuleExtXform.isExt(model)) {
	      return;
	    }

	    switch (model.type) {
	      case 'dataBar':
	        this.renderDataBar(xmlStream, model);
	        break;
	      case 'iconSet':
	        this.renderIconSet(xmlStream, model);
	        break;
	    }
	  }

	  renderDataBar(xmlStream, model) {
	    xmlStream.openNode(this.tag, {
	      type: 'dataBar',
	      id: model.x14Id,
	    });

	    this.databarXform.render(xmlStream, model);

	    xmlStream.closeNode();
	  }

	  renderIconSet(xmlStream, model) {
	    xmlStream.openNode(this.tag, {
	      type: 'iconSet',
	      priority: model.priority,
	      id: model.x14Id || `{${uuidv4()}}`,
	    });

	    this.iconSetXform.render(xmlStream, model);

	    xmlStream.closeNode();
	  }

	  createNewModel({attributes}) {
	    return {
	      type: attributes.type,
	      x14Id: attributes.id,
	      priority: baseXform.toIntValue(attributes.priority),
	    };
	  }

	  onParserClose(name, parser) {
	    Object.assign(this.model, parser.model);
	  }
	}

	var cfRuleExtXform = CfRuleExtXform;

	class SqrefExtXform extends baseXform {
	  get tag() {
	    return 'xm:sqref';
	  }

	  render(xmlStream, model) {
	    xmlStream.leafNode(this.tag, null, model);
	  }

	  parseOpen() {
	    this.model = '';
	  }

	  parseText(text) {
	    this.model += text;
	  }

	  parseClose(name) {
	    return name !== this.tag;
	  }
	}

	var sqrefExtXform = SqrefExtXform;

	class ConditionalFormattingExtXform extends compositeXform {
	  constructor() {
	    super();

	    this.map = {
	      'xm:sqref': (this.sqRef = new sqrefExtXform()),
	      'x14:cfRule': (this.cfRule = new cfRuleExtXform()),
	    };
	  }

	  get tag() {
	    return 'x14:conditionalFormatting';
	  }

	  prepare(model, options) {
	    model.rules.forEach(rule => {
	      this.cfRule.prepare(rule, options);
	    });
	  }

	  render(xmlStream, model) {
	    if (!model.rules.some(cfRuleExtXform.isExt)) {
	      return;
	    }

	    xmlStream.openNode(this.tag, {
	      'xmlns:xm': 'http://schemas.microsoft.com/office/excel/2006/main',
	    });

	    model.rules.filter(cfRuleExtXform.isExt).forEach(rule => this.cfRule.render(xmlStream, rule));

	    // for some odd reason, Excel needs the <xm:sqref> node to be after the rules
	    this.sqRef.render(xmlStream, model.ref);

	    xmlStream.closeNode();
	  }

	  createNewModel() {
	    return {
	      rules: [],
	    };
	  }

	  onParserClose(name, parser) {
	    switch (name) {
	      case 'xm:sqref':
	        this.model.ref = parser.model;
	        break;

	      case 'x14:cfRule':
	        this.model.rules.push(parser.model);
	        break;
	    }
	  }
	}

	var conditionalFormattingExtXform = ConditionalFormattingExtXform;

	class ConditionalFormattingsExtXform extends compositeXform {
	  constructor() {
	    super();

	    this.map = {
	      'x14:conditionalFormatting': (this.cfXform = new conditionalFormattingExtXform()),
	    };
	  }

	  get tag() {
	    return 'x14:conditionalFormattings';
	  }

	  hasContent(model) {
	    if (model.hasExtContent === undefined) {
	      model.hasExtContent = model.some(cf => cf.rules.some(cfRuleExtXform.isExt));
	    }
	    return model.hasExtContent;
	  }

	  prepare(model, options) {
	    model.forEach(cf => {
	      this.cfXform.prepare(cf, options);
	    });
	  }

	  render(xmlStream, model) {
	    if (this.hasContent(model)) {
	      xmlStream.openNode(this.tag);
	      model.forEach(cf => this.cfXform.render(xmlStream, cf));
	      xmlStream.closeNode();
	    }
	  }

	  createNewModel() {
	    return [];
	  }

	  onParserClose(name, parser) {
	    // model is array of conditional formatting objects
	    this.model.push(parser.model);
	  }
	}

	var conditionalFormattingsExtXform = ConditionalFormattingsExtXform;

	/* eslint-disable max-classes-per-file */




	class ExtXform$1 extends compositeXform {
	  constructor() {
	    super();
	    this.map = {
	      'x14:conditionalFormattings': (this.conditionalFormattings = new conditionalFormattingsExtXform()),
	    };
	  }

	  get tag() {
	    return 'ext';
	  }

	  hasContent(model) {
	    return this.conditionalFormattings.hasContent(model.conditionalFormattings);
	  }

	  prepare(model, options) {
	    this.conditionalFormattings.prepare(model.conditionalFormattings, options);
	  }

	  render(xmlStream, model) {
	    xmlStream.openNode('ext', {
	      uri: '{78C0D931-6437-407d-A8EE-F0AAD7539E65}',
	      'xmlns:x14': 'http://schemas.microsoft.com/office/spreadsheetml/2009/9/main',
	    });

	    this.conditionalFormattings.render(xmlStream, model.conditionalFormattings);

	    xmlStream.closeNode();
	  }

	  createNewModel() {
	    return {};
	  }

	  onParserClose(name, parser) {
	    this.model[name] = parser.model;
	  }
	}

	class ExtLstXform extends compositeXform {
	  constructor() {
	    super();

	    this.map = {
	      ext: (this.ext = new ExtXform$1()),
	    };
	  }

	  get tag() {
	    return 'extLst';
	  }

	  prepare(model, options) {
	    this.ext.prepare(model, options);
	  }

	  hasContent(model) {
	    return this.ext.hasContent(model);
	  }

	  render(xmlStream, model) {
	    if (!this.hasContent(model)) {
	      return;
	    }

	    xmlStream.openNode('extLst');
	    this.ext.render(xmlStream, model);
	    xmlStream.closeNode();
	  }

	  createNewModel() {
	    return {};
	  }

	  onParserClose(name, parser) {
	    Object.assign(this.model, parser.model);
	  }
	}

	var extLstXform = ExtLstXform;

	const mergeRule = (rule, extRule) => {
	  Object.keys(extRule).forEach(key => {
	    const value = rule[key];
	    const extValue = extRule[key];
	    if (value === undefined && extValue !== undefined) {
	      rule[key] = extValue;
	    }
	  });
	};

	const mergeConditionalFormattings = (model, extModel) => {
	  // conditional formattings are rendered in worksheet.conditionalFormatting and also in
	  // worksheet.extLst.ext.x14:conditionalFormattings
	  // some (e.g. dataBar) are even spread across both!
	  if (!extModel || !extModel.length) {
	    return model;
	  }
	  if (!model || !model.length) {
	    return extModel;
	  }

	  // index model rules by x14Id
	  const cfMap = {};
	  const ruleMap = {};
	  model.forEach(cf => {
	    cfMap[cf.ref] = cf;
	    cf.rules.forEach(rule => {
	      const {x14Id} = rule;
	      if (x14Id) {
	        ruleMap[x14Id] = rule;
	      }
	    });
	  });

	  extModel.forEach(extCf => {
	    extCf.rules.forEach(extRule => {
	      const rule = ruleMap[extRule.x14Id];
	      if (rule) {
	        // merge with matching rule
	        mergeRule(rule, extRule);
	      } else if (cfMap[extCf.ref]) {
	        // reuse existing cf ref
	        cfMap[extCf.ref].rules.push(extRule);
	      } else {
	        // create new cf
	        model.push({
	          ref: extCf.ref,
	          rules: [extRule],
	        });
	      }
	    });
	  });

	  // need to cope with rules in extModel that don't exist in model
	  return model;
	};

	class WorkSheetXform extends baseXform {
	  constructor(options) {
	    super();

	    const {maxRows, maxCols} = options || {};
	    this.map = {
	      sheetPr: new sheetPropertiesXform(),
	      dimension: new dimensionXform(),
	      sheetViews: new listXform({
	        tag: 'sheetViews',
	        count: false,
	        childXform: new sheetViewXform(),
	      }),
	      sheetFormatPr: new sheetFormatPropertiesXform(),
	      cols: new listXform({tag: 'cols', count: false, childXform: new colXform()}),
	      sheetData: new listXform({
	        tag: 'sheetData',
	        count: false,
	        empty: true,
	        childXform: new rowXform({maxItems: maxCols}),
	        maxItems: maxRows,
	      }),
	      autoFilter: new autoFilterXform(),
	      mergeCells: new listXform({tag: 'mergeCells', count: true, childXform: new mergeCellXform()}),
	      rowBreaks: new rowBreaksXform(),
	      hyperlinks: new listXform({
	        tag: 'hyperlinks',
	        count: false,
	        childXform: new hyperlinkXform(),
	      }),
	      pageMargins: new pageMarginsXform(),
	      dataValidations: new dataValidationsXform(),
	      pageSetup: new pageSetupXform(),
	      headerFooter: new headerFooterXform(),
	      printOptions: new printOptionsXform(),
	      picture: new pictureXform(),
	      drawing: new drawingXform(),
	      sheetProtection: new sheetProtectionXform(),
	      tableParts: new listXform({tag: 'tableParts', count: true, childXform: new tablePartXform()}),
	      conditionalFormatting: new conditionalFormattingsXform(),
	      extLst: new extLstXform(),
	    };
	  }

	  prepare(model, options) {
	    options.merges = new merges();
	    model.hyperlinks = options.hyperlinks = [];
	    model.comments = options.comments = [];

	    options.formulae = {};
	    options.siFormulae = 0;
	    this.map.cols.prepare(model.cols, options);
	    this.map.sheetData.prepare(model.rows, options);
	    this.map.conditionalFormatting.prepare(model.conditionalFormattings, options);

	    model.mergeCells = options.merges.mergeCells;

	    // prepare relationships
	    const rels = (model.rels = []);

	    function nextRid(r) {
	      return `rId${r.length + 1}`;
	    }

	    model.hyperlinks.forEach(hyperlink => {
	      const rId = nextRid(rels);
	      hyperlink.rId = rId;
	      rels.push({
	        Id: rId,
	        Type: relType.Hyperlink,
	        Target: hyperlink.target,
	        TargetMode: 'External',
	      });
	    });

	    // prepare comment relationships
	    if (model.comments.length > 0) {
	      const comment = {
	        Id: nextRid(rels),
	        Type: relType.Comments,
	        Target: `../comments${model.id}.xml`,
	      };
	      rels.push(comment);
	      const vmlDrawing = {
	        Id: nextRid(rels),
	        Type: relType.VmlDrawing,
	        Target: `../drawings/vmlDrawing${model.id}.vml`,
	      };
	      rels.push(vmlDrawing);

	      model.comments.forEach(item => {
	        item.refAddress = colCache_1.decodeAddress(item.ref);
	      });

	      options.commentRefs.push({
	        commentName: `comments${model.id}`,
	        vmlDrawing: `vmlDrawing${model.id}`,
	      });
	    }

	    const drawingRelsHash = [];
	    let bookImage;
	    model.media.forEach(medium => {
	      if (medium.type === 'background') {
	        const rId = nextRid(rels);
	        bookImage = options.media[medium.imageId];
	        rels.push({
	          Id: rId,
	          Type: relType.Image,
	          Target: `../media/${bookImage.name}.${bookImage.extension}`,
	        });
	        model.background = {
	          rId,
	        };
	        model.image = options.media[medium.imageId];
	      } else if (medium.type === 'image') {
	        let {drawing} = model;
	        bookImage = options.media[medium.imageId];
	        if (!drawing) {
	          drawing = model.drawing = {
	            rId: nextRid(rels),
	            name: `drawing${++options.drawingsCount}`,
	            anchors: [],
	            rels: [],
	          };
	          options.drawings.push(drawing);
	          rels.push({
	            Id: drawing.rId,
	            Type: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/drawing',
	            Target: `../drawings/${drawing.name}.xml`,
	          });
	        }
	        let rIdImage =
	          this.preImageId === medium.imageId
	            ? drawingRelsHash[medium.imageId]
	            : drawingRelsHash[drawing.rels.length];
	        if (!rIdImage) {
	          rIdImage = nextRid(drawing.rels);
	          drawingRelsHash[drawing.rels.length] = rIdImage;
	          drawing.rels.push({
	            Id: rIdImage,
	            Type: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/image',
	            Target: `../media/${bookImage.name}.${bookImage.extension}`,
	          });
	        }

	        const anchor = {
	          picture: {
	            rId: rIdImage,
	          },
	          range: medium.range,
	        };
	        if (medium.hyperlinks && medium.hyperlinks.hyperlink) {
	          const rIdHyperLink = nextRid(drawing.rels);
	          drawingRelsHash[drawing.rels.length] = rIdHyperLink;
	          anchor.picture.hyperlinks = {
	            tooltip: medium.hyperlinks.tooltip,
	            rId: rIdHyperLink,
	          };
	          drawing.rels.push({
	            Id: rIdHyperLink,
	            Type: relType.Hyperlink,
	            Target: medium.hyperlinks.hyperlink,
	            TargetMode: 'External',
	          });
	        }
	        this.preImageId = medium.imageId;
	        drawing.anchors.push(anchor);
	      }
	    });

	    // prepare tables
	    model.tables.forEach(table => {
	      // relationships
	      const rId = nextRid(rels);
	      table.rId = rId;
	      rels.push({
	        Id: rId,
	        Type: relType.Table,
	        Target: `../tables/${table.target}`,
	      });

	      // dynamic styles
	      table.columns.forEach(column => {
	        const {style} = column;
	        if (style) {
	          column.dxfId = options.styles.addDxfStyle(style);
	        }
	      });
	    });

	    // prepare ext items
	    this.map.extLst.prepare(model, options);
	  }

	  render(xmlStream$1, model) {
	    xmlStream$1.openXml(xmlStream.StdDocAttributes);
	    xmlStream$1.openNode('worksheet', WorkSheetXform.WORKSHEET_ATTRIBUTES);

	    const sheetFormatPropertiesModel = model.properties
	      ? {
	          defaultRowHeight: model.properties.defaultRowHeight,
	          dyDescent: model.properties.dyDescent,
	          outlineLevelCol: model.properties.outlineLevelCol,
	          outlineLevelRow: model.properties.outlineLevelRow,
	        }
	      : undefined;
	    if (model.properties && model.properties.defaultColWidth) {
	      sheetFormatPropertiesModel.defaultColWidth = model.properties.defaultColWidth;
	    }
	    const sheetPropertiesModel = {
	      outlineProperties: model.properties && model.properties.outlineProperties,
	      tabColor: model.properties && model.properties.tabColor,
	      pageSetup:
	        model.pageSetup && model.pageSetup.fitToPage
	          ? {
	              fitToPage: model.pageSetup.fitToPage,
	            }
	          : undefined,
	    };
	    const pageMarginsModel = model.pageSetup && model.pageSetup.margins;
	    const printOptionsModel = {
	      showRowColHeaders: model.pageSetup && model.pageSetup.showRowColHeaders,
	      showGridLines: model.pageSetup && model.pageSetup.showGridLines,
	      horizontalCentered: model.pageSetup && model.pageSetup.horizontalCentered,
	      verticalCentered: model.pageSetup && model.pageSetup.verticalCentered,
	    };
	    const sheetProtectionModel = model.sheetProtection;

	    this.map.sheetPr.render(xmlStream$1, sheetPropertiesModel);
	    this.map.dimension.render(xmlStream$1, model.dimensions);
	    this.map.sheetViews.render(xmlStream$1, model.views);
	    this.map.sheetFormatPr.render(xmlStream$1, sheetFormatPropertiesModel);
	    this.map.cols.render(xmlStream$1, model.cols);
	    this.map.sheetData.render(xmlStream$1, model.rows);
	    this.map.sheetProtection.render(xmlStream$1, sheetProtectionModel); // Note: must be after sheetData and before autoFilter
	    this.map.autoFilter.render(xmlStream$1, model.autoFilter);
	    this.map.mergeCells.render(xmlStream$1, model.mergeCells);
	    this.map.conditionalFormatting.render(xmlStream$1, model.conditionalFormattings); // Note: must be before dataValidations
	    this.map.dataValidations.render(xmlStream$1, model.dataValidations);

	    // For some reason hyperlinks have to be after the data validations
	    this.map.hyperlinks.render(xmlStream$1, model.hyperlinks);

	    this.map.printOptions.render(xmlStream$1, printOptionsModel); // Note: must be before pageMargins
	    this.map.pageMargins.render(xmlStream$1, pageMarginsModel);
	    this.map.pageSetup.render(xmlStream$1, model.pageSetup);
	    this.map.headerFooter.render(xmlStream$1, model.headerFooter);
	    this.map.rowBreaks.render(xmlStream$1, model.rowBreaks);
	    this.map.drawing.render(xmlStream$1, model.drawing); // Note: must be after rowBreaks
	    this.map.picture.render(xmlStream$1, model.background); // Note: must be after drawing
	    this.map.tableParts.render(xmlStream$1, model.tables);

	    this.map.extLst.render(xmlStream$1, model);

	    if (model.rels) {
	      // add a <legacyDrawing /> node for each comment
	      model.rels.forEach(rel => {
	        if (rel.Type === relType.VmlDrawing) {
	          xmlStream$1.leafNode('legacyDrawing', {'r:id': rel.Id});
	        }
	      });
	    }

	    xmlStream$1.closeNode();
	  }

	  parseOpen(node) {
	    if (this.parser) {
	      this.parser.parseOpen(node);
	      return true;
	    }

	    if (node.name === 'worksheet') {
	      underDash.each(this.map, xform => {
	        xform.reset();
	      });
	      return true;
	    }

	    this.parser = this.map[node.name];
	    if (this.parser) {
	      this.parser.parseOpen(node);
	    }
	    return true;
	  }

	  parseText(text) {
	    if (this.parser) {
	      this.parser.parseText(text);
	    }
	  }

	  parseClose(name) {
	    if (this.parser) {
	      if (!this.parser.parseClose(name)) {
	        this.parser = undefined;
	      }
	      return true;
	    }
	    switch (name) {
	      case 'worksheet': {
	        const properties = this.map.sheetFormatPr.model || {};
	        if (this.map.sheetPr.model && this.map.sheetPr.model.tabColor) {
	          properties.tabColor = this.map.sheetPr.model.tabColor;
	        }
	        if (this.map.sheetPr.model && this.map.sheetPr.model.outlineProperties) {
	          properties.outlineProperties = this.map.sheetPr.model.outlineProperties;
	        }
	        const sheetProperties = {
	          fitToPage:
	            (this.map.sheetPr.model &&
	              this.map.sheetPr.model.pageSetup &&
	              this.map.sheetPr.model.pageSetup.fitToPage) ||
	            false,
	          margins: this.map.pageMargins.model,
	        };
	        const pageSetup = Object.assign(
	          sheetProperties,
	          this.map.pageSetup.model,
	          this.map.printOptions.model
	        );
	        const conditionalFormattings = mergeConditionalFormattings(
	          this.map.conditionalFormatting.model,
	          this.map.extLst.model && this.map.extLst.model['x14:conditionalFormattings']
	        );
	        this.model = {
	          dimensions: this.map.dimension.model,
	          cols: this.map.cols.model,
	          rows: this.map.sheetData.model,
	          mergeCells: this.map.mergeCells.model,
	          hyperlinks: this.map.hyperlinks.model,
	          dataValidations: this.map.dataValidations.model,
	          properties,
	          views: this.map.sheetViews.model,
	          pageSetup,
	          headerFooter: this.map.headerFooter.model,
	          background: this.map.picture.model,
	          drawing: this.map.drawing.model,
	          tables: this.map.tableParts.model,
	          conditionalFormattings,
	        };

	        if (this.map.autoFilter.model) {
	          this.model.autoFilter = this.map.autoFilter.model;
	        }
	        if (this.map.sheetProtection.model) {
	          this.model.sheetProtection = this.map.sheetProtection.model;
	        }

	        return false;
	      }

	      default:
	        // not quite sure how we get here!
	        return true;
	    }
	  }

	  reconcile(model, options) {
	    // options.merges = new Merges();
	    // options.merges.reconcile(model.mergeCells, model.rows);
	    const rels = (model.relationships || []).reduce((h, rel) => {
	      h[rel.Id] = rel;
	      if (rel.Type === relType.Comments) {
	        model.comments = options.comments[rel.Target].comments;
	      }
	      if (rel.Type === relType.VmlDrawing && model.comments && model.comments.length) {
	        const vmlComment = options.vmlDrawings[rel.Target].comments;
	        model.comments.forEach((comment, index) => {
	          comment.note = Object.assign({}, comment.note, vmlComment[index]);
	        });
	      }
	      return h;
	    }, {});
	    options.commentsMap = (model.comments || []).reduce((h, comment) => {
	      if (comment.ref) {
	        h[comment.ref] = comment;
	      }
	      return h;
	    }, {});
	    options.hyperlinkMap = (model.hyperlinks || []).reduce((h, hyperlink) => {
	      if (hyperlink.rId) {
	        h[hyperlink.address] = rels[hyperlink.rId].Target;
	      }
	      return h;
	    }, {});
	    options.formulae = {};

	    // compact the rows and cells
	    model.rows = (model.rows && model.rows.filter(Boolean)) || [];
	    model.rows.forEach(row => {
	      row.cells = (row.cells && row.cells.filter(Boolean)) || [];
	    });

	    this.map.cols.reconcile(model.cols, options);
	    this.map.sheetData.reconcile(model.rows, options);
	    this.map.conditionalFormatting.reconcile(model.conditionalFormattings, options);

	    model.media = [];
	    if (model.drawing) {
	      const drawingRel = rels[model.drawing.rId];
	      const match = drawingRel.Target.match(/\/drawings\/([a-zA-Z0-9]+)[.][a-zA-Z]{3,4}$/);
	      if (match) {
	        const drawingName = match[1];
	        const drawing = options.drawings[drawingName];
	        drawing.anchors.forEach(anchor => {
	          if (anchor.medium) {
	            const image = {
	              type: 'image',
	              imageId: anchor.medium.index,
	              range: anchor.range,
	              hyperlinks: anchor.picture.hyperlinks,
	            };
	            model.media.push(image);
	          }
	        });
	      }
	    }

	    const backgroundRel = model.background && rels[model.background.rId];
	    if (backgroundRel) {
	      const target = backgroundRel.Target.split('/media/')[1];
	      const imageId = options.mediaIndex && options.mediaIndex[target];
	      if (imageId !== undefined) {
	        model.media.push({
	          type: 'background',
	          imageId,
	        });
	      }
	    }

	    model.tables = (model.tables || []).map(tablePart => {
	      const rel = rels[tablePart.rId];
	      return options.tables[rel.Target];
	    });

	    delete model.relationships;
	    delete model.hyperlinks;
	    delete model.comments;
	  }
	}

	WorkSheetXform.WORKSHEET_ATTRIBUTES = {
	  xmlns: 'http://schemas.openxmlformats.org/spreadsheetml/2006/main',
	  'xmlns:r': 'http://schemas.openxmlformats.org/officeDocument/2006/relationships',
	  'xmlns:mc': 'http://schemas.openxmlformats.org/markup-compatibility/2006',
	  'mc:Ignorable': 'x14ac',
	  'xmlns:x14ac': 'http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac',
	};

	var worksheetXform = WorkSheetXform;

	class BaseCellAnchorXform extends baseXform {
	  parseOpen(node) {
	    if (this.parser) {
	      this.parser.parseOpen(node);
	      return true;
	    }
	    switch (node.name) {
	      case this.tag:
	        this.reset();
	        this.model = {
	          range: {
	            editAs: node.attributes.editAs || 'oneCell',
	          },
	        };
	        break;
	      default:
	        this.parser = this.map[node.name];
	        if (this.parser) {
	          this.parser.parseOpen(node);
	        }
	        break;
	    }
	    return true;
	  }

	  parseText(text) {
	    if (this.parser) {
	      this.parser.parseText(text);
	    }
	  }

	  reconcilePicture(model, options) {
	    if (model && model.rId) {
	      const rel = options.rels[model.rId];
	      const match = rel.Target.match(/.*\/media\/(.+[.][a-zA-Z]{3,4})/);
	      if (match) {
	        const name = match[1];
	        const mediaId = options.mediaIndex[name];
	        return options.media[mediaId];
	      }
	    }
	    return undefined;
	  }
	}

	var baseCellAnchorXform = BaseCellAnchorXform;

	class CellPositionXform extends baseXform {
	  constructor(options) {
	    super();

	    this.tag = options.tag;
	    this.map = {
	      'xdr:col': new integerXform({tag: 'xdr:col', zero: true}),
	      'xdr:colOff': new integerXform({tag: 'xdr:colOff', zero: true}),
	      'xdr:row': new integerXform({tag: 'xdr:row', zero: true}),
	      'xdr:rowOff': new integerXform({tag: 'xdr:rowOff', zero: true}),
	    };
	  }

	  render(xmlStream, model) {
	    xmlStream.openNode(this.tag);

	    this.map['xdr:col'].render(xmlStream, model.nativeCol);
	    this.map['xdr:colOff'].render(xmlStream, model.nativeColOff);

	    this.map['xdr:row'].render(xmlStream, model.nativeRow);
	    this.map['xdr:rowOff'].render(xmlStream, model.nativeRowOff);

	    xmlStream.closeNode();
	  }

	  parseOpen(node) {
	    if (this.parser) {
	      this.parser.parseOpen(node);
	      return true;
	    }
	    switch (node.name) {
	      case this.tag:
	        this.reset();
	        break;
	      default:
	        this.parser = this.map[node.name];
	        if (this.parser) {
	          this.parser.parseOpen(node);
	        }
	        break;
	    }
	    return true;
	  }

	  parseText(text) {
	    if (this.parser) {
	      this.parser.parseText(text);
	    }
	  }

	  parseClose(name) {
	    if (this.parser) {
	      if (!this.parser.parseClose(name)) {
	        this.parser = undefined;
	      }
	      return true;
	    }
	    switch (name) {
	      case this.tag:
	        this.model = {
	          nativeCol: this.map['xdr:col'].model,
	          nativeColOff: this.map['xdr:colOff'].model,
	          nativeRow: this.map['xdr:row'].model,
	          nativeRowOff: this.map['xdr:rowOff'].model,
	        };
	        return false;
	      default:
	        // not quite sure how we get here!
	        return true;
	    }
	  }
	}

	var cellPositionXform = CellPositionXform;

	class BlipXform extends baseXform {
	  get tag() {
	    return 'a:blip';
	  }

	  render(xmlStream, model) {
	    xmlStream.leafNode(this.tag, {
	      'xmlns:r': 'http://schemas.openxmlformats.org/officeDocument/2006/relationships',
	      'r:embed': model.rId,
	      cstate: 'print',
	    });
	    // TODO: handle children (e.g. a:extLst=>a:ext=>a14:useLocalDpi
	  }

	  parseOpen(node) {
	    switch (node.name) {
	      case this.tag:
	        this.model = {
	          rId: node.attributes['r:embed'],
	        };
	        return true;
	      default:
	        return true;
	    }
	  }

	  parseText() {}

	  parseClose(name) {
	    switch (name) {
	      case this.tag:
	        return false;
	      default:
	        // unprocessed internal nodes
	        return true;
	    }
	  }
	}

	var blipXform = BlipXform;

	class BlipFillXform extends baseXform {
	  constructor() {
	    super();

	    this.map = {
	      'a:blip': new blipXform(),
	    };
	  }

	  get tag() {
	    return 'xdr:blipFill';
	  }

	  render(xmlStream, model) {
	    xmlStream.openNode(this.tag);

	    this.map['a:blip'].render(xmlStream, model);

	    // TODO: options for this + parsing
	    xmlStream.openNode('a:stretch');
	    xmlStream.leafNode('a:fillRect');
	    xmlStream.closeNode();

	    xmlStream.closeNode();
	  }

	  parseOpen(node) {
	    if (this.parser) {
	      this.parser.parseOpen(node);
	      return true;
	    }

	    switch (node.name) {
	      case this.tag:
	        this.reset();
	        break;

	      default:
	        this.parser = this.map[node.name];
	        if (this.parser) {
	          this.parser.parseOpen(node);
	        }
	        break;
	    }
	    return true;
	  }

	  parseText() {}

	  parseClose(name) {
	    if (this.parser) {
	      if (!this.parser.parseClose(name)) {
	        this.parser = undefined;
	      }
	      return true;
	    }
	    switch (name) {
	      case this.tag:
	        this.model = this.map['a:blip'].model;
	        return false;

	      default:
	        return true;
	    }
	  }
	}

	var blipFillXform = BlipFillXform;

	class HLinkClickXform extends baseXform {
	  get tag() {
	    return 'a:hlinkClick';
	  }

	  render(xmlStream, model) {
	    if (!(model.hyperlinks && model.hyperlinks.rId)) {
	      return;
	    }
	    xmlStream.leafNode(this.tag, {
	      'xmlns:r': 'http://schemas.openxmlformats.org/officeDocument/2006/relationships',
	      'r:id': model.hyperlinks.rId,
	      tooltip: model.hyperlinks.tooltip,
	    });
	  }

	  parseOpen(node) {
	    switch (node.name) {
	      case this.tag:
	        this.model = {
	          hyperlinks: {
	            rId: node.attributes['r:id'],
	            tooltip: node.attributes.tooltip,
	          },
	        };
	        return true;
	      default:
	        return true;
	    }
	  }

	  parseText() {}

	  parseClose() {
	    return false;
	  }
	}

	var hlinkClickXform = HLinkClickXform;

	class ExtLstXform$1 extends baseXform {
	  get tag() {
	    return 'a:extLst';
	  }

	  render(xmlStream) {
	    xmlStream.openNode(this.tag);
	    xmlStream.openNode('a:ext', {
	      uri: '{FF2B5EF4-FFF2-40B4-BE49-F238E27FC236}',
	    });
	    xmlStream.leafNode('a16:creationId', {
	      'xmlns:a16': 'http://schemas.microsoft.com/office/drawing/2014/main',
	      id: '{00000000-0008-0000-0000-000002000000}',
	    });
	    xmlStream.closeNode();
	    xmlStream.closeNode();
	  }

	  parseOpen(node) {
	    switch (node.name) {
	      case this.tag:
	        return true;
	      default:
	        return true;
	    }
	  }

	  parseText() {}

	  parseClose(name) {
	    switch (name) {
	      case this.tag:
	        return false;
	      default:
	        // unprocessed internal nodes
	        return true;
	    }
	  }
	}

	var extLstXform$1 = ExtLstXform$1;

	class CNvPrXform extends baseXform {
	  constructor() {
	    super();

	    this.map = {
	      'a:hlinkClick': new hlinkClickXform(),
	      'a:extLst': new extLstXform$1(),
	    };
	  }

	  get tag() {
	    return 'xdr:cNvPr';
	  }

	  render(xmlStream, model) {
	    xmlStream.openNode(this.tag, {
	      id: model.index,
	      name: `Picture ${model.index}`,
	    });
	    this.map['a:hlinkClick'].render(xmlStream, model);
	    this.map['a:extLst'].render(xmlStream, model);
	    xmlStream.closeNode();
	  }

	  parseOpen(node) {
	    if (this.parser) {
	      this.parser.parseOpen(node);
	      return true;
	    }

	    switch (node.name) {
	      case this.tag:
	        this.reset();
	        break;
	      default:
	        this.parser = this.map[node.name];
	        if (this.parser) {
	          this.parser.parseOpen(node);
	        }
	        break;
	    }
	    return true;
	  }

	  parseText() {}

	  parseClose(name) {
	    if (this.parser) {
	      if (!this.parser.parseClose(name)) {
	        this.parser = undefined;
	      }
	      return true;
	    }
	    switch (name) {
	      case this.tag:
	        this.model = this.map['a:hlinkClick'].model;
	        return false;
	      default:
	        return true;
	    }
	  }
	}

	var cNvPrXform = CNvPrXform;

	class CNvPicPrXform extends baseXform {
	  get tag() {
	    return 'xdr:cNvPicPr';
	  }

	  render(xmlStream) {
	    xmlStream.openNode(this.tag);
	    xmlStream.leafNode('a:picLocks', {
	      noChangeAspect: '1',
	    });
	    xmlStream.closeNode();
	  }

	  parseOpen(node) {
	    switch (node.name) {
	      case this.tag:
	        return true;
	      default:
	        return true;
	    }
	  }

	  parseText() {}

	  parseClose(name) {
	    switch (name) {
	      case this.tag:
	        return false;
	      default:
	        // unprocessed internal nodes
	        return true;
	    }
	  }
	}

	var cNvPicPrXform = CNvPicPrXform;

	class NvPicPrXform extends baseXform {
	  constructor() {
	    super();

	    this.map = {
	      'xdr:cNvPr': new cNvPrXform(),
	      'xdr:cNvPicPr': new cNvPicPrXform(),
	    };
	  }

	  get tag() {
	    return 'xdr:nvPicPr';
	  }

	  render(xmlStream, model) {
	    xmlStream.openNode(this.tag);
	    this.map['xdr:cNvPr'].render(xmlStream, model);
	    this.map['xdr:cNvPicPr'].render(xmlStream, model);
	    xmlStream.closeNode();
	  }

	  parseOpen(node) {
	    if (this.parser) {
	      this.parser.parseOpen(node);
	      return true;
	    }

	    switch (node.name) {
	      case this.tag:
	        this.reset();
	        break;
	      default:
	        this.parser = this.map[node.name];
	        if (this.parser) {
	          this.parser.parseOpen(node);
	        }
	        break;
	    }
	    return true;
	  }

	  parseText() {}

	  parseClose(name) {
	    if (this.parser) {
	      if (!this.parser.parseClose(name)) {
	        this.parser = undefined;
	      }
	      return true;
	    }
	    switch (name) {
	      case this.tag:
	        this.model = this.map['xdr:cNvPr'].model;
	        return false;
	      default:
	        return true;
	    }
	  }
	}

	var nvPicPrXform = NvPicPrXform;

	var spPr = {
	  tag: 'xdr:spPr',
	  c: [
	    {
	      tag: 'a:xfrm',
	      c: [
	        {tag: 'a:off', $: {x: '0', y: '0'}},
	        {tag: 'a:ext', $: {cx: '0', cy: '0'}},
	      ],
	    },
	    {
	      tag: 'a:prstGeom',
	      $: {prst: 'rect'},
	      c: [{tag: 'a:avLst'}],
	    },
	  ],
	};

	class PicXform extends baseXform {
	  constructor() {
	    super();

	    this.map = {
	      'xdr:nvPicPr': new nvPicPrXform(),
	      'xdr:blipFill': new blipFillXform(),
	      'xdr:spPr': new staticXform(spPr),
	    };
	  }

	  get tag() {
	    return 'xdr:pic';
	  }

	  prepare(model, options) {
	    model.index = options.index + 1;
	  }

	  render(xmlStream, model) {
	    xmlStream.openNode(this.tag);

	    this.map['xdr:nvPicPr'].render(xmlStream, model);
	    this.map['xdr:blipFill'].render(xmlStream, model);
	    this.map['xdr:spPr'].render(xmlStream, model);

	    xmlStream.closeNode();
	  }

	  parseOpen(node) {
	    if (this.parser) {
	      this.parser.parseOpen(node);
	      return true;
	    }
	    switch (node.name) {
	      case this.tag:
	        this.reset();
	        break;
	      default:
	        this.parser = this.map[node.name];
	        if (this.parser) {
	          this.parser.parseOpen(node);
	        }
	        break;
	    }
	    return true;
	  }

	  parseText() {}

	  parseClose(name) {
	    if (this.parser) {
	      if (!this.parser.parseClose(name)) {
	        this.mergeModel(this.parser.model);
	        this.parser = undefined;
	      }
	      return true;
	    }
	    switch (name) {
	      case this.tag:
	        return false;
	      default:
	        // not quite sure how we get here!
	        return true;
	    }
	  }
	}

	var picXform = PicXform;

	class TwoCellAnchorXform extends baseCellAnchorXform {
	  constructor() {
	    super();

	    this.map = {
	      'xdr:from': new cellPositionXform({tag: 'xdr:from'}),
	      'xdr:to': new cellPositionXform({tag: 'xdr:to'}),
	      'xdr:pic': new picXform(),
	      'xdr:clientData': new staticXform({tag: 'xdr:clientData'}),
	    };
	  }

	  get tag() {
	    return 'xdr:twoCellAnchor';
	  }

	  prepare(model, options) {
	    this.map['xdr:pic'].prepare(model.picture, options);
	  }

	  render(xmlStream, model) {
	    xmlStream.openNode(this.tag, {editAs: model.range.editAs || 'oneCell'});

	    this.map['xdr:from'].render(xmlStream, model.range.tl);
	    this.map['xdr:to'].render(xmlStream, model.range.br);
	    this.map['xdr:pic'].render(xmlStream, model.picture);
	    this.map['xdr:clientData'].render(xmlStream, {});

	    xmlStream.closeNode();
	  }

	  parseClose(name) {
	    if (this.parser) {
	      if (!this.parser.parseClose(name)) {
	        this.parser = undefined;
	      }
	      return true;
	    }
	    switch (name) {
	      case this.tag:
	        this.model.range.tl = this.map['xdr:from'].model;
	        this.model.range.br = this.map['xdr:to'].model;
	        this.model.picture = this.map['xdr:pic'].model;
	        return false;
	      default:
	        // could be some unrecognised tags
	        return true;
	    }
	  }

	  reconcile(model, options) {
	    model.medium = this.reconcilePicture(model.picture, options);
	  }
	}

	var twoCellAnchorXform = TwoCellAnchorXform;

	/** https://en.wikipedia.org/wiki/Office_Open_XML_file_formats#DrawingML */
	const EMU_PER_PIXEL_AT_96_DPI = 9525;

	class ExtXform$2 extends baseXform {
	  constructor(options) {
	    super();

	    this.tag = options.tag;
	    this.map = {};
	  }

	  render(xmlStream, model) {
	    xmlStream.openNode(this.tag);

	    const width = Math.floor(model.width * EMU_PER_PIXEL_AT_96_DPI);
	    const height = Math.floor(model.height * EMU_PER_PIXEL_AT_96_DPI);

	    xmlStream.addAttribute('cx', width);
	    xmlStream.addAttribute('cy', height);

	    xmlStream.closeNode();
	  }

	  parseOpen(node) {
	    if (node.name === this.tag) {
	      this.model = {
	        width: parseInt(node.attributes.cx || '0', 10) / EMU_PER_PIXEL_AT_96_DPI,
	        height: parseInt(node.attributes.cy || '0', 10) / EMU_PER_PIXEL_AT_96_DPI,
	      };
	      return true;
	    }
	    return false;
	  }

	  parseText(/* text */) {}

	  parseClose(/* name */) {
	    return false;
	  }
	}

	var extXform = ExtXform$2;

	class OneCellAnchorXform extends baseCellAnchorXform {
	  constructor() {
	    super();

	    this.map = {
	      'xdr:from': new cellPositionXform({tag: 'xdr:from'}),
	      'xdr:ext': new extXform({tag: 'xdr:ext'}),
	      'xdr:pic': new picXform(),
	      'xdr:clientData': new staticXform({tag: 'xdr:clientData'}),
	    };
	  }

	  get tag() {
	    return 'xdr:oneCellAnchor';
	  }

	  prepare(model, options) {
	    this.map['xdr:pic'].prepare(model.picture, options);
	  }

	  render(xmlStream, model) {
	    xmlStream.openNode(this.tag, {editAs: model.range.editAs || 'oneCell'});

	    this.map['xdr:from'].render(xmlStream, model.range.tl);
	    this.map['xdr:ext'].render(xmlStream, model.range.ext);
	    this.map['xdr:pic'].render(xmlStream, model.picture);
	    this.map['xdr:clientData'].render(xmlStream, {});

	    xmlStream.closeNode();
	  }

	  parseClose(name) {
	    if (this.parser) {
	      if (!this.parser.parseClose(name)) {
	        this.parser = undefined;
	      }
	      return true;
	    }
	    switch (name) {
	      case this.tag:
	        this.model.range.tl = this.map['xdr:from'].model;
	        this.model.range.ext = this.map['xdr:ext'].model;
	        this.model.picture = this.map['xdr:pic'].model;
	        return false;
	      default:
	        // could be some unrecognised tags
	        return true;
	    }
	  }

	  reconcile(model, options) {
	    model.medium = this.reconcilePicture(model.picture, options);
	  }
	}

	var oneCellAnchorXform = OneCellAnchorXform;

	function getAnchorType(model) {
	  const range = typeof model.range === 'string' ? colCache_1.decode(model.range) : model.range;

	  return range.br ? 'xdr:twoCellAnchor' : 'xdr:oneCellAnchor';
	}

	class DrawingXform$1 extends baseXform {
	  constructor() {
	    super();

	    this.map = {
	      'xdr:twoCellAnchor': new twoCellAnchorXform(),
	      'xdr:oneCellAnchor': new oneCellAnchorXform(),
	    };
	  }

	  prepare(model) {
	    model.anchors.forEach((item, index) => {
	      item.anchorType = getAnchorType(item);
	      const anchor = this.map[item.anchorType];
	      anchor.prepare(item, {index});
	    });
	  }

	  get tag() {
	    return 'xdr:wsDr';
	  }

	  render(xmlStream$1, model) {
	    xmlStream$1.openXml(xmlStream.StdDocAttributes);
	    xmlStream$1.openNode(this.tag, DrawingXform$1.DRAWING_ATTRIBUTES);

	    model.anchors.forEach(item => {
	      const anchor = this.map[item.anchorType];
	      anchor.render(xmlStream$1, item);
	    });

	    xmlStream$1.closeNode();
	  }

	  parseOpen(node) {
	    if (this.parser) {
	      this.parser.parseOpen(node);
	      return true;
	    }
	    switch (node.name) {
	      case this.tag:
	        this.reset();
	        this.model = {
	          anchors: [],
	        };
	        break;
	      default:
	        this.parser = this.map[node.name];
	        if (this.parser) {
	          this.parser.parseOpen(node);
	        }
	        break;
	    }
	    return true;
	  }

	  parseText(text) {
	    if (this.parser) {
	      this.parser.parseText(text);
	    }
	  }

	  parseClose(name) {
	    if (this.parser) {
	      if (!this.parser.parseClose(name)) {
	        this.model.anchors.push(this.parser.model);
	        this.parser = undefined;
	      }
	      return true;
	    }
	    switch (name) {
	      case this.tag:
	        return false;
	      default:
	        // could be some unrecognised tags
	        return true;
	    }
	  }

	  reconcile(model, options) {
	    model.anchors.forEach(anchor => {
	      if (anchor.br) {
	        this.map['xdr:twoCellAnchor'].reconcile(anchor, options);
	      } else {
	        this.map['xdr:oneCellAnchor'].reconcile(anchor, options);
	      }
	    });
	  }
	}

	DrawingXform$1.DRAWING_ATTRIBUTES = {
	  'xmlns:xdr': 'http://schemas.openxmlformats.org/drawingml/2006/spreadsheetDrawing',
	  'xmlns:a': 'http://schemas.openxmlformats.org/drawingml/2006/main',
	};

	var drawingXform$1 = DrawingXform$1;

	class FilterColumnXform extends baseXform {
	  get tag() {
	    return 'filterColumn';
	  }

	  prepare(model, options) {
	    model.colId = options.index.toString();
	  }

	  render(xmlStream, model) {
	    xmlStream.leafNode(this.tag, {
	      colId: model.colId,
	      hiddenButton: model.filterButton ? '0' : '1',
	    });
	    return true;
	  }

	  parseOpen(node) {
	    if (node.name === this.tag) {
	      const {attributes} = node;
	      this.model = {
	        filterButton: attributes.hiddenButton === '0',
	      };
	      return true;
	    }
	    return false;
	  }

	  parseText() {}

	  parseClose() {
	    return false;
	  }
	}

	var filterColumnXform = FilterColumnXform;

	class AutoFilterXform$1 extends baseXform {
	  constructor() {
	    super();

	    this.map = {
	      filterColumn: new filterColumnXform(),
	    };
	  }

	  get tag() {
	    return 'autoFilter';
	  }

	  prepare(model) {
	    model.columns.forEach((column, index) => {
	      this.map.filterColumn.prepare(column, {index});
	    });
	  }

	  render(xmlStream, model) {
	    xmlStream.openNode(this.tag, {ref: model.autoFilterRef});

	    model.columns.forEach(column => {
	      this.map.filterColumn.render(xmlStream, column);
	    });

	    xmlStream.closeNode();
	    return true;
	  }

	  parseOpen(node) {
	    if (this.parser) {
	      this.parser.parseOpen(node);
	      return true;
	    }
	    switch (node.name) {
	      case this.tag:
	        this.model = {
	          autoFilterRef: node.attributes.ref,
	          columns: [],
	        };
	        return true;

	      default:
	        this.parser = this.map[node.name];
	        if (this.parser) {
	          this.parseOpen(node);
	          return true;
	        }
	        throw new Error(`Unexpected xml node in parseOpen: ${JSON.stringify(node)}`);
	    }
	  }

	  parseText(text) {
	    if (this.parser) {
	      this.parser.parseText(text);
	    }
	  }

	  parseClose(name) {
	    if (this.parser) {
	      if (!this.parser.parseClose(name)) {
	        this.model.columns.push(this.parser.model);
	        this.parser = undefined;
	      }
	      return true;
	    }
	    switch (name) {
	      case this.tag:
	        return false;
	      default:
	        throw new Error(`Unexpected xml node in parseClose: ${name}`);
	    }
	  }
	}

	var autoFilterXform$1 = AutoFilterXform$1;

	class TableColumnXform extends baseXform {
	  get tag() {
	    return 'tableColumn';
	  }

	  prepare(model, options) {
	    model.id = options.index + 1;
	  }

	  render(xmlStream, model) {
	    xmlStream.leafNode(this.tag, {
	      id: model.id.toString(),
	      name: model.name,
	      totalsRowLabel: model.totalsRowLabel,
	      totalsRowFunction: model.totalsRowFunction,
	      dxfId: model.dxfId,
	    });
	    return true;
	  }

	  parseOpen(node) {
	    if (node.name === this.tag) {
	      const {attributes} = node;
	      this.model = {
	        name: attributes.name,
	        totalsRowLabel: attributes.totalsRowLabel,
	        totalsRowFunction: attributes.totalsRowFunction,
	        dxfId: attributes.dxfId,
	      };
	      return true;
	    }
	    return false;
	  }

	  parseText() {}

	  parseClose() {
	    return false;
	  }
	}

	var tableColumnXform = TableColumnXform;

	class TableStyleInfoXform extends baseXform {
	  get tag() {
	    return 'tableStyleInfo';
	  }

	  render(xmlStream, model) {
	    xmlStream.leafNode(this.tag, {
	      name: model.theme ? model.theme : undefined,
	      showFirstColumn: model.showFirstColumn ? '1' : '0',
	      showLastColumn: model.showLastColumn ? '1' : '0',
	      showRowStripes: model.showRowStripes ? '1' : '0',
	      showColumnStripes: model.showColumnStripes ? '1' : '0',
	    });
	    return true;
	  }

	  parseOpen(node) {
	    if (node.name === this.tag) {
	      const {attributes} = node;
	      this.model = {
	        theme: attributes.name ? attributes.name : null,
	        showFirstColumn: attributes.showFirstColumn === '1',
	        showLastColumn: attributes.showLastColumn === '1',
	        showRowStripes: attributes.showRowStripes === '1',
	        showColumnStripes: attributes.showColumnStripes === '1',
	      };
	      return true;
	    }
	    return false;
	  }

	  parseText() {}

	  parseClose() {
	    return false;
	  }
	}

	var tableStyleInfoXform = TableStyleInfoXform;

	class TableXform extends baseXform {
	  constructor() {
	    super();

	    this.map = {
	      autoFilter: new autoFilterXform$1(),
	      tableColumns: new listXform({
	        tag: 'tableColumns',
	        count: true,
	        empty: true,
	        childXform: new tableColumnXform(),
	      }),
	      tableStyleInfo: new tableStyleInfoXform(),
	    };
	  }

	  prepare(model, options) {
	    this.map.autoFilter.prepare(model);
	    this.map.tableColumns.prepare(model.columns, options);
	  }

	  get tag() {
	    return 'table';
	  }

	  render(xmlStream$1, model) {
	    xmlStream$1.openXml(xmlStream.StdDocAttributes);
	    xmlStream$1.openNode(this.tag, {
	      ...TableXform.TABLE_ATTRIBUTES,
	      id: model.id,
	      name: model.name,
	      displayName: model.displayName || model.name,
	      ref: model.tableRef,
	      totalsRowCount: model.totalsRow ? '1' : undefined,
	      totalsRowShown: model.totalsRow ? undefined : '1',
	      headerRowCount: model.headerRow ? '1' : '0',
	    });

	    this.map.autoFilter.render(xmlStream$1, model);
	    this.map.tableColumns.render(xmlStream$1, model.columns);
	    this.map.tableStyleInfo.render(xmlStream$1, model.style);

	    xmlStream$1.closeNode();
	  }

	  parseOpen(node) {
	    if (this.parser) {
	      this.parser.parseOpen(node);
	      return true;
	    }
	    const {name, attributes} = node;
	    switch (name) {
	      case this.tag:
	        this.reset();
	        this.model = {
	          name: attributes.name,
	          displayName: attributes.displayName || attributes.name,
	          tableRef: attributes.ref,
	          totalsRow: attributes.totalsRowCount === '1',
	          headerRow: attributes.headerRowCount === '1',
	        };
	        break;
	      default:
	        this.parser = this.map[node.name];
	        if (this.parser) {
	          this.parser.parseOpen(node);
	        }
	        break;
	    }
	    return true;
	  }

	  parseText(text) {
	    if (this.parser) {
	      this.parser.parseText(text);
	    }
	  }

	  parseClose(name) {
	    if (this.parser) {
	      if (!this.parser.parseClose(name)) {
	        this.parser = undefined;
	      }
	      return true;
	    }
	    switch (name) {
	      case this.tag:
	        this.model.columns = this.map.tableColumns.model;
	        if (this.map.autoFilter.model) {
	          this.model.autoFilterRef = this.map.autoFilter.model.autoFilterRef;
	          this.map.autoFilter.model.columns.forEach((column, index) => {
	            this.model.columns[index].filterButton = column.filterButton;
	          });
	        }
	        this.model.style = this.map.tableStyleInfo.model;
	        return false;
	      default:
	        // could be some unrecognised tags
	        return true;
	    }
	  }

	  reconcile(model, options) {
	    // fetch the dfxs from styles
	    model.columns.forEach(column => {
	      if (column.dxfId !== undefined) {
	        column.style = options.styles.getDxfStyle(column.dxfId);
	      }
	    });
	  }
	}

	TableXform.TABLE_ATTRIBUTES = {
	  xmlns: 'http://schemas.openxmlformats.org/spreadsheetml/2006/main',
	  'xmlns:mc': 'http://schemas.openxmlformats.org/markup-compatibility/2006',
	  'mc:Ignorable': 'xr xr3',
	  'xmlns:xr': 'http://schemas.microsoft.com/office/spreadsheetml/2014/revision',
	  'xmlns:xr3': 'http://schemas.microsoft.com/office/spreadsheetml/2016/revision3',
	  // 'xr:uid': '{00000000-000C-0000-FFFF-FFFF00000000}',
	};

	var tableXform = TableXform;

	var commentXform = createCommonjsModule(function (module) {
	/**
	  <comment ref="B1" authorId="0">
	    <text>
	      <r>
	        <rPr>
	          <b/>
	          <sz val="9"/>
	          <rFont val="å®ä½"/>
	          <charset val="134"/>
	        </rPr>
	        <t>51422:</t>
	      </r>
	      <r>
	        <rPr>
	          <sz val="9"/>
	          <rFont val="å®ä½"/>
	          <charset val="134"/>
	        </rPr>
	        <t xml:space="preserve">&#10;test</t>
	      </r>
	    </text>
	  </comment>
	 */

	const CommentXform = (module.exports = function(model) {
	  this.model = model;
	});

	utils_1.inherits(CommentXform, baseXform, {
	  get tag() {
	    return 'r';
	  },

	  get richTextXform() {
	    if (!this._richTextXform) {
	      this._richTextXform = new richTextXform();
	    }
	    return this._richTextXform;
	  },

	  render(xmlStream, model) {
	    model = model || this.model;

	    xmlStream.openNode('comment', {
	      ref: model.ref,
	      authorId: 0,
	    });
	    xmlStream.openNode('text');
	    if (model && model.note && model.note.texts) {
	      model.note.texts.forEach(text => {
	        this.richTextXform.render(xmlStream, text);
	      });
	    }
	    xmlStream.closeNode();
	    xmlStream.closeNode();
	  },

	  parseOpen(node) {
	    if (this.parser) {
	      this.parser.parseOpen(node);
	      return true;
	    }
	    switch (node.name) {
	      case 'comment':
	        this.model = {
	          type: 'note',
	          note: {
	            texts: [],
	          },
	          ...node.attributes,
	        };
	        return true;
	      case 'r':
	        this.parser = this.richTextXform;
	        this.parser.parseOpen(node);
	        return true;
	      default:
	        return false;
	    }
	  },
	  parseText(text) {
	    if (this.parser) {
	      this.parser.parseText(text);
	    }
	  },
	  parseClose(name) {
	    switch (name) {
	      case 'comment':
	        return false;
	      case 'r':
	        this.model.note.texts.push(this.parser.model);
	        this.parser = undefined;
	        return true;
	      default:
	        if (this.parser) {
	          this.parser.parseClose(name);
	        }
	        return true;
	    }
	  },
	});
	});

	var commentsXform = createCommonjsModule(function (module) {
	const CommentsXform = (module.exports = function() {
	  this.map = {
	    comment: new commentXform(),
	  };
	});

	utils_1.inherits(
	  CommentsXform,
	  baseXform,
	  {
	    COMMENTS_ATTRIBUTES: {
	      xmlns: 'http://schemas.openxmlformats.org/spreadsheetml/2006/main',
	    },
	  },
	  {
	    render(xmlStream$1, model) {
	      model = model || this.model;
	      xmlStream$1.openXml(xmlStream.StdDocAttributes);
	      xmlStream$1.openNode('comments', CommentsXform.COMMENTS_ATTRIBUTES);

	      // authors
	      // TODO: support authors properly
	      xmlStream$1.openNode('authors');
	      xmlStream$1.leafNode('author', null, 'Author');
	      xmlStream$1.closeNode();

	      // comments
	      xmlStream$1.openNode('commentList');
	      model.comments.forEach(comment => {
	        this.map.comment.render(xmlStream$1, comment);
	      });
	      xmlStream$1.closeNode();
	      xmlStream$1.closeNode();
	    },

	    parseOpen(node) {
	      if (this.parser) {
	        this.parser.parseOpen(node);
	        return true;
	      }
	      switch (node.name) {
	        case 'commentList':
	          this.model = {
	            comments: [],
	          };
	          return true;
	        case 'comment':
	          this.parser = this.map.comment;
	          this.parser.parseOpen(node);
	          return true;
	        default:
	          return false;
	      }
	    },
	    parseText(text) {
	      if (this.parser) {
	        this.parser.parseText(text);
	      }
	    },
	    parseClose(name) {
	      switch (name) {
	        case 'commentList':
	          return false;
	        case 'comment':
	          this.model.comments.push(this.parser.model);
	          this.parser = undefined;
	          return true;
	        default:
	          if (this.parser) {
	            this.parser.parseClose(name);
	          }
	          return true;
	      }
	    },
	  }
	);
	});

	class VmlTextboxXform extends baseXform {
	  get tag() {
	    return 'v:textbox';
	  }

	  conversionUnit(value, multiple, unit) {
	    return `${parseFloat(value) * multiple.toFixed(2)}${unit}`;
	  }

	  reverseConversionUnit(inset) {
	    return (inset || '').split(',').map(margin => {
	      return Number(parseFloat(this.conversionUnit(parseFloat(margin), 0.1, '')).toFixed(2));
	    });
	  }

	  render(xmlStream, model) {
	    const attributes = {
	      style: 'mso-direction-alt:auto',
	    };
	    if (model && model.note) {
	      let {inset} = model.note && model.note.margins;
	      if (Array.isArray(inset)) {
	        inset = inset
	          .map(margin => {
	            return this.conversionUnit(margin, 10, 'mm');
	          })
	          .join(',');
	      }
	      if (inset) {
	        attributes.inset = inset;
	      }
	    }
	    xmlStream.openNode('v:textbox', attributes);
	    xmlStream.leafNode('div', {style: 'text-align:left'});
	    xmlStream.closeNode();
	  }

	  parseOpen(node) {
	    switch (node.name) {
	      case this.tag:
	        this.model = {
	          inset: this.reverseConversionUnit(node.attributes.inset),
	        };
	        return true;
	      default:
	        return true;
	    }
	  }

	  parseText() {}

	  parseClose(name) {
	    switch (name) {
	      case this.tag:
	        return false;
	      default:
	        return true;
	    }
	  }
	}

	var vmlTextboxXform = VmlTextboxXform;

	// render the triangle in the cell for the comment
	class VmlAnchorXform extends baseXform {
	  get tag() {
	    return 'x:Anchor';
	  }

	  getAnchorRect(anchor) {
	    const l = Math.floor(anchor.left);
	    const lf = Math.floor((anchor.left - l) * 68);
	    const t = Math.floor(anchor.top);
	    const tf = Math.floor((anchor.top - t) * 18);
	    const r = Math.floor(anchor.right);
	    const rf = Math.floor((anchor.right - r) * 68);
	    const b = Math.floor(anchor.bottom);
	    const bf = Math.floor((anchor.bottom - b) * 18);
	    return [l, lf, t, tf, r, rf, b, bf];
	  }

	  getDefaultRect(ref) {
	    const l = ref.col;
	    const lf = 6;
	    const t = Math.max(ref.row - 2, 0);
	    const tf = 14;
	    const r = l + 2;
	    const rf = 2;
	    const b = t + 4;
	    const bf = 16;
	    return [l, lf, t, tf, r, rf, b, bf];
	  }

	  render(xmlStream, model) {
	    const rect = model.anchor
	      ? this.getAnchorRect(model.anchor)
	      : this.getDefaultRect(model.refAddress);

	    xmlStream.leafNode('x:Anchor', null, rect.join(', '));
	  }

	  parseOpen(node) {
	    switch (node.name) {
	      case this.tag:
	        this.text = '';
	        return true;
	      default:
	        return false;
	    }
	  }

	  parseText(text) {
	    this.text = text;
	  }

	  parseClose() {
	    return false;
	  }
	}

	var vmlAnchorXform = VmlAnchorXform;

	class VmlProtectionXform extends baseXform {
	  constructor(model) {
	    super();
	    this._model = model;
	  }

	  get tag() {
	    return this._model && this._model.tag;
	  }

	  render(xmlStream, model) {
	    xmlStream.leafNode(this.tag, null, model);
	  }

	  parseOpen(node) {
	    switch (node.name) {
	      case this.tag:
	        this.text = '';
	        return true;
	      default:
	        return false;
	    }
	  }

	  parseText(text) {
	    this.text = text;
	  }

	  parseClose() {
	    return false;
	  }
	}

	var vmlProtectionXform = VmlProtectionXform;

	class VmlPositionXform extends baseXform {
	  constructor(model) {
	    super();
	    this._model = model;
	  }

	  get tag() {
	    return this._model && this._model.tag;
	  }

	  render(xmlStream, model, type) {
	    if (model === type[2]) {
	      xmlStream.leafNode(this.tag);
	    } else if (this.tag === 'x:SizeWithCells' && model === type[1]) {
	      xmlStream.leafNode(this.tag);
	    }
	  }

	  parseOpen(node) {
	    switch (node.name) {
	      case this.tag:
	        this.model = {};
	        this.model[this.tag] = true;
	        return true;
	      default:
	        return false;
	    }
	  }

	  parseText() {}

	  parseClose() {
	    return false;
	  }
	}

	var vmlPositionXform = VmlPositionXform;

	const POSITION_TYPE = ['twoCells', 'oneCells', 'absolute'];

	class VmlClientDataXform extends baseXform {
	  constructor() {
	    super();
	    this.map = {
	      'x:Anchor': new vmlAnchorXform(),
	      'x:Locked': new vmlProtectionXform({tag: 'x:Locked'}),
	      'x:LockText': new vmlProtectionXform({tag: 'x:LockText'}),
	      'x:SizeWithCells': new vmlPositionXform({tag: 'x:SizeWithCells'}),
	      'x:MoveWithCells': new vmlPositionXform({tag: 'x:MoveWithCells'}),
	    };
	  }

	  get tag() {
	    return 'x:ClientData';
	  }

	  render(xmlStream, model) {
	    const {protection, editAs} = model.note;
	    xmlStream.openNode(this.tag, {ObjectType: 'Note'});
	    this.map['x:MoveWithCells'].render(xmlStream, editAs, POSITION_TYPE);
	    this.map['x:SizeWithCells'].render(xmlStream, editAs, POSITION_TYPE);
	    this.map['x:Anchor'].render(xmlStream, model);
	    this.map['x:Locked'].render(xmlStream, protection.locked);
	    xmlStream.leafNode('x:AutoFill', null, 'False');
	    this.map['x:LockText'].render(xmlStream, protection.lockText);
	    xmlStream.leafNode('x:Row', null, model.refAddress.row - 1);
	    xmlStream.leafNode('x:Column', null, model.refAddress.col - 1);
	    xmlStream.closeNode();
	  }

	  parseOpen(node) {
	    switch (node.name) {
	      case this.tag:
	        this.reset();
	        this.model = {
	          anchor: [],
	          protection: {},
	          editAs: '',
	        };
	        break;
	      default:
	        this.parser = this.map[node.name];
	        if (this.parser) {
	          this.parser.parseOpen(node);
	        }
	        break;
	    }
	    return true;
	  }

	  parseText(text) {
	    if (this.parser) {
	      this.parser.parseText(text);
	    }
	  }

	  parseClose(name) {
	    if (this.parser) {
	      if (!this.parser.parseClose(name)) {
	        this.parser = undefined;
	      }
	      return true;
	    }
	    switch (name) {
	      case this.tag:
	        this.normalizeModel();
	        return false;
	      default:
	        return true;
	    }
	  }

	  normalizeModel() {
	    const position = Object.assign(
	      {},
	      this.map['x:MoveWithCells'].model,
	      this.map['x:SizeWithCells'].model
	    );
	    const len = Object.keys(position).length;
	    this.model.editAs = POSITION_TYPE[len];
	    this.model.anchor = this.map['x:Anchor'].text;
	    this.model.protection.locked = this.map['x:Locked'].text;
	    this.model.protection.lockText = this.map['x:LockText'].text;
	  }
	}

	var vmlClientDataXform = VmlClientDataXform;

	class VmlShapeXform extends baseXform {
	  constructor() {
	    super();
	    this.map = {
	      'v:textbox': new vmlTextboxXform(),
	      'x:ClientData': new vmlClientDataXform(),
	    };
	  }

	  get tag() {
	    return 'v:shape';
	  }

	  render(xmlStream, model, index) {
	    xmlStream.openNode('v:shape', VmlShapeXform.V_SHAPE_ATTRIBUTES(model, index));

	    xmlStream.leafNode('v:fill', {color2: 'infoBackground [80]'});
	    xmlStream.leafNode('v:shadow', {color: 'none [81]', obscured: 't'});
	    xmlStream.leafNode('v:path', {'o:connecttype': 'none'});
	    this.map['v:textbox'].render(xmlStream, model);
	    this.map['x:ClientData'].render(xmlStream, model);

	    xmlStream.closeNode();
	  }

	  parseOpen(node) {
	    if (this.parser) {
	      this.parser.parseOpen(node);
	      return true;
	    }

	    switch (node.name) {
	      case this.tag:
	        this.reset();
	        this.model = {
	          margins: {
	            insetmode: node.attributes['o:insetmode'],
	          },
	          anchor: '',
	          editAs: '',
	          protection: {},
	        };
	        break;
	      default:
	        this.parser = this.map[node.name];
	        if (this.parser) {
	          this.parser.parseOpen(node);
	        }
	        break;
	    }
	    return true;
	  }

	  parseText(text) {
	    if (this.parser) {
	      this.parser.parseText(text);
	    }
	  }

	  parseClose(name) {
	    if (this.parser) {
	      if (!this.parser.parseClose(name)) {
	        this.parser = undefined;
	      }
	      return true;
	    }
	    switch (name) {
	      case this.tag:
	        this.model.margins.inset = this.map['v:textbox'].model && this.map['v:textbox'].model.inset;
	        this.model.protection =
	          this.map['x:ClientData'].model && this.map['x:ClientData'].model.protection;
	        this.model.anchor = this.map['x:ClientData'].model && this.map['x:ClientData'].model.anchor;
	        this.model.editAs = this.map['x:ClientData'].model && this.map['x:ClientData'].model.editAs;
	        return false;
	      default:
	        return true;
	    }
	  }
	}

	VmlShapeXform.V_SHAPE_ATTRIBUTES = (model, index) => ({
	  id: `_x0000_s${1025 + index}`,
	  type: '#_x0000_t202',
	  style:
	    'position:absolute; margin-left:105.3pt;margin-top:10.5pt;width:97.8pt;height:59.1pt;z-index:1;visibility:hidden',
	  fillcolor: 'infoBackground [80]',
	  strokecolor: 'none [81]',
	  'o:insetmode': model.note.margins && model.note.margins.insetmode,
	});

	var vmlShapeXform = VmlShapeXform;

	// This class is (currently) single purposed to insert the triangle
	// drawing icons on commented cells
	class VmlNotesXform extends baseXform {
	  constructor() {
	    super();
	    this.map = {
	      'v:shape': new vmlShapeXform(),
	    };
	  }

	  get tag() {
	    return 'xml';
	  }

	  render(xmlStream$1, model) {
	    xmlStream$1.openXml(xmlStream.StdDocAttributes);
	    xmlStream$1.openNode(this.tag, VmlNotesXform.DRAWING_ATTRIBUTES);

	    xmlStream$1.openNode('o:shapelayout', {'v:ext': 'edit'});
	    xmlStream$1.leafNode('o:idmap', {'v:ext': 'edit', data: 1});
	    xmlStream$1.closeNode();

	    xmlStream$1.openNode('v:shapetype', {
	      id: '_x0000_t202',
	      coordsize: '21600,21600',
	      'o:spt': 202,
	      path: 'm,l,21600r21600,l21600,xe',
	    });
	    xmlStream$1.leafNode('v:stroke', {joinstyle: 'miter'});
	    xmlStream$1.leafNode('v:path', {gradientshapeok: 't', 'o:connecttype': 'rect'});
	    xmlStream$1.closeNode();

	    model.comments.forEach((item, index) => {
	      this.map['v:shape'].render(xmlStream$1, item, index);
	    });

	    xmlStream$1.closeNode();
	  }

	  parseOpen(node) {
	    if (this.parser) {
	      this.parser.parseOpen(node);
	      return true;
	    }
	    switch (node.name) {
	      case this.tag:
	        this.reset();
	        this.model = {
	          comments: [],
	        };
	        break;
	      default:
	        this.parser = this.map[node.name];
	        if (this.parser) {
	          this.parser.parseOpen(node);
	        }
	        break;
	    }
	    return true;
	  }

	  parseText(text) {
	    if (this.parser) {
	      this.parser.parseText(text);
	    }
	  }

	  parseClose(name) {
	    if (this.parser) {
	      if (!this.parser.parseClose(name)) {
	        this.model.comments.push(this.parser.model);
	        this.parser = undefined;
	      }
	      return true;
	    }
	    switch (name) {
	      case this.tag:
	        return false;
	      default:
	        // could be some unrecognised tags
	        return true;
	    }
	  }

	  reconcile(model, options) {
	    model.anchors.forEach(anchor => {
	      if (anchor.br) {
	        this.map['xdr:twoCellAnchor'].reconcile(anchor, options);
	      } else {
	        this.map['xdr:oneCellAnchor'].reconcile(anchor, options);
	      }
	    });
	  }
	}

	VmlNotesXform.DRAWING_ATTRIBUTES = {
	  'xmlns:v': 'urn:schemas-microsoft-com:vml',
	  'xmlns:o': 'urn:schemas-microsoft-com:office:office',
	  'xmlns:x': 'urn:schemas-microsoft-com:office:excel',
	};

	var vmlNotesXform = VmlNotesXform;

	/* eslint-disable */
	var theme1 =
	  '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>\n<a:theme xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" name="Office Theme"> <a:themeElements> <a:clrScheme name="Office"> <a:dk1> <a:sysClr val="windowText" lastClr="000000"/> </a:dk1> <a:lt1> <a:sysClr val="window" lastClr="FFFFFF"/> </a:lt1> <a:dk2> <a:srgbClr val="1F497D"/> </a:dk2> <a:lt2> <a:srgbClr val="EEECE1"/> </a:lt2> <a:accent1> <a:srgbClr val="4F81BD"/> </a:accent1> <a:accent2> <a:srgbClr val="C0504D"/> </a:accent2> <a:accent3> <a:srgbClr val="9BBB59"/> </a:accent3> <a:accent4> <a:srgbClr val="8064A2"/> </a:accent4> <a:accent5> <a:srgbClr val="4BACC6"/> </a:accent5> <a:accent6> <a:srgbClr val="F79646"/> </a:accent6> <a:hlink> <a:srgbClr val="0000FF"/> </a:hlink> <a:folHlink> <a:srgbClr val="800080"/> </a:folHlink> </a:clrScheme> <a:fontScheme name="Office"> <a:majorFont> <a:latin typeface="Cambria"/> <a:ea typeface=""/> <a:cs typeface=""/> <a:font script="Jpan" typeface="ï¼­ï¼³ ï¼°ã´ã·ãã¯"/> <a:font script="Hang" typeface="ë§ì ê³ ë"/> <a:font script="Hans" typeface="å®ä½"/> <a:font script="Hant" typeface="æ°ç´°æé«"/> <a:font script="Arab" typeface="Times New Roman"/> <a:font script="Hebr" typeface="Times New Roman"/> <a:font script="Thai" typeface="Tahoma"/> <a:font script="Ethi" typeface="Nyala"/> <a:font script="Beng" typeface="Vrinda"/> <a:font script="Gujr" typeface="Shruti"/> <a:font script="Khmr" typeface="MoolBoran"/> <a:font script="Knda" typeface="Tunga"/> <a:font script="Guru" typeface="Raavi"/> <a:font script="Cans" typeface="Euphemia"/> <a:font script="Cher" typeface="Plantagenet Cherokee"/> <a:font script="Yiii" typeface="Microsoft Yi Baiti"/> <a:font script="Tibt" typeface="Microsoft Himalaya"/> <a:font script="Thaa" typeface="MV Boli"/> <a:font script="Deva" typeface="Mangal"/> <a:font script="Telu" typeface="Gautami"/> <a:font script="Taml" typeface="Latha"/> <a:font script="Syrc" typeface="Estrangelo Edessa"/> <a:font script="Orya" typeface="Kalinga"/> <a:font script="Mlym" typeface="Kartika"/> <a:font script="Laoo" typeface="DokChampa"/> <a:font script="Sinh" typeface="Iskoola Pota"/> <a:font script="Mong" typeface="Mongolian Baiti"/> <a:font script="Viet" typeface="Times New Roman"/> <a:font script="Uigh" typeface="Microsoft Uighur"/> <a:font script="Geor" typeface="Sylfaen"/> </a:majorFont> <a:minorFont> <a:latin typeface="Calibri"/> <a:ea typeface=""/> <a:cs typeface=""/> <a:font script="Jpan" typeface="ï¼­ï¼³ ï¼°ã´ã·ãã¯"/> <a:font script="Hang" typeface="ë§ì ê³ ë"/> <a:font script="Hans" typeface="å®ä½"/> <a:font script="Hant" typeface="æ°ç´°æé«"/> <a:font script="Arab" typeface="Arial"/> <a:font script="Hebr" typeface="Arial"/> <a:font script="Thai" typeface="Tahoma"/> <a:font script="Ethi" typeface="Nyala"/> <a:font script="Beng" typeface="Vrinda"/> <a:font script="Gujr" typeface="Shruti"/> <a:font script="Khmr" typeface="DaunPenh"/> <a:font script="Knda" typeface="Tunga"/> <a:font script="Guru" typeface="Raavi"/> <a:font script="Cans" typeface="Euphemia"/> <a:font script="Cher" typeface="Plantagenet Cherokee"/> <a:font script="Yiii" typeface="Microsoft Yi Baiti"/> <a:font script="Tibt" typeface="Microsoft Himalaya"/> <a:font script="Thaa" typeface="MV Boli"/> <a:font script="Deva" typeface="Mangal"/> <a:font script="Telu" typeface="Gautami"/> <a:font script="Taml" typeface="Latha"/> <a:font script="Syrc" typeface="Estrangelo Edessa"/> <a:font script="Orya" typeface="Kalinga"/> <a:font script="Mlym" typeface="Kartika"/> <a:font script="Laoo" typeface="DokChampa"/> <a:font script="Sinh" typeface="Iskoola Pota"/> <a:font script="Mong" typeface="Mongolian Baiti"/> <a:font script="Viet" typeface="Arial"/> <a:font script="Uigh" typeface="Microsoft Uighur"/> <a:font script="Geor" typeface="Sylfaen"/> </a:minorFont> </a:fontScheme> <a:fmtScheme name="Office"> <a:fillStyleLst> <a:solidFill> <a:schemeClr val="phClr"/> </a:solidFill> <a:gradFill rotWithShape="1"> <a:gsLst> <a:gs pos="0"> <a:schemeClr val="phClr"> <a:tint val="50000"/> <a:satMod val="300000"/> </a:schemeClr> </a:gs> <a:gs pos="35000"> <a:schemeClr val="phClr"> <a:tint val="37000"/> <a:satMod val="300000"/> </a:schemeClr> </a:gs> <a:gs pos="100000"> <a:schemeClr val="phClr"> <a:tint val="15000"/> <a:satMod val="350000"/> </a:schemeClr> </a:gs> </a:gsLst> <a:lin ang="16200000" scaled="1"/> </a:gradFill> <a:gradFill rotWithShape="1"> <a:gsLst> <a:gs pos="0"> <a:schemeClr val="phClr"> <a:tint val="100000"/> <a:shade val="100000"/> <a:satMod val="130000"/> </a:schemeClr> </a:gs> <a:gs pos="100000"> <a:schemeClr val="phClr"> <a:tint val="50000"/> <a:shade val="100000"/> <a:satMod val="350000"/> </a:schemeClr> </a:gs> </a:gsLst> <a:lin ang="16200000" scaled="0"/> </a:gradFill> </a:fillStyleLst> <a:lnStyleLst> <a:ln w="9525" cap="flat" cmpd="sng" algn="ctr"> <a:solidFill> <a:schemeClr val="phClr"> <a:shade val="95000"/> <a:satMod val="105000"/> </a:schemeClr> </a:solidFill> <a:prstDash val="solid"/> </a:ln> <a:ln w="25400" cap="flat" cmpd="sng" algn="ctr"> <a:solidFill> <a:schemeClr val="phClr"/> </a:solidFill> <a:prstDash val="solid"/> </a:ln> <a:ln w="38100" cap="flat" cmpd="sng" algn="ctr"> <a:solidFill> <a:schemeClr val="phClr"/> </a:solidFill> <a:prstDash val="solid"/> </a:ln> </a:lnStyleLst> <a:effectStyleLst> <a:effectStyle> <a:effectLst> <a:outerShdw blurRad="40000" dist="20000" dir="5400000" rotWithShape="0"> <a:srgbClr val="000000"> <a:alpha val="38000"/> </a:srgbClr> </a:outerShdw> </a:effectLst> </a:effectStyle> <a:effectStyle> <a:effectLst> <a:outerShdw blurRad="40000" dist="23000" dir="5400000" rotWithShape="0"> <a:srgbClr val="000000"> <a:alpha val="35000"/> </a:srgbClr> </a:outerShdw> </a:effectLst> </a:effectStyle> <a:effectStyle> <a:effectLst> <a:outerShdw blurRad="40000" dist="23000" dir="5400000" rotWithShape="0"> <a:srgbClr val="000000"> <a:alpha val="35000"/> </a:srgbClr> </a:outerShdw> </a:effectLst> <a:scene3d> <a:camera prst="orthographicFront"> <a:rot lat="0" lon="0" rev="0"/> </a:camera> <a:lightRig rig="threePt" dir="t"> <a:rot lat="0" lon="0" rev="1200000"/> </a:lightRig> </a:scene3d> <a:sp3d> <a:bevelT w="63500" h="25400"/> </a:sp3d> </a:effectStyle> </a:effectStyleLst> <a:bgFillStyleLst> <a:solidFill> <a:schemeClr val="phClr"/> </a:solidFill> <a:gradFill rotWithShape="1"> <a:gsLst> <a:gs pos="0"> <a:schemeClr val="phClr"> <a:tint val="40000"/> <a:satMod val="350000"/> </a:schemeClr> </a:gs> <a:gs pos="40000"> <a:schemeClr val="phClr"> <a:tint val="45000"/> <a:shade val="99000"/> <a:satMod val="350000"/> </a:schemeClr> </a:gs> <a:gs pos="100000"> <a:schemeClr val="phClr"> <a:shade val="20000"/> <a:satMod val="255000"/> </a:schemeClr> </a:gs> </a:gsLst> <a:path path="circle"> <a:fillToRect l="50000" t="-80000" r="50000" b="180000"/> </a:path> </a:gradFill> <a:gradFill rotWithShape="1"> <a:gsLst> <a:gs pos="0"> <a:schemeClr val="phClr"> <a:tint val="80000"/> <a:satMod val="300000"/> </a:schemeClr> </a:gs> <a:gs pos="100000"> <a:schemeClr val="phClr"> <a:shade val="30000"/> <a:satMod val="200000"/> </a:schemeClr> </a:gs> </a:gsLst> <a:path path="circle"> <a:fillToRect l="50000" t="50000" r="50000" b="50000"/> </a:path> </a:gradFill> </a:bgFillStyleLst> </a:fmtScheme> </a:themeElements> <a:objectDefaults> <a:spDef> <a:spPr/> <a:bodyPr/> <a:lstStyle/> <a:style> <a:lnRef idx="1"> <a:schemeClr val="accent1"/> </a:lnRef> <a:fillRef idx="3"> <a:schemeClr val="accent1"/> </a:fillRef> <a:effectRef idx="2"> <a:schemeClr val="accent1"/> </a:effectRef> <a:fontRef idx="minor"> <a:schemeClr val="lt1"/> </a:fontRef> </a:style> </a:spDef> <a:lnDef> <a:spPr/> <a:bodyPr/> <a:lstStyle/> <a:style> <a:lnRef idx="2"> <a:schemeClr val="accent1"/> </a:lnRef> <a:fillRef idx="0"> <a:schemeClr val="accent1"/> </a:fillRef> <a:effectRef idx="1"> <a:schemeClr val="accent1"/> </a:effectRef> <a:fontRef idx="minor"> <a:schemeClr val="tx1"/> </a:fontRef> </a:style> </a:lnDef> </a:objectDefaults> <a:extraClrSchemeLst/> </a:theme>';

	const {PassThrough: PassThrough$2} = readableBrowser;





	const {bufferToString: bufferToString$2} = browserBufferDecode;

















	function fsReadFileAsync(filename, options) {
	  return new Promise((resolve, reject) => {
	    fs__default['default'].readFile(filename, options, (error, data) => {
	      if (error) {
	        reject(error);
	      } else {
	        resolve(data);
	      }
	    });
	  });
	}

	class XLSX {
	  constructor(workbook) {
	    this.workbook = workbook;
	  }

	  // ===============================================================================
	  // Workbook
	  // =========================================================================
	  // Read

	  async readFile(filename, options) {
	    if (!(await utils_1.fs.exists(filename))) {
	      throw new Error(`File not found: ${filename}`);
	    }
	    const stream = fs__default['default'].createReadStream(filename);
	    try {
	      const workbook = await this.read(stream, options);
	      stream.close();
	      return workbook;
	    } catch (error) {
	      stream.close();
	      throw error;
	    }
	  }

	  parseRels(stream) {
	    const xform = new relationshipsXform();
	    return xform.parseStream(stream);
	  }

	  parseWorkbook(stream) {
	    const xform = new workbookXform();
	    return xform.parseStream(stream);
	  }

	  parseSharedStrings(stream) {
	    const xform = new sharedStringsXform();
	    return xform.parseStream(stream);
	  }

	  reconcile(model, options) {
	    const workbookXform$1 = new workbookXform();
	    const worksheetXform$1 = new worksheetXform(options);
	    const drawingXform = new drawingXform$1();
	    const tableXform$1 = new tableXform();

	    workbookXform$1.reconcile(model);

	    // reconcile drawings with their rels
	    const drawingOptions = {
	      media: model.media,
	      mediaIndex: model.mediaIndex,
	    };
	    Object.keys(model.drawings).forEach(name => {
	      const drawing = model.drawings[name];
	      const drawingRel = model.drawingRels[name];
	      if (drawingRel) {
	        drawingOptions.rels = drawingRel.reduce((o, rel) => {
	          o[rel.Id] = rel;
	          return o;
	        }, {});
	        (drawing.anchors || []).forEach(anchor => {
	          const hyperlinks = anchor.picture && anchor.picture.hyperlinks;
	          if (hyperlinks && drawingOptions.rels[hyperlinks.rId]) {
	            hyperlinks.hyperlink = drawingOptions.rels[hyperlinks.rId].Target;
	            delete hyperlinks.rId;
	          }
	        });
	        drawingXform.reconcile(drawing, drawingOptions);
	      }
	    });

	    // reconcile tables with the default styles
	    const tableOptions = {
	      styles: model.styles,
	    };
	    Object.values(model.tables).forEach(table => {
	      tableXform$1.reconcile(table, tableOptions);
	    });

	    const sheetOptions = {
	      styles: model.styles,
	      sharedStrings: model.sharedStrings,
	      media: model.media,
	      mediaIndex: model.mediaIndex,
	      date1904: model.properties && model.properties.date1904,
	      drawings: model.drawings,
	      comments: model.comments,
	      tables: model.tables,
	      vmlDrawings: model.vmlDrawings,
	    };
	    model.worksheets.forEach(worksheet => {
	      worksheet.relationships = model.worksheetRels[worksheet.sheetNo];
	      worksheetXform$1.reconcile(worksheet, sheetOptions);
	    });

	    // delete unnecessary parts
	    delete model.worksheetHash;
	    delete model.worksheetRels;
	    delete model.globalRels;
	    delete model.sharedStrings;
	    delete model.workbookRels;
	    delete model.sheetDefs;
	    delete model.styles;
	    delete model.mediaIndex;
	    delete model.drawings;
	    delete model.drawingRels;
	    delete model.vmlDrawings;
	  }

	  async _processWorksheetEntry(stream, model, sheetNo, options, path) {
	    const xform = new worksheetXform(options);
	    const worksheet = await xform.parseStream(stream);
	    worksheet.sheetNo = sheetNo;
	    model.worksheetHash[path] = worksheet;
	    model.worksheets.push(worksheet);
	  }

	  async _processCommentEntry(stream, model, name) {
	    const xform = new commentsXform();
	    const comments = await xform.parseStream(stream);
	    model.comments[`../${name}.xml`] = comments;
	  }

	  async _processTableEntry(stream, model, name) {
	    const xform = new tableXform();
	    const table = await xform.parseStream(stream);
	    model.tables[`../tables/${name}.xml`] = table;
	  }

	  async _processWorksheetRelsEntry(stream, model, sheetNo) {
	    const xform = new relationshipsXform();
	    const relationships = await xform.parseStream(stream);
	    model.worksheetRels[sheetNo] = relationships;
	  }

	  async _processMediaEntry(entry, model, filename) {
	    const lastDot = filename.lastIndexOf('.');
	    // if we can't determine extension, ignore it
	    if (lastDot >= 1) {
	      const extension = filename.substr(lastDot + 1);
	      const name = filename.substr(0, lastDot);
	      await new Promise((resolve, reject) => {
	        const streamBuf$1 = new streamBuf();
	        streamBuf$1.on('finish', () => {
	          model.mediaIndex[filename] = model.media.length;
	          model.mediaIndex[name] = model.media.length;
	          const medium = {
	            type: 'image',
	            name,
	            extension,
	            buffer: streamBuf$1.toBuffer(),
	          };
	          model.media.push(medium);
	          resolve();
	        });
	        entry.on('error', error => {
	          reject(error);
	        });
	        entry.pipe(streamBuf$1);
	      });
	    }
	  }

	  async _processDrawingEntry(entry, model, name) {
	    const xform = new drawingXform$1();
	    const drawing = await xform.parseStream(entry);
	    model.drawings[name] = drawing;
	  }

	  async _processDrawingRelsEntry(entry, model, name) {
	    const xform = new relationshipsXform();
	    const relationships = await xform.parseStream(entry);
	    model.drawingRels[name] = relationships;
	  }

	  async _processVmlDrawingEntry(entry, model, name) {
	    const xform = new vmlNotesXform();
	    const vmlDrawing = await xform.parseStream(entry);
	    model.vmlDrawings[`../drawings/${name}.vml`] = vmlDrawing;
	  }

	  async _processThemeEntry(entry, model, name) {
	    await new Promise((resolve, reject) => {
	      // TODO: stream entry into buffer and store the xml in the model.themes[]
	      const stream = new streamBuf();
	      entry.on('error', reject);
	      stream.on('error', reject);
	      stream.on('finish', () => {
	        model.themes[name] = stream.read().toString();
	        resolve();
	      });
	      entry.pipe(stream);
	    });
	  }

	  /**
	   * @deprecated since version 4.0. You should use `#read` instead. Please follow upgrade instruction: https://github.com/exceljs/exceljs/blob/master/UPGRADE-4.0.md
	   */
	  createInputStream() {
	    throw new Error(
	      '`XLSX#createInputStream` is deprecated. You should use `XLSX#read` instead. This method will be removed in version 5.0. Please follow upgrade instruction: https://github.com/exceljs/exceljs/blob/master/UPGRADE-4.0.md'
	    );
	  }

	  async read(stream, options) {
	    // TODO: Remove once node v8 is deprecated
	    // Detect and upgrade old streams
	    if (!stream[Symbol.asyncIterator] && stream.pipe) {
	      stream = stream.pipe(new PassThrough$2());
	    }
	    const chunks = [];
	    for await (const chunk of stream) {
	      chunks.push(chunk);
	    }
	    return this.load(Buffer.concat(chunks), options);
	  }

	  async load(data, options) {
	    let buffer;
	    if (options && options.base64) {
	      buffer = Buffer.from(data.toString(), 'base64');
	    } else {
	      buffer = data;
	    }

	    const model = {
	      worksheets: [],
	      worksheetHash: {},
	      worksheetRels: [],
	      themes: {},
	      media: [],
	      mediaIndex: {},
	      drawings: {},
	      drawingRels: {},
	      comments: {},
	      tables: {},
	      vmlDrawings: {},
	    };

	    const zip = await jszip_min.loadAsync(buffer);
	    for (const entry of Object.values(zip.files)) {
	      /* eslint-disable no-await-in-loop */
	      if (!entry.dir) {
	        let entryName = entry.name;
	        if (entryName[0] === '/') {
	          entryName = entryName.substr(1);
	        }
	        let stream;
	        if (entryName.match(/xl\/media\//) ||
	          // themes are not parsed as stream
	          entryName.match(/xl\/theme\/([a-zA-Z0-9]+)[.]xml/)) {
	          stream = new PassThrough$2();
	          stream.write(await entry.async('nodebuffer'));
	        } else {
	          // use object mode to avoid buffer-string convention
	          stream = new PassThrough$2({
	            writableObjectMode: true,
	            readableObjectMode: true,
	          });
	          let content;
	          // https://www.npmjs.com/package/process
	          if (process.browser) {
	            // running in browser, use TextDecoder if possible
	            content = bufferToString$2(await entry.async('nodebuffer'));
	          } else {
	            // running in node.js
	            content = await entry.async('string');
	          }
	          const chunkSize = 16 * 1024;
	          for (let i = 0; i < content.length; i += chunkSize) {
	            stream.write(content.substring(i, i + chunkSize));
	          }
	        }
	        stream.end();
	        switch (entryName) {
	          case '_rels/.rels':
	            model.globalRels = await this.parseRels(stream);
	            break;

	          case 'xl/workbook.xml': {
	            const workbook = await this.parseWorkbook(stream);
	            model.sheets = workbook.sheets;
	            model.definedNames = workbook.definedNames;
	            model.views = workbook.views;
	            model.properties = workbook.properties;
	            model.calcProperties = workbook.calcProperties;
	            break;
	          }

	          case 'xl/_rels/workbook.xml.rels':
	            model.workbookRels = await this.parseRels(stream);
	            break;

	          case 'xl/sharedStrings.xml':
	            model.sharedStrings = new sharedStringsXform();
	            await model.sharedStrings.parseStream(stream);
	            break;

	          case 'xl/styles.xml':
	            model.styles = new stylesXform();
	            await model.styles.parseStream(stream);
	            break;

	          case 'docProps/app.xml': {
	            const appXform$1 = new appXform();
	            const appProperties = await appXform$1.parseStream(stream);
	            model.company = appProperties.company;
	            model.manager = appProperties.manager;
	            break;
	          }

	          case 'docProps/core.xml': {
	            const coreXform$1 = new coreXform();
	            const coreProperties = await coreXform$1.parseStream(stream);
	            Object.assign(model, coreProperties);
	            break;
	          }

	          default: {
	            let match = entryName.match(/xl\/worksheets\/sheet(\d+)[.]xml/);
	            if (match) {
	              await this._processWorksheetEntry(stream, model, match[1], options, entryName);
	              break;
	            }
	            match = entryName.match(/xl\/worksheets\/_rels\/sheet(\d+)[.]xml.rels/);
	            if (match) {
	              await this._processWorksheetRelsEntry(stream, model, match[1]);
	              break;
	            }
	            match = entryName.match(/xl\/theme\/([a-zA-Z0-9]+)[.]xml/);
	            if (match) {
	              await this._processThemeEntry(stream, model, match[1]);
	              break;
	            }
	            match = entryName.match(/xl\/media\/([a-zA-Z0-9]+[.][a-zA-Z0-9]{3,4})$/);
	            if (match) {
	              await this._processMediaEntry(stream, model, match[1]);
	              break;
	            }
	            match = entryName.match(/xl\/drawings\/([a-zA-Z0-9]+)[.]xml/);
	            if (match) {
	              await this._processDrawingEntry(stream, model, match[1]);
	              break;
	            }
	            match = entryName.match(/xl\/(comments\d+)[.]xml/);
	            if (match) {
	              await this._processCommentEntry(stream, model, match[1]);
	              break;
	            }
	            match = entryName.match(/xl\/tables\/(table\d+)[.]xml/);
	            if (match) {
	              await this._processTableEntry(stream, model, match[1]);
	              break;
	            }
	            match = entryName.match(/xl\/drawings\/_rels\/([a-zA-Z0-9]+)[.]xml[.]rels/);
	            if (match) {
	              await this._processDrawingRelsEntry(stream, model, match[1]);
	              break;
	            }
	            match = entryName.match(/xl\/drawings\/(vmlDrawing\d+)[.]vml/);
	            if (match) {
	              await this._processVmlDrawingEntry(stream, model, match[1]);
	              break;
	            }
	          }
	        }
	      }
	    }

	    this.reconcile(model, options);

	    // apply model
	    this.workbook.model = model;
	    return this.workbook;
	  }

	  // =========================================================================
	  // Write

	  async addMedia(zip, model) {
	    await Promise.all(
	      model.media.map(async medium => {
	        if (medium.type === 'image') {
	          const filename = `xl/media/${medium.name}.${medium.extension}`;
	          if (medium.filename) {
	            const data = await fsReadFileAsync(medium.filename);
	            return zip.append(data, {name: filename});
	          }
	          if (medium.buffer) {
	            return zip.append(medium.buffer, {name: filename});
	          }
	          if (medium.base64) {
	            const dataimg64 = medium.base64;
	            const content = dataimg64.substring(dataimg64.indexOf(',') + 1);
	            return zip.append(content, {name: filename, base64: true});
	          }
	        }
	        throw new Error('Unsupported media');
	      })
	    );
	  }

	  addDrawings(zip, model) {
	    const drawingXform = new drawingXform$1();
	    const relsXform = new relationshipsXform();

	    model.worksheets.forEach(worksheet => {
	      const {drawing} = worksheet;
	      if (drawing) {
	        drawingXform.prepare(drawing, {});
	        let xml = drawingXform.toXml(drawing);
	        zip.append(xml, {name: `xl/drawings/${drawing.name}.xml`});

	        xml = relsXform.toXml(drawing.rels);
	        zip.append(xml, {name: `xl/drawings/_rels/${drawing.name}.xml.rels`});
	      }
	    });
	  }

	  addTables(zip, model) {
	    const tableXform$1 = new tableXform();

	    model.worksheets.forEach(worksheet => {
	      const {tables} = worksheet;
	      tables.forEach(table => {
	        tableXform$1.prepare(table, {});
	        const tableXml = tableXform$1.toXml(table);
	        zip.append(tableXml, {name: `xl/tables/${table.target}`});
	      });
	    });
	  }

	  async addContentTypes(zip, model) {
	    const xform = new contentTypesXform();
	    const xml = xform.toXml(model);
	    zip.append(xml, {name: '[Content_Types].xml'});
	  }

	  async addApp(zip, model) {
	    const xform = new appXform();
	    const xml = xform.toXml(model);
	    zip.append(xml, {name: 'docProps/app.xml'});
	  }

	  async addCore(zip, model) {
	    const coreXform$1 = new coreXform();
	    zip.append(coreXform$1.toXml(model), {name: 'docProps/core.xml'});
	  }

	  async addThemes(zip, model) {
	    const themes = model.themes || {theme1: theme1};
	    Object.keys(themes).forEach(name => {
	      const xml = themes[name];
	      const path = `xl/theme/${name}.xml`;
	      zip.append(xml, {name: path});
	    });
	  }

	  async addOfficeRels(zip) {
	    const xform = new relationshipsXform();
	    const xml = xform.toXml([
	      {Id: 'rId1', Type: XLSX.RelType.OfficeDocument, Target: 'xl/workbook.xml'},
	      {Id: 'rId2', Type: XLSX.RelType.CoreProperties, Target: 'docProps/core.xml'},
	      {Id: 'rId3', Type: XLSX.RelType.ExtenderProperties, Target: 'docProps/app.xml'},
	    ]);
	    zip.append(xml, {name: '_rels/.rels'});
	  }

	  async addWorkbookRels(zip, model) {
	    let count = 1;
	    const relationships = [
	      {Id: `rId${count++}`, Type: XLSX.RelType.Styles, Target: 'styles.xml'},
	      {Id: `rId${count++}`, Type: XLSX.RelType.Theme, Target: 'theme/theme1.xml'},
	    ];
	    if (model.sharedStrings.count) {
	      relationships.push({
	        Id: `rId${count++}`,
	        Type: XLSX.RelType.SharedStrings,
	        Target: 'sharedStrings.xml',
	      });
	    }
	    model.worksheets.forEach(worksheet => {
	      worksheet.rId = `rId${count++}`;
	      relationships.push({
	        Id: worksheet.rId,
	        Type: XLSX.RelType.Worksheet,
	        Target: `worksheets/sheet${worksheet.id}.xml`,
	      });
	    });
	    const xform = new relationshipsXform();
	    const xml = xform.toXml(relationships);
	    zip.append(xml, {name: 'xl/_rels/workbook.xml.rels'});
	  }

	  async addSharedStrings(zip, model) {
	    if (model.sharedStrings && model.sharedStrings.count) {
	      zip.append(model.sharedStrings.xml, {name: 'xl/sharedStrings.xml'});
	    }
	  }

	  async addStyles(zip, model) {
	    const {xml} = model.styles;
	    if (xml) {
	      zip.append(xml, {name: 'xl/styles.xml'});
	    }
	  }

	  async addWorkbook(zip, model) {
	    const xform = new workbookXform();
	    zip.append(xform.toXml(model), {name: 'xl/workbook.xml'});
	  }

	  async addWorksheets(zip, model) {
	    // preparation phase
	    const worksheetXform$1 = new worksheetXform();
	    const relationshipsXform$1 = new relationshipsXform();
	    const commentsXform$1 = new commentsXform();
	    const vmlNotesXform$1 = new vmlNotesXform();

	    // write sheets
	    model.worksheets.forEach(worksheet => {
	      let xmlStream$1 = new xmlStream();
	      worksheetXform$1.render(xmlStream$1, worksheet);
	      zip.append(xmlStream$1.xml, {name: `xl/worksheets/sheet${worksheet.id}.xml`});

	      if (worksheet.rels && worksheet.rels.length) {
	        xmlStream$1 = new xmlStream();
	        relationshipsXform$1.render(xmlStream$1, worksheet.rels);
	        zip.append(xmlStream$1.xml, {name: `xl/worksheets/_rels/sheet${worksheet.id}.xml.rels`});
	      }

	      if (worksheet.comments.length > 0) {
	        xmlStream$1 = new xmlStream();
	        commentsXform$1.render(xmlStream$1, worksheet);
	        zip.append(xmlStream$1.xml, {name: `xl/comments${worksheet.id}.xml`});

	        xmlStream$1 = new xmlStream();
	        vmlNotesXform$1.render(xmlStream$1, worksheet);
	        zip.append(xmlStream$1.xml, {name: `xl/drawings/vmlDrawing${worksheet.id}.vml`});
	      }
	    });
	  }

	  _finalize(zip) {
	    return new Promise((resolve, reject) => {
	      zip.on('finish', () => {
	        resolve(this);
	      });
	      zip.on('error', reject);
	      zip.finalize();
	    });
	  }

	  prepareModel(model, options) {
	    // ensure following properties have sane values
	    model.creator = model.creator || 'ExcelJS';
	    model.lastModifiedBy = model.lastModifiedBy || 'ExcelJS';
	    model.created = model.created || new Date();
	    model.modified = model.modified || new Date();

	    model.useSharedStrings =
	      options.useSharedStrings !== undefined ? options.useSharedStrings : true;
	    model.useStyles = options.useStyles !== undefined ? options.useStyles : true;

	    // Manage the shared strings
	    model.sharedStrings = new sharedStringsXform();

	    // add a style manager to handle cell formats, fonts, etc.
	    model.styles = model.useStyles ? new stylesXform(true) : new stylesXform.Mock();

	    // prepare all of the things before the render
	    const workbookXform$1 = new workbookXform();
	    const worksheetXform$1 = new worksheetXform();

	    workbookXform$1.prepare(model);

	    const worksheetOptions = {
	      sharedStrings: model.sharedStrings,
	      styles: model.styles,
	      date1904: model.properties.date1904,
	      drawingsCount: 0,
	      media: model.media,
	    };
	    worksheetOptions.drawings = model.drawings = [];
	    worksheetOptions.commentRefs = model.commentRefs = [];
	    let tableCount = 0;
	    model.tables = [];
	    model.worksheets.forEach(worksheet => {
	      // assign unique filenames to tables
	      worksheet.tables.forEach(table => {
	        tableCount++;
	        table.target = `table${tableCount}.xml`;
	        table.id = tableCount;
	        model.tables.push(table);
	      });

	      worksheetXform$1.prepare(worksheet, worksheetOptions);
	    });

	    // TODO: workbook drawing list
	  }

	  async write(stream, options) {
	    options = options || {};
	    const {model} = this.workbook;
	    const zip = new zipStream.ZipWriter(options.zip);
	    zip.pipe(stream);

	    this.prepareModel(model, options);

	    // render
	    await this.addContentTypes(zip, model);
	    await this.addOfficeRels(zip, model);
	    await this.addWorkbookRels(zip, model);
	    await this.addWorksheets(zip, model);
	    await this.addSharedStrings(zip, model); // always after worksheets
	    await this.addDrawings(zip, model);
	    await this.addTables(zip, model);
	    await Promise.all([this.addThemes(zip, model), this.addStyles(zip, model)]);
	    await this.addMedia(zip, model);
	    await Promise.all([this.addApp(zip, model), this.addCore(zip, model)]);
	    await this.addWorkbook(zip, model);
	    return this._finalize(zip);
	  }

	  writeFile(filename, options) {
	    const stream = fs__default['default'].createWriteStream(filename);

	    return new Promise((resolve, reject) => {
	      stream.on('finish', () => {
	        resolve();
	      });
	      stream.on('error', error => {
	        reject(error);
	      });

	      this.write(stream, options).then(() => {
	        stream.end();
	      });
	    });
	  }

	  async writeBuffer(options) {
	    const stream = new streamBuf();
	    await this.write(stream, options);
	    return stream.read();
	  }
	}

	XLSX.RelType = relType;

	var xlsx = XLSX;

	var FormatterOptions_1 = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.FormatterOptions = void 0;
	class FormatterOptions {
	    constructor(opts = {}) {
	        var _a;
	        this.objectMode = true;
	        this.delimiter = ',';
	        this.rowDelimiter = '\n';
	        this.quote = '"';
	        this.escape = this.quote;
	        this.quoteColumns = false;
	        this.quoteHeaders = this.quoteColumns;
	        this.headers = null;
	        this.includeEndRowDelimiter = false;
	        this.writeBOM = false;
	        this.BOM = '\ufeff';
	        this.alwaysWriteHeaders = false;
	        Object.assign(this, opts || {});
	        if (typeof (opts === null || opts === void 0 ? void 0 : opts.quoteHeaders) === 'undefined') {
	            this.quoteHeaders = this.quoteColumns;
	        }
	        if ((opts === null || opts === void 0 ? void 0 : opts.quote) === true) {
	            this.quote = '"';
	        }
	        else if ((opts === null || opts === void 0 ? void 0 : opts.quote) === false) {
	            this.quote = '';
	        }
	        if (typeof (opts === null || opts === void 0 ? void 0 : opts.escape) !== 'string') {
	            this.escape = this.quote;
	        }
	        this.shouldWriteHeaders = !!this.headers && ((_a = opts.writeHeaders) !== null && _a !== void 0 ? _a : true);
	        this.headers = Array.isArray(this.headers) ? this.headers : null;
	        this.escapedQuote = `${this.escape}${this.quote}`;
	    }
	}
	exports.FormatterOptions = FormatterOptions;

	});

	unwrapExports(FormatterOptions_1);
	var FormatterOptions_2 = FormatterOptions_1.FormatterOptions;

	/**
	 * Lodash (Custom Build) <https://lodash.com/>
	 * Build: `lodash modularize exports="npm" -o ./`
	 * Copyright JS Foundation and other contributors <https://js.foundation/>
	 * Released under MIT license <https://lodash.com/license>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 */

	/** `Object#toString` result references. */
	var asyncTag = '[object AsyncFunction]',
	    funcTag = '[object Function]',
	    genTag = '[object GeneratorFunction]',
	    nullTag = '[object Null]',
	    proxyTag = '[object Proxy]',
	    undefinedTag = '[object Undefined]';

	/** Detect free variable `global` from Node.js. */
	var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

	/** Detect free variable `self`. */
	var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

	/** Used as a reference to the global object. */
	var root = freeGlobal || freeSelf || Function('return this')();

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$1 = objectProto.hasOwnProperty;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString = objectProto.toString;

	/** Built-in value references. */
	var Symbol$2 = root.Symbol,
	    symToStringTag = Symbol$2 ? Symbol$2.toStringTag : undefined;

	/**
	 * The base implementation of `getTag` without fallbacks for buggy environments.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	function baseGetTag(value) {
	  if (value == null) {
	    return value === undefined ? undefinedTag : nullTag;
	  }
	  return (symToStringTag && symToStringTag in Object(value))
	    ? getRawTag(value)
	    : objectToString(value);
	}

	/**
	 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the raw `toStringTag`.
	 */
	function getRawTag(value) {
	  var isOwn = hasOwnProperty$1.call(value, symToStringTag),
	      tag = value[symToStringTag];

	  try {
	    value[symToStringTag] = undefined;
	    var unmasked = true;
	  } catch (e) {}

	  var result = nativeObjectToString.call(value);
	  if (unmasked) {
	    if (isOwn) {
	      value[symToStringTag] = tag;
	    } else {
	      delete value[symToStringTag];
	    }
	  }
	  return result;
	}

	/**
	 * Converts `value` to a string using `Object.prototype.toString`.
	 *
	 * @private
	 * @param {*} value The value to convert.
	 * @returns {string} Returns the converted string.
	 */
	function objectToString(value) {
	  return nativeObjectToString.call(value);
	}

	/**
	 * Checks if `value` is classified as a `Function` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
	 * @example
	 *
	 * _.isFunction(_);
	 * // => true
	 *
	 * _.isFunction(/abc/);
	 * // => false
	 */
	function isFunction(value) {
	  if (!isObject$1(value)) {
	    return false;
	  }
	  // The use of `Object#toString` avoids issues with the `typeof` operator
	  // in Safari 9 which returns 'object' for typed arrays and other constructors.
	  var tag = baseGetTag(value);
	  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
	}

	/**
	 * Checks if `value` is the
	 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
	 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(_.noop);
	 * // => true
	 *
	 * _.isObject(null);
	 * // => false
	 */
	function isObject$1(value) {
	  var type = typeof value;
	  return value != null && (type == 'object' || type == 'function');
	}

	var lodash_isfunction = isFunction;

	var lodash_isequal = createCommonjsModule(function (module, exports) {
	/**
	 * Lodash (Custom Build) <https://lodash.com/>
	 * Build: `lodash modularize exports="npm" -o ./`
	 * Copyright JS Foundation and other contributors <https://js.foundation/>
	 * Released under MIT license <https://lodash.com/license>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 */

	/** Used as the size to enable large array optimizations. */
	var LARGE_ARRAY_SIZE = 200;

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED = '__lodash_hash_undefined__';

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG = 1,
	    COMPARE_UNORDERED_FLAG = 2;

	/** Used as references for various `Number` constants. */
	var MAX_SAFE_INTEGER = 9007199254740991;

	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]',
	    arrayTag = '[object Array]',
	    asyncTag = '[object AsyncFunction]',
	    boolTag = '[object Boolean]',
	    dateTag = '[object Date]',
	    errorTag = '[object Error]',
	    funcTag = '[object Function]',
	    genTag = '[object GeneratorFunction]',
	    mapTag = '[object Map]',
	    numberTag = '[object Number]',
	    nullTag = '[object Null]',
	    objectTag = '[object Object]',
	    promiseTag = '[object Promise]',
	    proxyTag = '[object Proxy]',
	    regexpTag = '[object RegExp]',
	    setTag = '[object Set]',
	    stringTag = '[object String]',
	    symbolTag = '[object Symbol]',
	    undefinedTag = '[object Undefined]',
	    weakMapTag = '[object WeakMap]';

	var arrayBufferTag = '[object ArrayBuffer]',
	    dataViewTag = '[object DataView]',
	    float32Tag = '[object Float32Array]',
	    float64Tag = '[object Float64Array]',
	    int8Tag = '[object Int8Array]',
	    int16Tag = '[object Int16Array]',
	    int32Tag = '[object Int32Array]',
	    uint8Tag = '[object Uint8Array]',
	    uint8ClampedTag = '[object Uint8ClampedArray]',
	    uint16Tag = '[object Uint16Array]',
	    uint32Tag = '[object Uint32Array]';

	/**
	 * Used to match `RegExp`
	 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
	 */
	var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

	/** Used to detect host constructors (Safari). */
	var reIsHostCtor = /^\[object .+?Constructor\]$/;

	/** Used to detect unsigned integer values. */
	var reIsUint = /^(?:0|[1-9]\d*)$/;

	/** Used to identify `toStringTag` values of typed arrays. */
	var typedArrayTags = {};
	typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
	typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
	typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
	typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
	typedArrayTags[uint32Tag] = true;
	typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
	typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
	typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
	typedArrayTags[errorTag] = typedArrayTags[funcTag] =
	typedArrayTags[mapTag] = typedArrayTags[numberTag] =
	typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
	typedArrayTags[setTag] = typedArrayTags[stringTag] =
	typedArrayTags[weakMapTag] = false;

	/** Detect free variable `global` from Node.js. */
	var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

	/** Detect free variable `self`. */
	var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

	/** Used as a reference to the global object. */
	var root = freeGlobal || freeSelf || Function('return this')();

	/** Detect free variable `exports`. */
	var freeExports =  exports && !exports.nodeType && exports;

	/** Detect free variable `module`. */
	var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

	/** Detect the popular CommonJS extension `module.exports`. */
	var moduleExports = freeModule && freeModule.exports === freeExports;

	/** Detect free variable `process` from Node.js. */
	var freeProcess = moduleExports && freeGlobal.process;

	/** Used to access faster Node.js helpers. */
	var nodeUtil = (function() {
	  try {
	    return freeProcess && freeProcess.binding && freeProcess.binding('util');
	  } catch (e) {}
	}());

	/* Node.js helper references. */
	var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

	/**
	 * A specialized version of `_.filter` for arrays without support for
	 * iteratee shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} predicate The function invoked per iteration.
	 * @returns {Array} Returns the new filtered array.
	 */
	function arrayFilter(array, predicate) {
	  var index = -1,
	      length = array == null ? 0 : array.length,
	      resIndex = 0,
	      result = [];

	  while (++index < length) {
	    var value = array[index];
	    if (predicate(value, index, array)) {
	      result[resIndex++] = value;
	    }
	  }
	  return result;
	}

	/**
	 * Appends the elements of `values` to `array`.
	 *
	 * @private
	 * @param {Array} array The array to modify.
	 * @param {Array} values The values to append.
	 * @returns {Array} Returns `array`.
	 */
	function arrayPush(array, values) {
	  var index = -1,
	      length = values.length,
	      offset = array.length;

	  while (++index < length) {
	    array[offset + index] = values[index];
	  }
	  return array;
	}

	/**
	 * A specialized version of `_.some` for arrays without support for iteratee
	 * shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} predicate The function invoked per iteration.
	 * @returns {boolean} Returns `true` if any element passes the predicate check,
	 *  else `false`.
	 */
	function arraySome(array, predicate) {
	  var index = -1,
	      length = array == null ? 0 : array.length;

	  while (++index < length) {
	    if (predicate(array[index], index, array)) {
	      return true;
	    }
	  }
	  return false;
	}

	/**
	 * The base implementation of `_.times` without support for iteratee shorthands
	 * or max array length checks.
	 *
	 * @private
	 * @param {number} n The number of times to invoke `iteratee`.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the array of results.
	 */
	function baseTimes(n, iteratee) {
	  var index = -1,
	      result = Array(n);

	  while (++index < n) {
	    result[index] = iteratee(index);
	  }
	  return result;
	}

	/**
	 * The base implementation of `_.unary` without support for storing metadata.
	 *
	 * @private
	 * @param {Function} func The function to cap arguments for.
	 * @returns {Function} Returns the new capped function.
	 */
	function baseUnary(func) {
	  return function(value) {
	    return func(value);
	  };
	}

	/**
	 * Checks if a `cache` value for `key` exists.
	 *
	 * @private
	 * @param {Object} cache The cache to query.
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function cacheHas(cache, key) {
	  return cache.has(key);
	}

	/**
	 * Gets the value at `key` of `object`.
	 *
	 * @private
	 * @param {Object} [object] The object to query.
	 * @param {string} key The key of the property to get.
	 * @returns {*} Returns the property value.
	 */
	function getValue(object, key) {
	  return object == null ? undefined : object[key];
	}

	/**
	 * Converts `map` to its key-value pairs.
	 *
	 * @private
	 * @param {Object} map The map to convert.
	 * @returns {Array} Returns the key-value pairs.
	 */
	function mapToArray(map) {
	  var index = -1,
	      result = Array(map.size);

	  map.forEach(function(value, key) {
	    result[++index] = [key, value];
	  });
	  return result;
	}

	/**
	 * Creates a unary function that invokes `func` with its argument transformed.
	 *
	 * @private
	 * @param {Function} func The function to wrap.
	 * @param {Function} transform The argument transform.
	 * @returns {Function} Returns the new function.
	 */
	function overArg(func, transform) {
	  return function(arg) {
	    return func(transform(arg));
	  };
	}

	/**
	 * Converts `set` to an array of its values.
	 *
	 * @private
	 * @param {Object} set The set to convert.
	 * @returns {Array} Returns the values.
	 */
	function setToArray(set) {
	  var index = -1,
	      result = Array(set.size);

	  set.forEach(function(value) {
	    result[++index] = value;
	  });
	  return result;
	}

	/** Used for built-in method references. */
	var arrayProto = Array.prototype,
	    funcProto = Function.prototype,
	    objectProto = Object.prototype;

	/** Used to detect overreaching core-js shims. */
	var coreJsData = root['__core-js_shared__'];

	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/** Used to detect methods masquerading as native. */
	var maskSrcKey = (function() {
	  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
	  return uid ? ('Symbol(src)_1.' + uid) : '';
	}());

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString = objectProto.toString;

	/** Used to detect if a method is native. */
	var reIsNative = RegExp('^' +
	  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
	  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
	);

	/** Built-in value references. */
	var Buffer = moduleExports ? root.Buffer : undefined,
	    Symbol = root.Symbol,
	    Uint8Array = root.Uint8Array,
	    propertyIsEnumerable = objectProto.propertyIsEnumerable,
	    splice = arrayProto.splice,
	    symToStringTag = Symbol ? Symbol.toStringTag : undefined;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeGetSymbols = Object.getOwnPropertySymbols,
	    nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
	    nativeKeys = overArg(Object.keys, Object);

	/* Built-in method references that are verified to be native. */
	var DataView = getNative(root, 'DataView'),
	    Map = getNative(root, 'Map'),
	    Promise = getNative(root, 'Promise'),
	    Set = getNative(root, 'Set'),
	    WeakMap = getNative(root, 'WeakMap'),
	    nativeCreate = getNative(Object, 'create');

	/** Used to detect maps, sets, and weakmaps. */
	var dataViewCtorString = toSource(DataView),
	    mapCtorString = toSource(Map),
	    promiseCtorString = toSource(Promise),
	    setCtorString = toSource(Set),
	    weakMapCtorString = toSource(WeakMap);

	/** Used to convert symbols to primitives and strings. */
	var symbolProto = Symbol ? Symbol.prototype : undefined,
	    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

	/**
	 * Creates a hash object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Hash(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	/**
	 * Removes all key-value entries from the hash.
	 *
	 * @private
	 * @name clear
	 * @memberOf Hash
	 */
	function hashClear() {
	  this.__data__ = nativeCreate ? nativeCreate(null) : {};
	  this.size = 0;
	}

	/**
	 * Removes `key` and its value from the hash.
	 *
	 * @private
	 * @name delete
	 * @memberOf Hash
	 * @param {Object} hash The hash to modify.
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function hashDelete(key) {
	  var result = this.has(key) && delete this.__data__[key];
	  this.size -= result ? 1 : 0;
	  return result;
	}

	/**
	 * Gets the hash value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Hash
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function hashGet(key) {
	  var data = this.__data__;
	  if (nativeCreate) {
	    var result = data[key];
	    return result === HASH_UNDEFINED ? undefined : result;
	  }
	  return hasOwnProperty.call(data, key) ? data[key] : undefined;
	}

	/**
	 * Checks if a hash value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Hash
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function hashHas(key) {
	  var data = this.__data__;
	  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
	}

	/**
	 * Sets the hash `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Hash
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the hash instance.
	 */
	function hashSet(key, value) {
	  var data = this.__data__;
	  this.size += this.has(key) ? 0 : 1;
	  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
	  return this;
	}

	// Add methods to `Hash`.
	Hash.prototype.clear = hashClear;
	Hash.prototype['delete'] = hashDelete;
	Hash.prototype.get = hashGet;
	Hash.prototype.has = hashHas;
	Hash.prototype.set = hashSet;

	/**
	 * Creates an list cache object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function ListCache(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	/**
	 * Removes all key-value entries from the list cache.
	 *
	 * @private
	 * @name clear
	 * @memberOf ListCache
	 */
	function listCacheClear() {
	  this.__data__ = [];
	  this.size = 0;
	}

	/**
	 * Removes `key` and its value from the list cache.
	 *
	 * @private
	 * @name delete
	 * @memberOf ListCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function listCacheDelete(key) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);

	  if (index < 0) {
	    return false;
	  }
	  var lastIndex = data.length - 1;
	  if (index == lastIndex) {
	    data.pop();
	  } else {
	    splice.call(data, index, 1);
	  }
	  --this.size;
	  return true;
	}

	/**
	 * Gets the list cache value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf ListCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function listCacheGet(key) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);

	  return index < 0 ? undefined : data[index][1];
	}

	/**
	 * Checks if a list cache value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf ListCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function listCacheHas(key) {
	  return assocIndexOf(this.__data__, key) > -1;
	}

	/**
	 * Sets the list cache `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf ListCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the list cache instance.
	 */
	function listCacheSet(key, value) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);

	  if (index < 0) {
	    ++this.size;
	    data.push([key, value]);
	  } else {
	    data[index][1] = value;
	  }
	  return this;
	}

	// Add methods to `ListCache`.
	ListCache.prototype.clear = listCacheClear;
	ListCache.prototype['delete'] = listCacheDelete;
	ListCache.prototype.get = listCacheGet;
	ListCache.prototype.has = listCacheHas;
	ListCache.prototype.set = listCacheSet;

	/**
	 * Creates a map cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function MapCache(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	/**
	 * Removes all key-value entries from the map.
	 *
	 * @private
	 * @name clear
	 * @memberOf MapCache
	 */
	function mapCacheClear() {
	  this.size = 0;
	  this.__data__ = {
	    'hash': new Hash,
	    'map': new (Map || ListCache),
	    'string': new Hash
	  };
	}

	/**
	 * Removes `key` and its value from the map.
	 *
	 * @private
	 * @name delete
	 * @memberOf MapCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function mapCacheDelete(key) {
	  var result = getMapData(this, key)['delete'](key);
	  this.size -= result ? 1 : 0;
	  return result;
	}

	/**
	 * Gets the map value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf MapCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function mapCacheGet(key) {
	  return getMapData(this, key).get(key);
	}

	/**
	 * Checks if a map value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf MapCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function mapCacheHas(key) {
	  return getMapData(this, key).has(key);
	}

	/**
	 * Sets the map `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf MapCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the map cache instance.
	 */
	function mapCacheSet(key, value) {
	  var data = getMapData(this, key),
	      size = data.size;

	  data.set(key, value);
	  this.size += data.size == size ? 0 : 1;
	  return this;
	}

	// Add methods to `MapCache`.
	MapCache.prototype.clear = mapCacheClear;
	MapCache.prototype['delete'] = mapCacheDelete;
	MapCache.prototype.get = mapCacheGet;
	MapCache.prototype.has = mapCacheHas;
	MapCache.prototype.set = mapCacheSet;

	/**
	 *
	 * Creates an array cache object to store unique values.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [values] The values to cache.
	 */
	function SetCache(values) {
	  var index = -1,
	      length = values == null ? 0 : values.length;

	  this.__data__ = new MapCache;
	  while (++index < length) {
	    this.add(values[index]);
	  }
	}

	/**
	 * Adds `value` to the array cache.
	 *
	 * @private
	 * @name add
	 * @memberOf SetCache
	 * @alias push
	 * @param {*} value The value to cache.
	 * @returns {Object} Returns the cache instance.
	 */
	function setCacheAdd(value) {
	  this.__data__.set(value, HASH_UNDEFINED);
	  return this;
	}

	/**
	 * Checks if `value` is in the array cache.
	 *
	 * @private
	 * @name has
	 * @memberOf SetCache
	 * @param {*} value The value to search for.
	 * @returns {number} Returns `true` if `value` is found, else `false`.
	 */
	function setCacheHas(value) {
	  return this.__data__.has(value);
	}

	// Add methods to `SetCache`.
	SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
	SetCache.prototype.has = setCacheHas;

	/**
	 * Creates a stack cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Stack(entries) {
	  var data = this.__data__ = new ListCache(entries);
	  this.size = data.size;
	}

	/**
	 * Removes all key-value entries from the stack.
	 *
	 * @private
	 * @name clear
	 * @memberOf Stack
	 */
	function stackClear() {
	  this.__data__ = new ListCache;
	  this.size = 0;
	}

	/**
	 * Removes `key` and its value from the stack.
	 *
	 * @private
	 * @name delete
	 * @memberOf Stack
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function stackDelete(key) {
	  var data = this.__data__,
	      result = data['delete'](key);

	  this.size = data.size;
	  return result;
	}

	/**
	 * Gets the stack value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Stack
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function stackGet(key) {
	  return this.__data__.get(key);
	}

	/**
	 * Checks if a stack value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Stack
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function stackHas(key) {
	  return this.__data__.has(key);
	}

	/**
	 * Sets the stack `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Stack
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the stack cache instance.
	 */
	function stackSet(key, value) {
	  var data = this.__data__;
	  if (data instanceof ListCache) {
	    var pairs = data.__data__;
	    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
	      pairs.push([key, value]);
	      this.size = ++data.size;
	      return this;
	    }
	    data = this.__data__ = new MapCache(pairs);
	  }
	  data.set(key, value);
	  this.size = data.size;
	  return this;
	}

	// Add methods to `Stack`.
	Stack.prototype.clear = stackClear;
	Stack.prototype['delete'] = stackDelete;
	Stack.prototype.get = stackGet;
	Stack.prototype.has = stackHas;
	Stack.prototype.set = stackSet;

	/**
	 * Creates an array of the enumerable property names of the array-like `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @param {boolean} inherited Specify returning inherited property names.
	 * @returns {Array} Returns the array of property names.
	 */
	function arrayLikeKeys(value, inherited) {
	  var isArr = isArray(value),
	      isArg = !isArr && isArguments(value),
	      isBuff = !isArr && !isArg && isBuffer(value),
	      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
	      skipIndexes = isArr || isArg || isBuff || isType,
	      result = skipIndexes ? baseTimes(value.length, String) : [],
	      length = result.length;

	  for (var key in value) {
	    if ((inherited || hasOwnProperty.call(value, key)) &&
	        !(skipIndexes && (
	           // Safari 9 has enumerable `arguments.length` in strict mode.
	           key == 'length' ||
	           // Node.js 0.10 has enumerable non-index properties on buffers.
	           (isBuff && (key == 'offset' || key == 'parent')) ||
	           // PhantomJS 2 has enumerable non-index properties on typed arrays.
	           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
	           // Skip index properties.
	           isIndex(key, length)
	        ))) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	/**
	 * Gets the index at which the `key` is found in `array` of key-value pairs.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} key The key to search for.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function assocIndexOf(array, key) {
	  var length = array.length;
	  while (length--) {
	    if (eq(array[length][0], key)) {
	      return length;
	    }
	  }
	  return -1;
	}

	/**
	 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
	 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
	 * symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Function} keysFunc The function to get the keys of `object`.
	 * @param {Function} symbolsFunc The function to get the symbols of `object`.
	 * @returns {Array} Returns the array of property names and symbols.
	 */
	function baseGetAllKeys(object, keysFunc, symbolsFunc) {
	  var result = keysFunc(object);
	  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
	}

	/**
	 * The base implementation of `getTag` without fallbacks for buggy environments.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	function baseGetTag(value) {
	  if (value == null) {
	    return value === undefined ? undefinedTag : nullTag;
	  }
	  return (symToStringTag && symToStringTag in Object(value))
	    ? getRawTag(value)
	    : objectToString(value);
	}

	/**
	 * The base implementation of `_.isArguments`.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 */
	function baseIsArguments(value) {
	  return isObjectLike(value) && baseGetTag(value) == argsTag;
	}

	/**
	 * The base implementation of `_.isEqual` which supports partial comparisons
	 * and tracks traversed objects.
	 *
	 * @private
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @param {boolean} bitmask The bitmask flags.
	 *  1 - Unordered comparison
	 *  2 - Partial comparison
	 * @param {Function} [customizer] The function to customize comparisons.
	 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 */
	function baseIsEqual(value, other, bitmask, customizer, stack) {
	  if (value === other) {
	    return true;
	  }
	  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
	    return value !== value && other !== other;
	  }
	  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
	}

	/**
	 * A specialized version of `baseIsEqual` for arrays and objects which performs
	 * deep comparisons and tracks traversed objects enabling objects with circular
	 * references to be compared.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
	  var objIsArr = isArray(object),
	      othIsArr = isArray(other),
	      objTag = objIsArr ? arrayTag : getTag(object),
	      othTag = othIsArr ? arrayTag : getTag(other);

	  objTag = objTag == argsTag ? objectTag : objTag;
	  othTag = othTag == argsTag ? objectTag : othTag;

	  var objIsObj = objTag == objectTag,
	      othIsObj = othTag == objectTag,
	      isSameTag = objTag == othTag;

	  if (isSameTag && isBuffer(object)) {
	    if (!isBuffer(other)) {
	      return false;
	    }
	    objIsArr = true;
	    objIsObj = false;
	  }
	  if (isSameTag && !objIsObj) {
	    stack || (stack = new Stack);
	    return (objIsArr || isTypedArray(object))
	      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
	      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
	  }
	  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
	    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
	        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

	    if (objIsWrapped || othIsWrapped) {
	      var objUnwrapped = objIsWrapped ? object.value() : object,
	          othUnwrapped = othIsWrapped ? other.value() : other;

	      stack || (stack = new Stack);
	      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
	    }
	  }
	  if (!isSameTag) {
	    return false;
	  }
	  stack || (stack = new Stack);
	  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
	}

	/**
	 * The base implementation of `_.isNative` without bad shim checks.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a native function,
	 *  else `false`.
	 */
	function baseIsNative(value) {
	  if (!isObject(value) || isMasked(value)) {
	    return false;
	  }
	  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
	  return pattern.test(toSource(value));
	}

	/**
	 * The base implementation of `_.isTypedArray` without Node.js optimizations.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 */
	function baseIsTypedArray(value) {
	  return isObjectLike(value) &&
	    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
	}

	/**
	 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function baseKeys(object) {
	  if (!isPrototype(object)) {
	    return nativeKeys(object);
	  }
	  var result = [];
	  for (var key in Object(object)) {
	    if (hasOwnProperty.call(object, key) && key != 'constructor') {
	      result.push(key);
	    }
	  }
	  return result;
	}

	/**
	 * A specialized version of `baseIsEqualDeep` for arrays with support for
	 * partial deep comparisons.
	 *
	 * @private
	 * @param {Array} array The array to compare.
	 * @param {Array} other The other array to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} stack Tracks traversed `array` and `other` objects.
	 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
	 */
	function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
	  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
	      arrLength = array.length,
	      othLength = other.length;

	  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
	    return false;
	  }
	  // Assume cyclic values are equal.
	  var stacked = stack.get(array);
	  if (stacked && stack.get(other)) {
	    return stacked == other;
	  }
	  var index = -1,
	      result = true,
	      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;

	  stack.set(array, other);
	  stack.set(other, array);

	  // Ignore non-index properties.
	  while (++index < arrLength) {
	    var arrValue = array[index],
	        othValue = other[index];

	    if (customizer) {
	      var compared = isPartial
	        ? customizer(othValue, arrValue, index, other, array, stack)
	        : customizer(arrValue, othValue, index, array, other, stack);
	    }
	    if (compared !== undefined) {
	      if (compared) {
	        continue;
	      }
	      result = false;
	      break;
	    }
	    // Recursively compare arrays (susceptible to call stack limits).
	    if (seen) {
	      if (!arraySome(other, function(othValue, othIndex) {
	            if (!cacheHas(seen, othIndex) &&
	                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
	              return seen.push(othIndex);
	            }
	          })) {
	        result = false;
	        break;
	      }
	    } else if (!(
	          arrValue === othValue ||
	            equalFunc(arrValue, othValue, bitmask, customizer, stack)
	        )) {
	      result = false;
	      break;
	    }
	  }
	  stack['delete'](array);
	  stack['delete'](other);
	  return result;
	}

	/**
	 * A specialized version of `baseIsEqualDeep` for comparing objects of
	 * the same `toStringTag`.
	 *
	 * **Note:** This function only supports comparing values with tags of
	 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {string} tag The `toStringTag` of the objects to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} stack Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
	  switch (tag) {
	    case dataViewTag:
	      if ((object.byteLength != other.byteLength) ||
	          (object.byteOffset != other.byteOffset)) {
	        return false;
	      }
	      object = object.buffer;
	      other = other.buffer;

	    case arrayBufferTag:
	      if ((object.byteLength != other.byteLength) ||
	          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
	        return false;
	      }
	      return true;

	    case boolTag:
	    case dateTag:
	    case numberTag:
	      // Coerce booleans to `1` or `0` and dates to milliseconds.
	      // Invalid dates are coerced to `NaN`.
	      return eq(+object, +other);

	    case errorTag:
	      return object.name == other.name && object.message == other.message;

	    case regexpTag:
	    case stringTag:
	      // Coerce regexes to strings and treat strings, primitives and objects,
	      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
	      // for more details.
	      return object == (other + '');

	    case mapTag:
	      var convert = mapToArray;

	    case setTag:
	      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
	      convert || (convert = setToArray);

	      if (object.size != other.size && !isPartial) {
	        return false;
	      }
	      // Assume cyclic values are equal.
	      var stacked = stack.get(object);
	      if (stacked) {
	        return stacked == other;
	      }
	      bitmask |= COMPARE_UNORDERED_FLAG;

	      // Recursively compare objects (susceptible to call stack limits).
	      stack.set(object, other);
	      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
	      stack['delete'](object);
	      return result;

	    case symbolTag:
	      if (symbolValueOf) {
	        return symbolValueOf.call(object) == symbolValueOf.call(other);
	      }
	  }
	  return false;
	}

	/**
	 * A specialized version of `baseIsEqualDeep` for objects with support for
	 * partial deep comparisons.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} stack Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
	  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
	      objProps = getAllKeys(object),
	      objLength = objProps.length,
	      othProps = getAllKeys(other),
	      othLength = othProps.length;

	  if (objLength != othLength && !isPartial) {
	    return false;
	  }
	  var index = objLength;
	  while (index--) {
	    var key = objProps[index];
	    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
	      return false;
	    }
	  }
	  // Assume cyclic values are equal.
	  var stacked = stack.get(object);
	  if (stacked && stack.get(other)) {
	    return stacked == other;
	  }
	  var result = true;
	  stack.set(object, other);
	  stack.set(other, object);

	  var skipCtor = isPartial;
	  while (++index < objLength) {
	    key = objProps[index];
	    var objValue = object[key],
	        othValue = other[key];

	    if (customizer) {
	      var compared = isPartial
	        ? customizer(othValue, objValue, key, other, object, stack)
	        : customizer(objValue, othValue, key, object, other, stack);
	    }
	    // Recursively compare objects (susceptible to call stack limits).
	    if (!(compared === undefined
	          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
	          : compared
	        )) {
	      result = false;
	      break;
	    }
	    skipCtor || (skipCtor = key == 'constructor');
	  }
	  if (result && !skipCtor) {
	    var objCtor = object.constructor,
	        othCtor = other.constructor;

	    // Non `Object` object instances with different constructors are not equal.
	    if (objCtor != othCtor &&
	        ('constructor' in object && 'constructor' in other) &&
	        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
	          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
	      result = false;
	    }
	  }
	  stack['delete'](object);
	  stack['delete'](other);
	  return result;
	}

	/**
	 * Creates an array of own enumerable property names and symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names and symbols.
	 */
	function getAllKeys(object) {
	  return baseGetAllKeys(object, keys, getSymbols);
	}

	/**
	 * Gets the data for `map`.
	 *
	 * @private
	 * @param {Object} map The map to query.
	 * @param {string} key The reference key.
	 * @returns {*} Returns the map data.
	 */
	function getMapData(map, key) {
	  var data = map.__data__;
	  return isKeyable(key)
	    ? data[typeof key == 'string' ? 'string' : 'hash']
	    : data.map;
	}

	/**
	 * Gets the native function at `key` of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {string} key The key of the method to get.
	 * @returns {*} Returns the function if it's native, else `undefined`.
	 */
	function getNative(object, key) {
	  var value = getValue(object, key);
	  return baseIsNative(value) ? value : undefined;
	}

	/**
	 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the raw `toStringTag`.
	 */
	function getRawTag(value) {
	  var isOwn = hasOwnProperty.call(value, symToStringTag),
	      tag = value[symToStringTag];

	  try {
	    value[symToStringTag] = undefined;
	    var unmasked = true;
	  } catch (e) {}

	  var result = nativeObjectToString.call(value);
	  if (unmasked) {
	    if (isOwn) {
	      value[symToStringTag] = tag;
	    } else {
	      delete value[symToStringTag];
	    }
	  }
	  return result;
	}

	/**
	 * Creates an array of the own enumerable symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of symbols.
	 */
	var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
	  if (object == null) {
	    return [];
	  }
	  object = Object(object);
	  return arrayFilter(nativeGetSymbols(object), function(symbol) {
	    return propertyIsEnumerable.call(object, symbol);
	  });
	};

	/**
	 * Gets the `toStringTag` of `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	var getTag = baseGetTag;

	// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
	if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
	    (Map && getTag(new Map) != mapTag) ||
	    (Promise && getTag(Promise.resolve()) != promiseTag) ||
	    (Set && getTag(new Set) != setTag) ||
	    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
	  getTag = function(value) {
	    var result = baseGetTag(value),
	        Ctor = result == objectTag ? value.constructor : undefined,
	        ctorString = Ctor ? toSource(Ctor) : '';

	    if (ctorString) {
	      switch (ctorString) {
	        case dataViewCtorString: return dataViewTag;
	        case mapCtorString: return mapTag;
	        case promiseCtorString: return promiseTag;
	        case setCtorString: return setTag;
	        case weakMapCtorString: return weakMapTag;
	      }
	    }
	    return result;
	  };
	}

	/**
	 * Checks if `value` is a valid array-like index.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
	 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
	 */
	function isIndex(value, length) {
	  length = length == null ? MAX_SAFE_INTEGER : length;
	  return !!length &&
	    (typeof value == 'number' || reIsUint.test(value)) &&
	    (value > -1 && value % 1 == 0 && value < length);
	}

	/**
	 * Checks if `value` is suitable for use as unique object key.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
	 */
	function isKeyable(value) {
	  var type = typeof value;
	  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
	    ? (value !== '__proto__')
	    : (value === null);
	}

	/**
	 * Checks if `func` has its source masked.
	 *
	 * @private
	 * @param {Function} func The function to check.
	 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
	 */
	function isMasked(func) {
	  return !!maskSrcKey && (maskSrcKey in func);
	}

	/**
	 * Checks if `value` is likely a prototype object.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
	 */
	function isPrototype(value) {
	  var Ctor = value && value.constructor,
	      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

	  return value === proto;
	}

	/**
	 * Converts `value` to a string using `Object.prototype.toString`.
	 *
	 * @private
	 * @param {*} value The value to convert.
	 * @returns {string} Returns the converted string.
	 */
	function objectToString(value) {
	  return nativeObjectToString.call(value);
	}

	/**
	 * Converts `func` to its source code.
	 *
	 * @private
	 * @param {Function} func The function to convert.
	 * @returns {string} Returns the source code.
	 */
	function toSource(func) {
	  if (func != null) {
	    try {
	      return funcToString.call(func);
	    } catch (e) {}
	    try {
	      return (func + '');
	    } catch (e) {}
	  }
	  return '';
	}

	/**
	 * Performs a
	 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * comparison between two values to determine if they are equivalent.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 * var other = { 'a': 1 };
	 *
	 * _.eq(object, object);
	 * // => true
	 *
	 * _.eq(object, other);
	 * // => false
	 *
	 * _.eq('a', 'a');
	 * // => true
	 *
	 * _.eq('a', Object('a'));
	 * // => false
	 *
	 * _.eq(NaN, NaN);
	 * // => true
	 */
	function eq(value, other) {
	  return value === other || (value !== value && other !== other);
	}

	/**
	 * Checks if `value` is likely an `arguments` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArguments(function() { return arguments; }());
	 * // => true
	 *
	 * _.isArguments([1, 2, 3]);
	 * // => false
	 */
	var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
	  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
	    !propertyIsEnumerable.call(value, 'callee');
	};

	/**
	 * Checks if `value` is classified as an `Array` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
	 * @example
	 *
	 * _.isArray([1, 2, 3]);
	 * // => true
	 *
	 * _.isArray(document.body.children);
	 * // => false
	 *
	 * _.isArray('abc');
	 * // => false
	 *
	 * _.isArray(_.noop);
	 * // => false
	 */
	var isArray = Array.isArray;

	/**
	 * Checks if `value` is array-like. A value is considered array-like if it's
	 * not a function and has a `value.length` that's an integer greater than or
	 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	 * @example
	 *
	 * _.isArrayLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLike(document.body.children);
	 * // => true
	 *
	 * _.isArrayLike('abc');
	 * // => true
	 *
	 * _.isArrayLike(_.noop);
	 * // => false
	 */
	function isArrayLike(value) {
	  return value != null && isLength(value.length) && !isFunction(value);
	}

	/**
	 * Checks if `value` is a buffer.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.3.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
	 * @example
	 *
	 * _.isBuffer(new Buffer(2));
	 * // => true
	 *
	 * _.isBuffer(new Uint8Array(2));
	 * // => false
	 */
	var isBuffer = nativeIsBuffer || stubFalse;

	/**
	 * Performs a deep comparison between two values to determine if they are
	 * equivalent.
	 *
	 * **Note:** This method supports comparing arrays, array buffers, booleans,
	 * date objects, error objects, maps, numbers, `Object` objects, regexes,
	 * sets, strings, symbols, and typed arrays. `Object` objects are compared
	 * by their own, not inherited, enumerable properties. Functions and DOM
	 * nodes are compared by strict equality, i.e. `===`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 * var other = { 'a': 1 };
	 *
	 * _.isEqual(object, other);
	 * // => true
	 *
	 * object === other;
	 * // => false
	 */
	function isEqual(value, other) {
	  return baseIsEqual(value, other);
	}

	/**
	 * Checks if `value` is classified as a `Function` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
	 * @example
	 *
	 * _.isFunction(_);
	 * // => true
	 *
	 * _.isFunction(/abc/);
	 * // => false
	 */
	function isFunction(value) {
	  if (!isObject(value)) {
	    return false;
	  }
	  // The use of `Object#toString` avoids issues with the `typeof` operator
	  // in Safari 9 which returns 'object' for typed arrays and other constructors.
	  var tag = baseGetTag(value);
	  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
	}

	/**
	 * Checks if `value` is a valid array-like length.
	 *
	 * **Note:** This method is loosely based on
	 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	 * @example
	 *
	 * _.isLength(3);
	 * // => true
	 *
	 * _.isLength(Number.MIN_VALUE);
	 * // => false
	 *
	 * _.isLength(Infinity);
	 * // => false
	 *
	 * _.isLength('3');
	 * // => false
	 */
	function isLength(value) {
	  return typeof value == 'number' &&
	    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	}

	/**
	 * Checks if `value` is the
	 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
	 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(_.noop);
	 * // => true
	 *
	 * _.isObject(null);
	 * // => false
	 */
	function isObject(value) {
	  var type = typeof value;
	  return value != null && (type == 'object' || type == 'function');
	}

	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return value != null && typeof value == 'object';
	}

	/**
	 * Checks if `value` is classified as a typed array.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 * @example
	 *
	 * _.isTypedArray(new Uint8Array);
	 * // => true
	 *
	 * _.isTypedArray([]);
	 * // => false
	 */
	var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

	/**
	 * Creates an array of the own enumerable property names of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects. See the
	 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	 * for more details.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.keys(new Foo);
	 * // => ['a', 'b'] (iteration order is not guaranteed)
	 *
	 * _.keys('hi');
	 * // => ['0', '1']
	 */
	function keys(object) {
	  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
	}

	/**
	 * This method returns a new empty array.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.13.0
	 * @category Util
	 * @returns {Array} Returns the new empty array.
	 * @example
	 *
	 * var arrays = _.times(2, _.stubArray);
	 *
	 * console.log(arrays);
	 * // => [[], []]
	 *
	 * console.log(arrays[0] === arrays[1]);
	 * // => false
	 */
	function stubArray() {
	  return [];
	}

	/**
	 * This method returns `false`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.13.0
	 * @category Util
	 * @returns {boolean} Returns `false`.
	 * @example
	 *
	 * _.times(2, _.stubFalse);
	 * // => [false, false]
	 */
	function stubFalse() {
	  return false;
	}

	module.exports = isEqual;
	});

	/**
	 * lodash 3.0.3 (Custom Build) <https://lodash.com/>
	 * Build: `lodash modularize exports="npm" -o ./`
	 * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 * Available under MIT license <https://lodash.com/license>
	 */

	/** `Object#toString` result references. */
	var boolTag = '[object Boolean]';

	/** Used for built-in method references. */
	var objectProto$1 = Object.prototype;

	/**
	 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objectToString$1 = objectProto$1.toString;

	/**
	 * Checks if `value` is classified as a boolean primitive or object.
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	 * @example
	 *
	 * _.isBoolean(false);
	 * // => true
	 *
	 * _.isBoolean(null);
	 * // => false
	 */
	function isBoolean(value) {
	  return value === true || value === false ||
	    (isObjectLike(value) && objectToString$1.call(value) == boolTag);
	}

	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return !!value && typeof value == 'object';
	}

	var lodash_isboolean = isBoolean;

	/**
	 * lodash 4.0.0 (Custom Build) <https://lodash.com/>
	 * Build: `lodash modularize exports="npm" -o ./`
	 * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 * Available under MIT license <https://lodash.com/license>
	 */

	/**
	 * Checks if `value` is `null` or `undefined`.
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
	 * @example
	 *
	 * _.isNil(null);
	 * // => true
	 *
	 * _.isNil(void 0);
	 * // => true
	 *
	 * _.isNil(NaN);
	 * // => false
	 */
	function isNil(value) {
	  return value == null;
	}

	var lodash_isnil = isNil;

	/**
	 * lodash (Custom Build) <https://lodash.com/>
	 * Build: `lodash modularize exports="npm" -o ./`
	 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
	 * Released under MIT license <https://lodash.com/license>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 */

	/** Used as references for various `Number` constants. */
	var INFINITY = 1 / 0;

	/** `Object#toString` result references. */
	var symbolTag = '[object Symbol]';

	/**
	 * Used to match `RegExp`
	 * [syntax characters](http://ecma-international.org/ecma-262/6.0/#sec-patterns).
	 */
	var reRegExpChar = /[\\^$.*+?()[\]{}|]/g,
	    reHasRegExpChar = RegExp(reRegExpChar.source);

	/** Detect free variable `global` from Node.js. */
	var freeGlobal$1 = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

	/** Detect free variable `self`. */
	var freeSelf$1 = typeof self == 'object' && self && self.Object === Object && self;

	/** Used as a reference to the global object. */
	var root$1 = freeGlobal$1 || freeSelf$1 || Function('return this')();

	/** Used for built-in method references. */
	var objectProto$2 = Object.prototype;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objectToString$2 = objectProto$2.toString;

	/** Built-in value references. */
	var Symbol$3 = root$1.Symbol;

	/** Used to convert symbols to primitives and strings. */
	var symbolProto = Symbol$3 ? Symbol$3.prototype : undefined,
	    symbolToString = symbolProto ? symbolProto.toString : undefined;

	/**
	 * The base implementation of `_.toString` which doesn't convert nullish
	 * values to empty strings.
	 *
	 * @private
	 * @param {*} value The value to process.
	 * @returns {string} Returns the string.
	 */
	function baseToString(value) {
	  // Exit early for strings to avoid a performance hit in some environments.
	  if (typeof value == 'string') {
	    return value;
	  }
	  if (isSymbol$1(value)) {
	    return symbolToString ? symbolToString.call(value) : '';
	  }
	  var result = (value + '');
	  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
	}

	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike$1(value) {
	  return !!value && typeof value == 'object';
	}

	/**
	 * Checks if `value` is classified as a `Symbol` primitive or object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
	 * @example
	 *
	 * _.isSymbol(Symbol.iterator);
	 * // => true
	 *
	 * _.isSymbol('abc');
	 * // => false
	 */
	function isSymbol$1(value) {
	  return typeof value == 'symbol' ||
	    (isObjectLike$1(value) && objectToString$2.call(value) == symbolTag);
	}

	/**
	 * Converts `value` to a string. An empty string is returned for `null`
	 * and `undefined` values. The sign of `-0` is preserved.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to process.
	 * @returns {string} Returns the string.
	 * @example
	 *
	 * _.toString(null);
	 * // => ''
	 *
	 * _.toString(-0);
	 * // => '-0'
	 *
	 * _.toString([1, 2, 3]);
	 * // => '1,2,3'
	 */
	function toString$3(value) {
	  return value == null ? '' : baseToString(value);
	}

	/**
	 * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
	 * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category String
	 * @param {string} [string=''] The string to escape.
	 * @returns {string} Returns the escaped string.
	 * @example
	 *
	 * _.escapeRegExp('[lodash](https://lodash.com/)');
	 * // => '\[lodash\]\(https://lodash\.com/\)'
	 */
	function escapeRegExp(string) {
	  string = toString$3(string);
	  return (string && reHasRegExpChar.test(string))
	    ? string.replace(reRegExpChar, '\\$&')
	    : string;
	}

	var lodash_escaperegexp = escapeRegExp;

	var FieldFormatter_1 = createCommonjsModule(function (module, exports) {
	var __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.FieldFormatter = void 0;
	const lodash_isboolean_1 = __importDefault(lodash_isboolean);
	const lodash_isnil_1 = __importDefault(lodash_isnil);
	const lodash_escaperegexp_1 = __importDefault(lodash_escaperegexp);
	class FieldFormatter {
	    constructor(formatterOptions) {
	        this._headers = null;
	        this.formatterOptions = formatterOptions;
	        if (formatterOptions.headers !== null) {
	            this.headers = formatterOptions.headers;
	        }
	        this.REPLACE_REGEXP = new RegExp(formatterOptions.quote, 'g');
	        const escapePattern = `[${formatterOptions.delimiter}${lodash_escaperegexp_1.default(formatterOptions.rowDelimiter)}|\r|\n]`;
	        this.ESCAPE_REGEXP = new RegExp(escapePattern);
	    }
	    set headers(headers) {
	        this._headers = headers;
	    }
	    shouldQuote(fieldIndex, isHeader) {
	        const quoteConfig = isHeader ? this.formatterOptions.quoteHeaders : this.formatterOptions.quoteColumns;
	        if (lodash_isboolean_1.default(quoteConfig)) {
	            return quoteConfig;
	        }
	        if (Array.isArray(quoteConfig)) {
	            return quoteConfig[fieldIndex];
	        }
	        if (this._headers !== null) {
	            return quoteConfig[this._headers[fieldIndex]];
	        }
	        return false;
	    }
	    format(field, fieldIndex, isHeader) {
	        const preparedField = `${lodash_isnil_1.default(field) ? '' : field}`.replace(/\0/g, '');
	        const { formatterOptions } = this;
	        if (formatterOptions.quote !== '') {
	            const shouldEscape = preparedField.indexOf(formatterOptions.quote) !== -1;
	            if (shouldEscape) {
	                return this.quoteField(preparedField.replace(this.REPLACE_REGEXP, formatterOptions.escapedQuote));
	            }
	        }
	        const hasEscapeCharacters = preparedField.search(this.ESCAPE_REGEXP) !== -1;
	        if (hasEscapeCharacters || this.shouldQuote(fieldIndex, isHeader)) {
	            return this.quoteField(preparedField);
	        }
	        return preparedField;
	    }
	    quoteField(field) {
	        const { quote } = this.formatterOptions;
	        return `${quote}${field}${quote}`;
	    }
	}
	exports.FieldFormatter = FieldFormatter;

	});

	unwrapExports(FieldFormatter_1);
	var FieldFormatter_2 = FieldFormatter_1.FieldFormatter;

	var types = createCommonjsModule(function (module, exports) {
	/* eslint-disable @typescript-eslint/no-explicit-any */
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.isSyncTransform = void 0;
	exports.isSyncTransform = (transform) => transform.length === 1;

	});

	unwrapExports(types);
	var types_1 = types.isSyncTransform;

	var RowFormatter_1 = createCommonjsModule(function (module, exports) {
	var __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.RowFormatter = void 0;
	const lodash_isfunction_1 = __importDefault(lodash_isfunction);
	const lodash_isequal_1 = __importDefault(lodash_isequal);


	class RowFormatter {
	    constructor(formatterOptions) {
	        this.rowCount = 0;
	        this.formatterOptions = formatterOptions;
	        this.fieldFormatter = new FieldFormatter_1.FieldFormatter(formatterOptions);
	        this.headers = formatterOptions.headers;
	        this.shouldWriteHeaders = formatterOptions.shouldWriteHeaders;
	        this.hasWrittenHeaders = false;
	        if (this.headers !== null) {
	            this.fieldFormatter.headers = this.headers;
	        }
	        if (formatterOptions.transform) {
	            this.rowTransform = formatterOptions.transform;
	        }
	    }
	    static isRowHashArray(row) {
	        if (Array.isArray(row)) {
	            return Array.isArray(row[0]) && row[0].length === 2;
	        }
	        return false;
	    }
	    static isRowArray(row) {
	        return Array.isArray(row) && !this.isRowHashArray(row);
	    }
	    // get headers from a row item
	    static gatherHeaders(row) {
	        if (RowFormatter.isRowHashArray(row)) {
	            // lets assume a multi-dimesional array with item 0 being the header
	            return row.map((it) => it[0]);
	        }
	        if (Array.isArray(row)) {
	            return row;
	        }
	        return Object.keys(row);
	    }
	    // eslint-disable-next-line @typescript-eslint/no-shadow
	    static createTransform(transformFunction) {
	        if (types.isSyncTransform(transformFunction)) {
	            return (row, cb) => {
	                let transformedRow = null;
	                try {
	                    transformedRow = transformFunction(row);
	                }
	                catch (e) {
	                    return cb(e);
	                }
	                return cb(null, transformedRow);
	            };
	        }
	        return (row, cb) => {
	            transformFunction(row, cb);
	        };
	    }
	    set rowTransform(transformFunction) {
	        if (!lodash_isfunction_1.default(transformFunction)) {
	            throw new TypeError('The transform should be a function');
	        }
	        this._rowTransform = RowFormatter.createTransform(transformFunction);
	    }
	    format(row, cb) {
	        this.callTransformer(row, (err, transformedRow) => {
	            if (err) {
	                return cb(err);
	            }
	            if (!row) {
	                return cb(null);
	            }
	            const rows = [];
	            if (transformedRow) {
	                const { shouldFormatColumns, headers } = this.checkHeaders(transformedRow);
	                if (this.shouldWriteHeaders && headers && !this.hasWrittenHeaders) {
	                    rows.push(this.formatColumns(headers, true));
	                    this.hasWrittenHeaders = true;
	                }
	                if (shouldFormatColumns) {
	                    const columns = this.gatherColumns(transformedRow);
	                    rows.push(this.formatColumns(columns, false));
	                }
	            }
	            return cb(null, rows);
	        });
	    }
	    finish(cb) {
	        const rows = [];
	        // check if we should write headers and we didnt get any rows
	        if (this.formatterOptions.alwaysWriteHeaders && this.rowCount === 0) {
	            if (!this.headers) {
	                return cb(new Error('`alwaysWriteHeaders` option is set to true but `headers` option not provided.'));
	            }
	            rows.push(this.formatColumns(this.headers, true));
	        }
	        if (this.formatterOptions.includeEndRowDelimiter) {
	            rows.push(this.formatterOptions.rowDelimiter);
	        }
	        return cb(null, rows);
	    }
	    // check if we need to write header return true if we should also write a row
	    // could be false if headers is true and the header row(first item) is passed in
	    checkHeaders(row) {
	        if (this.headers) {
	            // either the headers were provided by the user or we have already gathered them.
	            return { shouldFormatColumns: true, headers: this.headers };
	        }
	        const headers = RowFormatter.gatherHeaders(row);
	        this.headers = headers;
	        this.fieldFormatter.headers = headers;
	        if (!this.shouldWriteHeaders) {
	            // if we are not supposed to write the headers then
	            // always format the columns
	            return { shouldFormatColumns: true, headers: null };
	        }
	        // if the row is equal to headers dont format
	        return { shouldFormatColumns: !lodash_isequal_1.default(headers, row), headers };
	    }
	    // todo change this method to unknown[]
	    gatherColumns(row) {
	        if (this.headers === null) {
	            throw new Error('Headers is currently null');
	        }
	        if (!Array.isArray(row)) {
	            return this.headers.map((header) => row[header]);
	        }
	        if (RowFormatter.isRowHashArray(row)) {
	            return this.headers.map((header, i) => {
	                const col = row[i];
	                if (col) {
	                    return col[1];
	                }
	                return '';
	            });
	        }
	        // if its a one dimensional array and headers were not provided
	        // then just return the row
	        if (RowFormatter.isRowArray(row) && !this.shouldWriteHeaders) {
	            return row;
	        }
	        return this.headers.map((header, i) => row[i]);
	    }
	    callTransformer(row, cb) {
	        if (!this._rowTransform) {
	            return cb(null, row);
	        }
	        return this._rowTransform(row, cb);
	    }
	    formatColumns(columns, isHeadersRow) {
	        const formattedCols = columns
	            .map((field, i) => this.fieldFormatter.format(field, i, isHeadersRow))
	            .join(this.formatterOptions.delimiter);
	        const { rowCount } = this;
	        this.rowCount += 1;
	        if (rowCount) {
	            return [this.formatterOptions.rowDelimiter, formattedCols].join('');
	        }
	        return formattedCols;
	    }
	}
	exports.RowFormatter = RowFormatter;

	});

	unwrapExports(RowFormatter_1);
	var RowFormatter_2 = RowFormatter_1.RowFormatter;

	var formatter = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.FieldFormatter = exports.RowFormatter = void 0;

	Object.defineProperty(exports, "RowFormatter", { enumerable: true, get: function () { return RowFormatter_1.RowFormatter; } });

	Object.defineProperty(exports, "FieldFormatter", { enumerable: true, get: function () { return FieldFormatter_1.FieldFormatter; } });

	});

	unwrapExports(formatter);
	var formatter_1 = formatter.FieldFormatter;
	var formatter_2 = formatter.RowFormatter;

	var CsvFormatterStream_1 = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.CsvFormatterStream = void 0;


	class CsvFormatterStream extends stream__default['default'].Transform {
	    constructor(formatterOptions) {
	        super({ writableObjectMode: formatterOptions.objectMode });
	        this.hasWrittenBOM = false;
	        this.formatterOptions = formatterOptions;
	        this.rowFormatter = new formatter.RowFormatter(formatterOptions);
	        // if writeBOM is false then set to true
	        // if writeBOM is true then set to false by default so it is written out
	        this.hasWrittenBOM = !formatterOptions.writeBOM;
	    }
	    transform(transformFunction) {
	        this.rowFormatter.rowTransform = transformFunction;
	        return this;
	    }
	    _transform(row, encoding, cb) {
	        let cbCalled = false;
	        try {
	            if (!this.hasWrittenBOM) {
	                this.push(this.formatterOptions.BOM);
	                this.hasWrittenBOM = true;
	            }
	            this.rowFormatter.format(row, (err, rows) => {
	                if (err) {
	                    cbCalled = true;
	                    return cb(err);
	                }
	                if (rows) {
	                    rows.forEach((r) => {
	                        this.push(Buffer.from(r, 'utf8'));
	                    });
	                }
	                cbCalled = true;
	                return cb();
	            });
	        }
	        catch (e) {
	            if (cbCalled) {
	                throw e;
	            }
	            cb(e);
	        }
	    }
	    _flush(cb) {
	        this.rowFormatter.finish((err, rows) => {
	            if (err) {
	                return cb(err);
	            }
	            if (rows) {
	                rows.forEach((r) => {
	                    this.push(Buffer.from(r, 'utf8'));
	                });
	            }
	            return cb();
	        });
	    }
	}
	exports.CsvFormatterStream = CsvFormatterStream;

	});

	unwrapExports(CsvFormatterStream_1);
	var CsvFormatterStream_2 = CsvFormatterStream_1.CsvFormatterStream;

	var src = createCommonjsModule(function (module, exports) {
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
	    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.writeToPath = exports.writeToString = exports.writeToBuffer = exports.writeToStream = exports.write = exports.format = exports.FormatterOptions = exports.CsvFormatterStream = void 0;


	const fs = __importStar(fs__default['default']);


	__exportStar(types, exports);
	var CsvFormatterStream_2 = CsvFormatterStream_1;
	Object.defineProperty(exports, "CsvFormatterStream", { enumerable: true, get: function () { return CsvFormatterStream_2.CsvFormatterStream; } });
	var FormatterOptions_2 = FormatterOptions_1;
	Object.defineProperty(exports, "FormatterOptions", { enumerable: true, get: function () { return FormatterOptions_2.FormatterOptions; } });
	exports.format = (options) => new CsvFormatterStream_1.CsvFormatterStream(new FormatterOptions_1.FormatterOptions(options));
	exports.write = (rows, options) => {
	    const csvStream = exports.format(options);
	    const promiseWrite = util__default['default'].promisify((row, cb) => {
	        csvStream.write(row, undefined, cb);
	    });
	    rows.reduce((prev, row) => prev.then(() => promiseWrite(row)), Promise.resolve())
	        .then(() => csvStream.end())
	        .catch((err) => {
	        csvStream.emit('error', err);
	    });
	    return csvStream;
	};
	exports.writeToStream = (ws, rows, options) => exports.write(rows, options).pipe(ws);
	exports.writeToBuffer = (rows, opts = {}) => {
	    const buffers = [];
	    const ws = new stream__default['default'].Writable({
	        write(data, enc, writeCb) {
	            buffers.push(data);
	            writeCb();
	        },
	    });
	    return new Promise((res, rej) => {
	        ws.on('error', rej).on('finish', () => res(Buffer.concat(buffers)));
	        exports.write(rows, opts).pipe(ws);
	    });
	};
	exports.writeToString = (rows, options) => exports.writeToBuffer(rows, options).then((buffer) => buffer.toString());
	exports.writeToPath = (path, rows, options) => {
	    const stream = fs.createWriteStream(path, { encoding: 'utf8' });
	    return exports.write(rows, options).pipe(stream);
	};

	});

	unwrapExports(src);
	var src_1 = src.writeToPath;
	var src_2 = src.writeToString;
	var src_3 = src.writeToBuffer;
	var src_4 = src.writeToStream;
	var src_5 = src.write;
	var src_6 = src.format;
	var src_7 = src.FormatterOptions;
	var src_8 = src.CsvFormatterStream;

	var ParserOptions_1 = createCommonjsModule(function (module, exports) {
	var __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.ParserOptions = void 0;
	const lodash_escaperegexp_1 = __importDefault(lodash_escaperegexp);
	const lodash_isnil_1 = __importDefault(lodash_isnil);
	class ParserOptions {
	    constructor(opts) {
	        var _a;
	        this.objectMode = true;
	        this.delimiter = ',';
	        this.ignoreEmpty = false;
	        this.quote = '"';
	        this.escape = null;
	        this.escapeChar = this.quote;
	        this.comment = null;
	        this.supportsComments = false;
	        this.ltrim = false;
	        this.rtrim = false;
	        this.trim = false;
	        this.headers = null;
	        this.renameHeaders = false;
	        this.strictColumnHandling = false;
	        this.discardUnmappedColumns = false;
	        this.carriageReturn = '\r';
	        this.encoding = 'utf8';
	        this.limitRows = false;
	        this.maxRows = 0;
	        this.skipLines = 0;
	        this.skipRows = 0;
	        Object.assign(this, opts || {});
	        if (this.delimiter.length > 1) {
	            throw new Error('delimiter option must be one character long');
	        }
	        this.escapedDelimiter = lodash_escaperegexp_1.default(this.delimiter);
	        this.escapeChar = (_a = this.escape) !== null && _a !== void 0 ? _a : this.quote;
	        this.supportsComments = !lodash_isnil_1.default(this.comment);
	        this.NEXT_TOKEN_REGEXP = new RegExp(`([^\\s]|\\r\\n|\\n|\\r|${this.escapedDelimiter})`);
	        if (this.maxRows > 0) {
	            this.limitRows = true;
	        }
	    }
	}
	exports.ParserOptions = ParserOptions;

	});

	unwrapExports(ParserOptions_1);
	var ParserOptions_2 = ParserOptions_1.ParserOptions;

	var types$1 = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.isSyncValidate = exports.isSyncTransform = void 0;
	exports.isSyncTransform = (transform) => transform.length === 1;
	exports.isSyncValidate = (validate) => validate.length === 1;

	});

	unwrapExports(types$1);
	var types_1$1 = types$1.isSyncValidate;
	var types_2 = types$1.isSyncTransform;

	var RowTransformerValidator_1 = createCommonjsModule(function (module, exports) {
	var __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.RowTransformerValidator = void 0;
	const lodash_isfunction_1 = __importDefault(lodash_isfunction);

	class RowTransformerValidator {
	    constructor() {
	        this._rowTransform = null;
	        this._rowValidator = null;
	    }
	    // eslint-disable-next-line @typescript-eslint/no-shadow
	    static createTransform(transformFunction) {
	        if (types$1.isSyncTransform(transformFunction)) {
	            return (row, cb) => {
	                let transformed = null;
	                try {
	                    transformed = transformFunction(row);
	                }
	                catch (e) {
	                    return cb(e);
	                }
	                return cb(null, transformed);
	            };
	        }
	        return transformFunction;
	    }
	    static createValidator(validateFunction) {
	        if (types$1.isSyncValidate(validateFunction)) {
	            return (row, cb) => {
	                cb(null, { row, isValid: validateFunction(row) });
	            };
	        }
	        return (row, cb) => {
	            validateFunction(row, (err, isValid, reason) => {
	                if (err) {
	                    return cb(err);
	                }
	                if (isValid) {
	                    return cb(null, { row, isValid, reason });
	                }
	                return cb(null, { row, isValid: false, reason });
	            });
	        };
	    }
	    set rowTransform(transformFunction) {
	        if (!lodash_isfunction_1.default(transformFunction)) {
	            throw new TypeError('The transform should be a function');
	        }
	        this._rowTransform = RowTransformerValidator.createTransform(transformFunction);
	    }
	    set rowValidator(validateFunction) {
	        if (!lodash_isfunction_1.default(validateFunction)) {
	            throw new TypeError('The validate should be a function');
	        }
	        this._rowValidator = RowTransformerValidator.createValidator(validateFunction);
	    }
	    transformAndValidate(row, cb) {
	        return this.callTransformer(row, (transformErr, transformedRow) => {
	            if (transformErr) {
	                return cb(transformErr);
	            }
	            if (!transformedRow) {
	                return cb(null, { row: null, isValid: true });
	            }
	            return this.callValidator(transformedRow, (validateErr, validationResult) => {
	                if (validateErr) {
	                    return cb(validateErr);
	                }
	                if (validationResult && !validationResult.isValid) {
	                    return cb(null, { row: transformedRow, isValid: false, reason: validationResult.reason });
	                }
	                return cb(null, { row: transformedRow, isValid: true });
	            });
	        });
	    }
	    callTransformer(row, cb) {
	        if (!this._rowTransform) {
	            return cb(null, row);
	        }
	        return this._rowTransform(row, cb);
	    }
	    callValidator(row, cb) {
	        if (!this._rowValidator) {
	            return cb(null, { row, isValid: true });
	        }
	        return this._rowValidator(row, cb);
	    }
	}
	exports.RowTransformerValidator = RowTransformerValidator;

	});

	unwrapExports(RowTransformerValidator_1);
	var RowTransformerValidator_2 = RowTransformerValidator_1.RowTransformerValidator;

	/**
	 * lodash 3.0.1 (Custom Build) <https://lodash.com/>
	 * Build: `lodash modern modularize exports="npm" -o ./`
	 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 * Available under MIT license <https://lodash.com/license>
	 */

	/**
	 * Checks if `value` is `undefined`.
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
	 * @example
	 *
	 * _.isUndefined(void 0);
	 * // => true
	 *
	 * _.isUndefined(null);
	 * // => false
	 */
	function isUndefined(value) {
	  return value === undefined;
	}

	var lodash_isundefined = isUndefined;

	/**
	 * lodash (Custom Build) <https://lodash.com/>
	 * Build: `lodash modularize exports="npm" -o ./`
	 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
	 * Released under MIT license <https://lodash.com/license>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 */

	/** Used as the size to enable large array optimizations. */
	var LARGE_ARRAY_SIZE = 200;

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED = '__lodash_hash_undefined__';

	/** Used as references for various `Number` constants. */
	var INFINITY$1 = 1 / 0;

	/** `Object#toString` result references. */
	var funcTag$1 = '[object Function]',
	    genTag$1 = '[object GeneratorFunction]';

	/**
	 * Used to match `RegExp`
	 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
	 */
	var reRegExpChar$1 = /[\\^$.*+?()[\]{}|]/g;

	/** Used to detect host constructors (Safari). */
	var reIsHostCtor = /^\[object .+?Constructor\]$/;

	/** Detect free variable `global` from Node.js. */
	var freeGlobal$2 = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

	/** Detect free variable `self`. */
	var freeSelf$2 = typeof self == 'object' && self && self.Object === Object && self;

	/** Used as a reference to the global object. */
	var root$2 = freeGlobal$2 || freeSelf$2 || Function('return this')();

	/**
	 * A specialized version of `_.includes` for arrays without support for
	 * specifying an index to search from.
	 *
	 * @private
	 * @param {Array} [array] The array to inspect.
	 * @param {*} target The value to search for.
	 * @returns {boolean} Returns `true` if `target` is found, else `false`.
	 */
	function arrayIncludes$1(array, value) {
	  var length = array ? array.length : 0;
	  return !!length && baseIndexOf(array, value, 0) > -1;
	}

	/**
	 * This function is like `arrayIncludes` except that it accepts a comparator.
	 *
	 * @private
	 * @param {Array} [array] The array to inspect.
	 * @param {*} target The value to search for.
	 * @param {Function} comparator The comparator invoked per element.
	 * @returns {boolean} Returns `true` if `target` is found, else `false`.
	 */
	function arrayIncludesWith(array, value, comparator) {
	  var index = -1,
	      length = array ? array.length : 0;

	  while (++index < length) {
	    if (comparator(value, array[index])) {
	      return true;
	    }
	  }
	  return false;
	}

	/**
	 * The base implementation of `_.findIndex` and `_.findLastIndex` without
	 * support for iteratee shorthands.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {Function} predicate The function invoked per iteration.
	 * @param {number} fromIndex The index to search from.
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function baseFindIndex(array, predicate, fromIndex, fromRight) {
	  var length = array.length,
	      index = fromIndex + (fromRight ? 1 : -1);

	  while ((fromRight ? index-- : ++index < length)) {
	    if (predicate(array[index], index, array)) {
	      return index;
	    }
	  }
	  return -1;
	}

	/**
	 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} value The value to search for.
	 * @param {number} fromIndex The index to search from.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function baseIndexOf(array, value, fromIndex) {
	  if (value !== value) {
	    return baseFindIndex(array, baseIsNaN, fromIndex);
	  }
	  var index = fromIndex - 1,
	      length = array.length;

	  while (++index < length) {
	    if (array[index] === value) {
	      return index;
	    }
	  }
	  return -1;
	}

	/**
	 * The base implementation of `_.isNaN` without support for number objects.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
	 */
	function baseIsNaN(value) {
	  return value !== value;
	}

	/**
	 * Checks if a cache value for `key` exists.
	 *
	 * @private
	 * @param {Object} cache The cache to query.
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function cacheHas(cache, key) {
	  return cache.has(key);
	}

	/**
	 * Gets the value at `key` of `object`.
	 *
	 * @private
	 * @param {Object} [object] The object to query.
	 * @param {string} key The key of the property to get.
	 * @returns {*} Returns the property value.
	 */
	function getValue(object, key) {
	  return object == null ? undefined : object[key];
	}

	/**
	 * Checks if `value` is a host object in IE < 9.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
	 */
	function isHostObject(value) {
	  // Many host objects are `Object` objects that can coerce to strings
	  // despite having improperly defined `toString` methods.
	  var result = false;
	  if (value != null && typeof value.toString != 'function') {
	    try {
	      result = !!(value + '');
	    } catch (e) {}
	  }
	  return result;
	}

	/**
	 * Converts `set` to an array of its values.
	 *
	 * @private
	 * @param {Object} set The set to convert.
	 * @returns {Array} Returns the values.
	 */
	function setToArray(set) {
	  var index = -1,
	      result = Array(set.size);

	  set.forEach(function(value) {
	    result[++index] = value;
	  });
	  return result;
	}

	/** Used for built-in method references. */
	var arrayProto = Array.prototype,
	    funcProto = Function.prototype,
	    objectProto$3 = Object.prototype;

	/** Used to detect overreaching core-js shims. */
	var coreJsData = root$2['__core-js_shared__'];

	/** Used to detect methods masquerading as native. */
	var maskSrcKey = (function() {
	  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
	  return uid ? ('Symbol(src)_1.' + uid) : '';
	}());

	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;

	/** Used to check objects for own properties. */
	var hasOwnProperty$2 = objectProto$3.hasOwnProperty;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objectToString$3 = objectProto$3.toString;

	/** Used to detect if a method is native. */
	var reIsNative = RegExp('^' +
	  funcToString.call(hasOwnProperty$2).replace(reRegExpChar$1, '\\$&')
	  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
	);

	/** Built-in value references. */
	var splice = arrayProto.splice;

	/* Built-in method references that are verified to be native. */
	var Map = getNative(root$2, 'Map'),
	    Set$1 = getNative(root$2, 'Set'),
	    nativeCreate = getNative(Object, 'create');

	/**
	 * Creates a hash object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Hash(entries) {
	  var index = -1,
	      length = entries ? entries.length : 0;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	/**
	 * Removes all key-value entries from the hash.
	 *
	 * @private
	 * @name clear
	 * @memberOf Hash
	 */
	function hashClear() {
	  this.__data__ = nativeCreate ? nativeCreate(null) : {};
	}

	/**
	 * Removes `key` and its value from the hash.
	 *
	 * @private
	 * @name delete
	 * @memberOf Hash
	 * @param {Object} hash The hash to modify.
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function hashDelete(key) {
	  return this.has(key) && delete this.__data__[key];
	}

	/**
	 * Gets the hash value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Hash
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function hashGet(key) {
	  var data = this.__data__;
	  if (nativeCreate) {
	    var result = data[key];
	    return result === HASH_UNDEFINED ? undefined : result;
	  }
	  return hasOwnProperty$2.call(data, key) ? data[key] : undefined;
	}

	/**
	 * Checks if a hash value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Hash
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function hashHas(key) {
	  var data = this.__data__;
	  return nativeCreate ? data[key] !== undefined : hasOwnProperty$2.call(data, key);
	}

	/**
	 * Sets the hash `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Hash
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the hash instance.
	 */
	function hashSet(key, value) {
	  var data = this.__data__;
	  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
	  return this;
	}

	// Add methods to `Hash`.
	Hash.prototype.clear = hashClear;
	Hash.prototype['delete'] = hashDelete;
	Hash.prototype.get = hashGet;
	Hash.prototype.has = hashHas;
	Hash.prototype.set = hashSet;

	/**
	 * Creates an list cache object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function ListCache(entries) {
	  var index = -1,
	      length = entries ? entries.length : 0;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	/**
	 * Removes all key-value entries from the list cache.
	 *
	 * @private
	 * @name clear
	 * @memberOf ListCache
	 */
	function listCacheClear() {
	  this.__data__ = [];
	}

	/**
	 * Removes `key` and its value from the list cache.
	 *
	 * @private
	 * @name delete
	 * @memberOf ListCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function listCacheDelete(key) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);

	  if (index < 0) {
	    return false;
	  }
	  var lastIndex = data.length - 1;
	  if (index == lastIndex) {
	    data.pop();
	  } else {
	    splice.call(data, index, 1);
	  }
	  return true;
	}

	/**
	 * Gets the list cache value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf ListCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function listCacheGet(key) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);

	  return index < 0 ? undefined : data[index][1];
	}

	/**
	 * Checks if a list cache value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf ListCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function listCacheHas(key) {
	  return assocIndexOf(this.__data__, key) > -1;
	}

	/**
	 * Sets the list cache `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf ListCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the list cache instance.
	 */
	function listCacheSet(key, value) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);

	  if (index < 0) {
	    data.push([key, value]);
	  } else {
	    data[index][1] = value;
	  }
	  return this;
	}

	// Add methods to `ListCache`.
	ListCache.prototype.clear = listCacheClear;
	ListCache.prototype['delete'] = listCacheDelete;
	ListCache.prototype.get = listCacheGet;
	ListCache.prototype.has = listCacheHas;
	ListCache.prototype.set = listCacheSet;

	/**
	 * Creates a map cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function MapCache(entries) {
	  var index = -1,
	      length = entries ? entries.length : 0;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	/**
	 * Removes all key-value entries from the map.
	 *
	 * @private
	 * @name clear
	 * @memberOf MapCache
	 */
	function mapCacheClear() {
	  this.__data__ = {
	    'hash': new Hash,
	    'map': new (Map || ListCache),
	    'string': new Hash
	  };
	}

	/**
	 * Removes `key` and its value from the map.
	 *
	 * @private
	 * @name delete
	 * @memberOf MapCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function mapCacheDelete(key) {
	  return getMapData(this, key)['delete'](key);
	}

	/**
	 * Gets the map value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf MapCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function mapCacheGet(key) {
	  return getMapData(this, key).get(key);
	}

	/**
	 * Checks if a map value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf MapCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function mapCacheHas(key) {
	  return getMapData(this, key).has(key);
	}

	/**
	 * Sets the map `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf MapCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the map cache instance.
	 */
	function mapCacheSet(key, value) {
	  getMapData(this, key).set(key, value);
	  return this;
	}

	// Add methods to `MapCache`.
	MapCache.prototype.clear = mapCacheClear;
	MapCache.prototype['delete'] = mapCacheDelete;
	MapCache.prototype.get = mapCacheGet;
	MapCache.prototype.has = mapCacheHas;
	MapCache.prototype.set = mapCacheSet;

	/**
	 *
	 * Creates an array cache object to store unique values.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [values] The values to cache.
	 */
	function SetCache(values) {
	  var index = -1,
	      length = values ? values.length : 0;

	  this.__data__ = new MapCache;
	  while (++index < length) {
	    this.add(values[index]);
	  }
	}

	/**
	 * Adds `value` to the array cache.
	 *
	 * @private
	 * @name add
	 * @memberOf SetCache
	 * @alias push
	 * @param {*} value The value to cache.
	 * @returns {Object} Returns the cache instance.
	 */
	function setCacheAdd(value) {
	  this.__data__.set(value, HASH_UNDEFINED);
	  return this;
	}

	/**
	 * Checks if `value` is in the array cache.
	 *
	 * @private
	 * @name has
	 * @memberOf SetCache
	 * @param {*} value The value to search for.
	 * @returns {number} Returns `true` if `value` is found, else `false`.
	 */
	function setCacheHas(value) {
	  return this.__data__.has(value);
	}

	// Add methods to `SetCache`.
	SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
	SetCache.prototype.has = setCacheHas;

	/**
	 * Gets the index at which the `key` is found in `array` of key-value pairs.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} key The key to search for.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function assocIndexOf(array, key) {
	  var length = array.length;
	  while (length--) {
	    if (eq(array[length][0], key)) {
	      return length;
	    }
	  }
	  return -1;
	}

	/**
	 * The base implementation of `_.isNative` without bad shim checks.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a native function,
	 *  else `false`.
	 */
	function baseIsNative(value) {
	  if (!isObject$2(value) || isMasked(value)) {
	    return false;
	  }
	  var pattern = (isFunction$1(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;
	  return pattern.test(toSource(value));
	}

	/**
	 * The base implementation of `_.uniqBy` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {Function} [iteratee] The iteratee invoked per element.
	 * @param {Function} [comparator] The comparator invoked per element.
	 * @returns {Array} Returns the new duplicate free array.
	 */
	function baseUniq(array, iteratee, comparator) {
	  var index = -1,
	      includes = arrayIncludes$1,
	      length = array.length,
	      isCommon = true,
	      result = [],
	      seen = result;

	  if (comparator) {
	    isCommon = false;
	    includes = arrayIncludesWith;
	  }
	  else if (length >= LARGE_ARRAY_SIZE) {
	    var set = iteratee ? null : createSet(array);
	    if (set) {
	      return setToArray(set);
	    }
	    isCommon = false;
	    includes = cacheHas;
	    seen = new SetCache;
	  }
	  else {
	    seen = iteratee ? [] : result;
	  }
	  outer:
	  while (++index < length) {
	    var value = array[index],
	        computed = iteratee ? iteratee(value) : value;

	    value = (comparator || value !== 0) ? value : 0;
	    if (isCommon && computed === computed) {
	      var seenIndex = seen.length;
	      while (seenIndex--) {
	        if (seen[seenIndex] === computed) {
	          continue outer;
	        }
	      }
	      if (iteratee) {
	        seen.push(computed);
	      }
	      result.push(value);
	    }
	    else if (!includes(seen, computed, comparator)) {
	      if (seen !== result) {
	        seen.push(computed);
	      }
	      result.push(value);
	    }
	  }
	  return result;
	}

	/**
	 * Creates a set object of `values`.
	 *
	 * @private
	 * @param {Array} values The values to add to the set.
	 * @returns {Object} Returns the new set.
	 */
	var createSet = !(Set$1 && (1 / setToArray(new Set$1([,-0]))[1]) == INFINITY$1) ? noop$2 : function(values) {
	  return new Set$1(values);
	};

	/**
	 * Gets the data for `map`.
	 *
	 * @private
	 * @param {Object} map The map to query.
	 * @param {string} key The reference key.
	 * @returns {*} Returns the map data.
	 */
	function getMapData(map, key) {
	  var data = map.__data__;
	  return isKeyable(key)
	    ? data[typeof key == 'string' ? 'string' : 'hash']
	    : data.map;
	}

	/**
	 * Gets the native function at `key` of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {string} key The key of the method to get.
	 * @returns {*} Returns the function if it's native, else `undefined`.
	 */
	function getNative(object, key) {
	  var value = getValue(object, key);
	  return baseIsNative(value) ? value : undefined;
	}

	/**
	 * Checks if `value` is suitable for use as unique object key.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
	 */
	function isKeyable(value) {
	  var type = typeof value;
	  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
	    ? (value !== '__proto__')
	    : (value === null);
	}

	/**
	 * Checks if `func` has its source masked.
	 *
	 * @private
	 * @param {Function} func The function to check.
	 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
	 */
	function isMasked(func) {
	  return !!maskSrcKey && (maskSrcKey in func);
	}

	/**
	 * Converts `func` to its source code.
	 *
	 * @private
	 * @param {Function} func The function to process.
	 * @returns {string} Returns the source code.
	 */
	function toSource(func) {
	  if (func != null) {
	    try {
	      return funcToString.call(func);
	    } catch (e) {}
	    try {
	      return (func + '');
	    } catch (e) {}
	  }
	  return '';
	}

	/**
	 * Creates a duplicate-free version of an array, using
	 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * for equality comparisons, in which only the first occurrence of each
	 * element is kept.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Array
	 * @param {Array} array The array to inspect.
	 * @returns {Array} Returns the new duplicate free array.
	 * @example
	 *
	 * _.uniq([2, 1, 2]);
	 * // => [2, 1]
	 */
	function uniq(array) {
	  return (array && array.length)
	    ? baseUniq(array)
	    : [];
	}

	/**
	 * Performs a
	 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * comparison between two values to determine if they are equivalent.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 * var other = { 'a': 1 };
	 *
	 * _.eq(object, object);
	 * // => true
	 *
	 * _.eq(object, other);
	 * // => false
	 *
	 * _.eq('a', 'a');
	 * // => true
	 *
	 * _.eq('a', Object('a'));
	 * // => false
	 *
	 * _.eq(NaN, NaN);
	 * // => true
	 */
	function eq(value, other) {
	  return value === other || (value !== value && other !== other);
	}

	/**
	 * Checks if `value` is classified as a `Function` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
	 * @example
	 *
	 * _.isFunction(_);
	 * // => true
	 *
	 * _.isFunction(/abc/);
	 * // => false
	 */
	function isFunction$1(value) {
	  // The use of `Object#toString` avoids issues with the `typeof` operator
	  // in Safari 8-9 which returns 'object' for typed array and other constructors.
	  var tag = isObject$2(value) ? objectToString$3.call(value) : '';
	  return tag == funcTag$1 || tag == genTag$1;
	}

	/**
	 * Checks if `value` is the
	 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
	 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(_.noop);
	 * // => true
	 *
	 * _.isObject(null);
	 * // => false
	 */
	function isObject$2(value) {
	  var type = typeof value;
	  return !!value && (type == 'object' || type == 'function');
	}

	/**
	 * This method returns `undefined`.
	 *
	 * @static
	 * @memberOf _
	 * @since 2.3.0
	 * @category Util
	 * @example
	 *
	 * _.times(2, _.noop);
	 * // => [undefined, undefined]
	 */
	function noop$2() {
	  // No operation performed.
	}

	var lodash_uniq = uniq;

	var lodash_groupby = createCommonjsModule(function (module, exports) {
	/**
	 * lodash (Custom Build) <https://lodash.com/>
	 * Build: `lodash modularize exports="npm" -o ./`
	 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
	 * Released under MIT license <https://lodash.com/license>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 */

	/** Used as the size to enable large array optimizations. */
	var LARGE_ARRAY_SIZE = 200;

	/** Used as the `TypeError` message for "Functions" methods. */
	var FUNC_ERROR_TEXT = 'Expected a function';

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED = '__lodash_hash_undefined__';

	/** Used to compose bitmasks for comparison styles. */
	var UNORDERED_COMPARE_FLAG = 1,
	    PARTIAL_COMPARE_FLAG = 2;

	/** Used as references for various `Number` constants. */
	var INFINITY = 1 / 0,
	    MAX_SAFE_INTEGER = 9007199254740991;

	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]',
	    arrayTag = '[object Array]',
	    boolTag = '[object Boolean]',
	    dateTag = '[object Date]',
	    errorTag = '[object Error]',
	    funcTag = '[object Function]',
	    genTag = '[object GeneratorFunction]',
	    mapTag = '[object Map]',
	    numberTag = '[object Number]',
	    objectTag = '[object Object]',
	    promiseTag = '[object Promise]',
	    regexpTag = '[object RegExp]',
	    setTag = '[object Set]',
	    stringTag = '[object String]',
	    symbolTag = '[object Symbol]',
	    weakMapTag = '[object WeakMap]';

	var arrayBufferTag = '[object ArrayBuffer]',
	    dataViewTag = '[object DataView]',
	    float32Tag = '[object Float32Array]',
	    float64Tag = '[object Float64Array]',
	    int8Tag = '[object Int8Array]',
	    int16Tag = '[object Int16Array]',
	    int32Tag = '[object Int32Array]',
	    uint8Tag = '[object Uint8Array]',
	    uint8ClampedTag = '[object Uint8ClampedArray]',
	    uint16Tag = '[object Uint16Array]',
	    uint32Tag = '[object Uint32Array]';

	/** Used to match property names within property paths. */
	var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
	    reIsPlainProp = /^\w*$/,
	    reLeadingDot = /^\./,
	    rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

	/**
	 * Used to match `RegExp`
	 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
	 */
	var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

	/** Used to match backslashes in property paths. */
	var reEscapeChar = /\\(\\)?/g;

	/** Used to detect host constructors (Safari). */
	var reIsHostCtor = /^\[object .+?Constructor\]$/;

	/** Used to detect unsigned integer values. */
	var reIsUint = /^(?:0|[1-9]\d*)$/;

	/** Used to identify `toStringTag` values of typed arrays. */
	var typedArrayTags = {};
	typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
	typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
	typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
	typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
	typedArrayTags[uint32Tag] = true;
	typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
	typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
	typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
	typedArrayTags[errorTag] = typedArrayTags[funcTag] =
	typedArrayTags[mapTag] = typedArrayTags[numberTag] =
	typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
	typedArrayTags[setTag] = typedArrayTags[stringTag] =
	typedArrayTags[weakMapTag] = false;

	/** Detect free variable `global` from Node.js. */
	var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

	/** Detect free variable `self`. */
	var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

	/** Used as a reference to the global object. */
	var root = freeGlobal || freeSelf || Function('return this')();

	/** Detect free variable `exports`. */
	var freeExports =  exports && !exports.nodeType && exports;

	/** Detect free variable `module`. */
	var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

	/** Detect the popular CommonJS extension `module.exports`. */
	var moduleExports = freeModule && freeModule.exports === freeExports;

	/** Detect free variable `process` from Node.js. */
	var freeProcess = moduleExports && freeGlobal.process;

	/** Used to access faster Node.js helpers. */
	var nodeUtil = (function() {
	  try {
	    return freeProcess && freeProcess.binding('util');
	  } catch (e) {}
	}());

	/* Node.js helper references. */
	var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

	/**
	 * A specialized version of `baseAggregator` for arrays.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} setter The function to set `accumulator` values.
	 * @param {Function} iteratee The iteratee to transform keys.
	 * @param {Object} accumulator The initial aggregated object.
	 * @returns {Function} Returns `accumulator`.
	 */
	function arrayAggregator(array, setter, iteratee, accumulator) {
	  var index = -1,
	      length = array ? array.length : 0;

	  while (++index < length) {
	    var value = array[index];
	    setter(accumulator, value, iteratee(value), array);
	  }
	  return accumulator;
	}

	/**
	 * A specialized version of `_.some` for arrays without support for iteratee
	 * shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} predicate The function invoked per iteration.
	 * @returns {boolean} Returns `true` if any element passes the predicate check,
	 *  else `false`.
	 */
	function arraySome(array, predicate) {
	  var index = -1,
	      length = array ? array.length : 0;

	  while (++index < length) {
	    if (predicate(array[index], index, array)) {
	      return true;
	    }
	  }
	  return false;
	}

	/**
	 * The base implementation of `_.property` without support for deep paths.
	 *
	 * @private
	 * @param {string} key The key of the property to get.
	 * @returns {Function} Returns the new accessor function.
	 */
	function baseProperty(key) {
	  return function(object) {
	    return object == null ? undefined : object[key];
	  };
	}

	/**
	 * The base implementation of `_.times` without support for iteratee shorthands
	 * or max array length checks.
	 *
	 * @private
	 * @param {number} n The number of times to invoke `iteratee`.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the array of results.
	 */
	function baseTimes(n, iteratee) {
	  var index = -1,
	      result = Array(n);

	  while (++index < n) {
	    result[index] = iteratee(index);
	  }
	  return result;
	}

	/**
	 * The base implementation of `_.unary` without support for storing metadata.
	 *
	 * @private
	 * @param {Function} func The function to cap arguments for.
	 * @returns {Function} Returns the new capped function.
	 */
	function baseUnary(func) {
	  return function(value) {
	    return func(value);
	  };
	}

	/**
	 * Gets the value at `key` of `object`.
	 *
	 * @private
	 * @param {Object} [object] The object to query.
	 * @param {string} key The key of the property to get.
	 * @returns {*} Returns the property value.
	 */
	function getValue(object, key) {
	  return object == null ? undefined : object[key];
	}

	/**
	 * Checks if `value` is a host object in IE < 9.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
	 */
	function isHostObject(value) {
	  // Many host objects are `Object` objects that can coerce to strings
	  // despite having improperly defined `toString` methods.
	  var result = false;
	  if (value != null && typeof value.toString != 'function') {
	    try {
	      result = !!(value + '');
	    } catch (e) {}
	  }
	  return result;
	}

	/**
	 * Converts `map` to its key-value pairs.
	 *
	 * @private
	 * @param {Object} map The map to convert.
	 * @returns {Array} Returns the key-value pairs.
	 */
	function mapToArray(map) {
	  var index = -1,
	      result = Array(map.size);

	  map.forEach(function(value, key) {
	    result[++index] = [key, value];
	  });
	  return result;
	}

	/**
	 * Creates a unary function that invokes `func` with its argument transformed.
	 *
	 * @private
	 * @param {Function} func The function to wrap.
	 * @param {Function} transform The argument transform.
	 * @returns {Function} Returns the new function.
	 */
	function overArg(func, transform) {
	  return function(arg) {
	    return func(transform(arg));
	  };
	}

	/**
	 * Converts `set` to an array of its values.
	 *
	 * @private
	 * @param {Object} set The set to convert.
	 * @returns {Array} Returns the values.
	 */
	function setToArray(set) {
	  var index = -1,
	      result = Array(set.size);

	  set.forEach(function(value) {
	    result[++index] = value;
	  });
	  return result;
	}

	/** Used for built-in method references. */
	var arrayProto = Array.prototype,
	    funcProto = Function.prototype,
	    objectProto = Object.prototype;

	/** Used to detect overreaching core-js shims. */
	var coreJsData = root['__core-js_shared__'];

	/** Used to detect methods masquerading as native. */
	var maskSrcKey = (function() {
	  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
	  return uid ? ('Symbol(src)_1.' + uid) : '';
	}());

	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objectToString = objectProto.toString;

	/** Used to detect if a method is native. */
	var reIsNative = RegExp('^' +
	  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
	  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
	);

	/** Built-in value references. */
	var Symbol = root.Symbol,
	    Uint8Array = root.Uint8Array,
	    propertyIsEnumerable = objectProto.propertyIsEnumerable,
	    splice = arrayProto.splice;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeKeys = overArg(Object.keys, Object);

	/* Built-in method references that are verified to be native. */
	var DataView = getNative(root, 'DataView'),
	    Map = getNative(root, 'Map'),
	    Promise = getNative(root, 'Promise'),
	    Set = getNative(root, 'Set'),
	    WeakMap = getNative(root, 'WeakMap'),
	    nativeCreate = getNative(Object, 'create');

	/** Used to detect maps, sets, and weakmaps. */
	var dataViewCtorString = toSource(DataView),
	    mapCtorString = toSource(Map),
	    promiseCtorString = toSource(Promise),
	    setCtorString = toSource(Set),
	    weakMapCtorString = toSource(WeakMap);

	/** Used to convert symbols to primitives and strings. */
	var symbolProto = Symbol ? Symbol.prototype : undefined,
	    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,
	    symbolToString = symbolProto ? symbolProto.toString : undefined;

	/**
	 * Creates a hash object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Hash(entries) {
	  var index = -1,
	      length = entries ? entries.length : 0;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	/**
	 * Removes all key-value entries from the hash.
	 *
	 * @private
	 * @name clear
	 * @memberOf Hash
	 */
	function hashClear() {
	  this.__data__ = nativeCreate ? nativeCreate(null) : {};
	}

	/**
	 * Removes `key` and its value from the hash.
	 *
	 * @private
	 * @name delete
	 * @memberOf Hash
	 * @param {Object} hash The hash to modify.
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function hashDelete(key) {
	  return this.has(key) && delete this.__data__[key];
	}

	/**
	 * Gets the hash value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Hash
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function hashGet(key) {
	  var data = this.__data__;
	  if (nativeCreate) {
	    var result = data[key];
	    return result === HASH_UNDEFINED ? undefined : result;
	  }
	  return hasOwnProperty.call(data, key) ? data[key] : undefined;
	}

	/**
	 * Checks if a hash value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Hash
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function hashHas(key) {
	  var data = this.__data__;
	  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
	}

	/**
	 * Sets the hash `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Hash
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the hash instance.
	 */
	function hashSet(key, value) {
	  var data = this.__data__;
	  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
	  return this;
	}

	// Add methods to `Hash`.
	Hash.prototype.clear = hashClear;
	Hash.prototype['delete'] = hashDelete;
	Hash.prototype.get = hashGet;
	Hash.prototype.has = hashHas;
	Hash.prototype.set = hashSet;

	/**
	 * Creates an list cache object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function ListCache(entries) {
	  var index = -1,
	      length = entries ? entries.length : 0;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	/**
	 * Removes all key-value entries from the list cache.
	 *
	 * @private
	 * @name clear
	 * @memberOf ListCache
	 */
	function listCacheClear() {
	  this.__data__ = [];
	}

	/**
	 * Removes `key` and its value from the list cache.
	 *
	 * @private
	 * @name delete
	 * @memberOf ListCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function listCacheDelete(key) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);

	  if (index < 0) {
	    return false;
	  }
	  var lastIndex = data.length - 1;
	  if (index == lastIndex) {
	    data.pop();
	  } else {
	    splice.call(data, index, 1);
	  }
	  return true;
	}

	/**
	 * Gets the list cache value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf ListCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function listCacheGet(key) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);

	  return index < 0 ? undefined : data[index][1];
	}

	/**
	 * Checks if a list cache value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf ListCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function listCacheHas(key) {
	  return assocIndexOf(this.__data__, key) > -1;
	}

	/**
	 * Sets the list cache `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf ListCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the list cache instance.
	 */
	function listCacheSet(key, value) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);

	  if (index < 0) {
	    data.push([key, value]);
	  } else {
	    data[index][1] = value;
	  }
	  return this;
	}

	// Add methods to `ListCache`.
	ListCache.prototype.clear = listCacheClear;
	ListCache.prototype['delete'] = listCacheDelete;
	ListCache.prototype.get = listCacheGet;
	ListCache.prototype.has = listCacheHas;
	ListCache.prototype.set = listCacheSet;

	/**
	 * Creates a map cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function MapCache(entries) {
	  var index = -1,
	      length = entries ? entries.length : 0;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	/**
	 * Removes all key-value entries from the map.
	 *
	 * @private
	 * @name clear
	 * @memberOf MapCache
	 */
	function mapCacheClear() {
	  this.__data__ = {
	    'hash': new Hash,
	    'map': new (Map || ListCache),
	    'string': new Hash
	  };
	}

	/**
	 * Removes `key` and its value from the map.
	 *
	 * @private
	 * @name delete
	 * @memberOf MapCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function mapCacheDelete(key) {
	  return getMapData(this, key)['delete'](key);
	}

	/**
	 * Gets the map value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf MapCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function mapCacheGet(key) {
	  return getMapData(this, key).get(key);
	}

	/**
	 * Checks if a map value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf MapCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function mapCacheHas(key) {
	  return getMapData(this, key).has(key);
	}

	/**
	 * Sets the map `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf MapCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the map cache instance.
	 */
	function mapCacheSet(key, value) {
	  getMapData(this, key).set(key, value);
	  return this;
	}

	// Add methods to `MapCache`.
	MapCache.prototype.clear = mapCacheClear;
	MapCache.prototype['delete'] = mapCacheDelete;
	MapCache.prototype.get = mapCacheGet;
	MapCache.prototype.has = mapCacheHas;
	MapCache.prototype.set = mapCacheSet;

	/**
	 *
	 * Creates an array cache object to store unique values.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [values] The values to cache.
	 */
	function SetCache(values) {
	  var index = -1,
	      length = values ? values.length : 0;

	  this.__data__ = new MapCache;
	  while (++index < length) {
	    this.add(values[index]);
	  }
	}

	/**
	 * Adds `value` to the array cache.
	 *
	 * @private
	 * @name add
	 * @memberOf SetCache
	 * @alias push
	 * @param {*} value The value to cache.
	 * @returns {Object} Returns the cache instance.
	 */
	function setCacheAdd(value) {
	  this.__data__.set(value, HASH_UNDEFINED);
	  return this;
	}

	/**
	 * Checks if `value` is in the array cache.
	 *
	 * @private
	 * @name has
	 * @memberOf SetCache
	 * @param {*} value The value to search for.
	 * @returns {number} Returns `true` if `value` is found, else `false`.
	 */
	function setCacheHas(value) {
	  return this.__data__.has(value);
	}

	// Add methods to `SetCache`.
	SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
	SetCache.prototype.has = setCacheHas;

	/**
	 * Creates a stack cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Stack(entries) {
	  this.__data__ = new ListCache(entries);
	}

	/**
	 * Removes all key-value entries from the stack.
	 *
	 * @private
	 * @name clear
	 * @memberOf Stack
	 */
	function stackClear() {
	  this.__data__ = new ListCache;
	}

	/**
	 * Removes `key` and its value from the stack.
	 *
	 * @private
	 * @name delete
	 * @memberOf Stack
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function stackDelete(key) {
	  return this.__data__['delete'](key);
	}

	/**
	 * Gets the stack value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Stack
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function stackGet(key) {
	  return this.__data__.get(key);
	}

	/**
	 * Checks if a stack value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Stack
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function stackHas(key) {
	  return this.__data__.has(key);
	}

	/**
	 * Sets the stack `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Stack
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the stack cache instance.
	 */
	function stackSet(key, value) {
	  var cache = this.__data__;
	  if (cache instanceof ListCache) {
	    var pairs = cache.__data__;
	    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
	      pairs.push([key, value]);
	      return this;
	    }
	    cache = this.__data__ = new MapCache(pairs);
	  }
	  cache.set(key, value);
	  return this;
	}

	// Add methods to `Stack`.
	Stack.prototype.clear = stackClear;
	Stack.prototype['delete'] = stackDelete;
	Stack.prototype.get = stackGet;
	Stack.prototype.has = stackHas;
	Stack.prototype.set = stackSet;

	/**
	 * Creates an array of the enumerable property names of the array-like `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @param {boolean} inherited Specify returning inherited property names.
	 * @returns {Array} Returns the array of property names.
	 */
	function arrayLikeKeys(value, inherited) {
	  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
	  // Safari 9 makes `arguments.length` enumerable in strict mode.
	  var result = (isArray(value) || isArguments(value))
	    ? baseTimes(value.length, String)
	    : [];

	  var length = result.length,
	      skipIndexes = !!length;

	  for (var key in value) {
	    if ((inherited || hasOwnProperty.call(value, key)) &&
	        !(skipIndexes && (key == 'length' || isIndex(key, length)))) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	/**
	 * Gets the index at which the `key` is found in `array` of key-value pairs.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} key The key to search for.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function assocIndexOf(array, key) {
	  var length = array.length;
	  while (length--) {
	    if (eq(array[length][0], key)) {
	      return length;
	    }
	  }
	  return -1;
	}

	/**
	 * Aggregates elements of `collection` on `accumulator` with keys transformed
	 * by `iteratee` and values set by `setter`.
	 *
	 * @private
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {Function} setter The function to set `accumulator` values.
	 * @param {Function} iteratee The iteratee to transform keys.
	 * @param {Object} accumulator The initial aggregated object.
	 * @returns {Function} Returns `accumulator`.
	 */
	function baseAggregator(collection, setter, iteratee, accumulator) {
	  baseEach(collection, function(value, key, collection) {
	    setter(accumulator, value, iteratee(value), collection);
	  });
	  return accumulator;
	}

	/**
	 * The base implementation of `_.forEach` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array|Object} Returns `collection`.
	 */
	var baseEach = createBaseEach(baseForOwn);

	/**
	 * The base implementation of `baseForOwn` which iterates over `object`
	 * properties returned by `keysFunc` and invokes `iteratee` for each property.
	 * Iteratee functions may exit iteration early by explicitly returning `false`.
	 *
	 * @private
	 * @param {Object} object The object to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @param {Function} keysFunc The function to get the keys of `object`.
	 * @returns {Object} Returns `object`.
	 */
	var baseFor = createBaseFor();

	/**
	 * The base implementation of `_.forOwn` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Object} object The object to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Object} Returns `object`.
	 */
	function baseForOwn(object, iteratee) {
	  return object && baseFor(object, iteratee, keys);
	}

	/**
	 * The base implementation of `_.get` without support for default values.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path of the property to get.
	 * @returns {*} Returns the resolved value.
	 */
	function baseGet(object, path) {
	  path = isKey(path, object) ? [path] : castPath(path);

	  var index = 0,
	      length = path.length;

	  while (object != null && index < length) {
	    object = object[toKey(path[index++])];
	  }
	  return (index && index == length) ? object : undefined;
	}

	/**
	 * The base implementation of `getTag`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	function baseGetTag(value) {
	  return objectToString.call(value);
	}

	/**
	 * The base implementation of `_.hasIn` without support for deep paths.
	 *
	 * @private
	 * @param {Object} [object] The object to query.
	 * @param {Array|string} key The key to check.
	 * @returns {boolean} Returns `true` if `key` exists, else `false`.
	 */
	function baseHasIn(object, key) {
	  return object != null && key in Object(object);
	}

	/**
	 * The base implementation of `_.isEqual` which supports partial comparisons
	 * and tracks traversed objects.
	 *
	 * @private
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @param {Function} [customizer] The function to customize comparisons.
	 * @param {boolean} [bitmask] The bitmask of comparison flags.
	 *  The bitmask may be composed of the following flags:
	 *     1 - Unordered comparison
	 *     2 - Partial comparison
	 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 */
	function baseIsEqual(value, other, customizer, bitmask, stack) {
	  if (value === other) {
	    return true;
	  }
	  if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {
	    return value !== value && other !== other;
	  }
	  return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack);
	}

	/**
	 * A specialized version of `baseIsEqual` for arrays and objects which performs
	 * deep comparisons and tracks traversed objects enabling objects with circular
	 * references to be compared.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Function} [customizer] The function to customize comparisons.
	 * @param {number} [bitmask] The bitmask of comparison flags. See `baseIsEqual`
	 *  for more details.
	 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack) {
	  var objIsArr = isArray(object),
	      othIsArr = isArray(other),
	      objTag = arrayTag,
	      othTag = arrayTag;

	  if (!objIsArr) {
	    objTag = getTag(object);
	    objTag = objTag == argsTag ? objectTag : objTag;
	  }
	  if (!othIsArr) {
	    othTag = getTag(other);
	    othTag = othTag == argsTag ? objectTag : othTag;
	  }
	  var objIsObj = objTag == objectTag && !isHostObject(object),
	      othIsObj = othTag == objectTag && !isHostObject(other),
	      isSameTag = objTag == othTag;

	  if (isSameTag && !objIsObj) {
	    stack || (stack = new Stack);
	    return (objIsArr || isTypedArray(object))
	      ? equalArrays(object, other, equalFunc, customizer, bitmask, stack)
	      : equalByTag(object, other, objTag, equalFunc, customizer, bitmask, stack);
	  }
	  if (!(bitmask & PARTIAL_COMPARE_FLAG)) {
	    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
	        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

	    if (objIsWrapped || othIsWrapped) {
	      var objUnwrapped = objIsWrapped ? object.value() : object,
	          othUnwrapped = othIsWrapped ? other.value() : other;

	      stack || (stack = new Stack);
	      return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack);
	    }
	  }
	  if (!isSameTag) {
	    return false;
	  }
	  stack || (stack = new Stack);
	  return equalObjects(object, other, equalFunc, customizer, bitmask, stack);
	}

	/**
	 * The base implementation of `_.isMatch` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Object} object The object to inspect.
	 * @param {Object} source The object of property values to match.
	 * @param {Array} matchData The property names, values, and compare flags to match.
	 * @param {Function} [customizer] The function to customize comparisons.
	 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
	 */
	function baseIsMatch(object, source, matchData, customizer) {
	  var index = matchData.length,
	      length = index,
	      noCustomizer = !customizer;

	  if (object == null) {
	    return !length;
	  }
	  object = Object(object);
	  while (index--) {
	    var data = matchData[index];
	    if ((noCustomizer && data[2])
	          ? data[1] !== object[data[0]]
	          : !(data[0] in object)
	        ) {
	      return false;
	    }
	  }
	  while (++index < length) {
	    data = matchData[index];
	    var key = data[0],
	        objValue = object[key],
	        srcValue = data[1];

	    if (noCustomizer && data[2]) {
	      if (objValue === undefined && !(key in object)) {
	        return false;
	      }
	    } else {
	      var stack = new Stack;
	      if (customizer) {
	        var result = customizer(objValue, srcValue, key, object, source, stack);
	      }
	      if (!(result === undefined
	            ? baseIsEqual(srcValue, objValue, customizer, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG, stack)
	            : result
	          )) {
	        return false;
	      }
	    }
	  }
	  return true;
	}

	/**
	 * The base implementation of `_.isNative` without bad shim checks.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a native function,
	 *  else `false`.
	 */
	function baseIsNative(value) {
	  if (!isObject(value) || isMasked(value)) {
	    return false;
	  }
	  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;
	  return pattern.test(toSource(value));
	}

	/**
	 * The base implementation of `_.isTypedArray` without Node.js optimizations.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 */
	function baseIsTypedArray(value) {
	  return isObjectLike(value) &&
	    isLength(value.length) && !!typedArrayTags[objectToString.call(value)];
	}

	/**
	 * The base implementation of `_.iteratee`.
	 *
	 * @private
	 * @param {*} [value=_.identity] The value to convert to an iteratee.
	 * @returns {Function} Returns the iteratee.
	 */
	function baseIteratee(value) {
	  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
	  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
	  if (typeof value == 'function') {
	    return value;
	  }
	  if (value == null) {
	    return identity;
	  }
	  if (typeof value == 'object') {
	    return isArray(value)
	      ? baseMatchesProperty(value[0], value[1])
	      : baseMatches(value);
	  }
	  return property(value);
	}

	/**
	 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function baseKeys(object) {
	  if (!isPrototype(object)) {
	    return nativeKeys(object);
	  }
	  var result = [];
	  for (var key in Object(object)) {
	    if (hasOwnProperty.call(object, key) && key != 'constructor') {
	      result.push(key);
	    }
	  }
	  return result;
	}

	/**
	 * The base implementation of `_.matches` which doesn't clone `source`.
	 *
	 * @private
	 * @param {Object} source The object of property values to match.
	 * @returns {Function} Returns the new spec function.
	 */
	function baseMatches(source) {
	  var matchData = getMatchData(source);
	  if (matchData.length == 1 && matchData[0][2]) {
	    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
	  }
	  return function(object) {
	    return object === source || baseIsMatch(object, source, matchData);
	  };
	}

	/**
	 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
	 *
	 * @private
	 * @param {string} path The path of the property to get.
	 * @param {*} srcValue The value to match.
	 * @returns {Function} Returns the new spec function.
	 */
	function baseMatchesProperty(path, srcValue) {
	  if (isKey(path) && isStrictComparable(srcValue)) {
	    return matchesStrictComparable(toKey(path), srcValue);
	  }
	  return function(object) {
	    var objValue = get(object, path);
	    return (objValue === undefined && objValue === srcValue)
	      ? hasIn(object, path)
	      : baseIsEqual(srcValue, objValue, undefined, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG);
	  };
	}

	/**
	 * A specialized version of `baseProperty` which supports deep paths.
	 *
	 * @private
	 * @param {Array|string} path The path of the property to get.
	 * @returns {Function} Returns the new accessor function.
	 */
	function basePropertyDeep(path) {
	  return function(object) {
	    return baseGet(object, path);
	  };
	}

	/**
	 * The base implementation of `_.toString` which doesn't convert nullish
	 * values to empty strings.
	 *
	 * @private
	 * @param {*} value The value to process.
	 * @returns {string} Returns the string.
	 */
	function baseToString(value) {
	  // Exit early for strings to avoid a performance hit in some environments.
	  if (typeof value == 'string') {
	    return value;
	  }
	  if (isSymbol(value)) {
	    return symbolToString ? symbolToString.call(value) : '';
	  }
	  var result = (value + '');
	  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
	}

	/**
	 * Casts `value` to a path array if it's not one.
	 *
	 * @private
	 * @param {*} value The value to inspect.
	 * @returns {Array} Returns the cast property path array.
	 */
	function castPath(value) {
	  return isArray(value) ? value : stringToPath(value);
	}

	/**
	 * Creates a function like `_.groupBy`.
	 *
	 * @private
	 * @param {Function} setter The function to set accumulator values.
	 * @param {Function} [initializer] The accumulator object initializer.
	 * @returns {Function} Returns the new aggregator function.
	 */
	function createAggregator(setter, initializer) {
	  return function(collection, iteratee) {
	    var func = isArray(collection) ? arrayAggregator : baseAggregator,
	        accumulator = initializer ? initializer() : {};

	    return func(collection, setter, baseIteratee(iteratee), accumulator);
	  };
	}

	/**
	 * Creates a `baseEach` or `baseEachRight` function.
	 *
	 * @private
	 * @param {Function} eachFunc The function to iterate over a collection.
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {Function} Returns the new base function.
	 */
	function createBaseEach(eachFunc, fromRight) {
	  return function(collection, iteratee) {
	    if (collection == null) {
	      return collection;
	    }
	    if (!isArrayLike(collection)) {
	      return eachFunc(collection, iteratee);
	    }
	    var length = collection.length,
	        index = fromRight ? length : -1,
	        iterable = Object(collection);

	    while ((fromRight ? index-- : ++index < length)) {
	      if (iteratee(iterable[index], index, iterable) === false) {
	        break;
	      }
	    }
	    return collection;
	  };
	}

	/**
	 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
	 *
	 * @private
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {Function} Returns the new base function.
	 */
	function createBaseFor(fromRight) {
	  return function(object, iteratee, keysFunc) {
	    var index = -1,
	        iterable = Object(object),
	        props = keysFunc(object),
	        length = props.length;

	    while (length--) {
	      var key = props[fromRight ? length : ++index];
	      if (iteratee(iterable[key], key, iterable) === false) {
	        break;
	      }
	    }
	    return object;
	  };
	}

	/**
	 * A specialized version of `baseIsEqualDeep` for arrays with support for
	 * partial deep comparisons.
	 *
	 * @private
	 * @param {Array} array The array to compare.
	 * @param {Array} other The other array to compare.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
	 *  for more details.
	 * @param {Object} stack Tracks traversed `array` and `other` objects.
	 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
	 */
	function equalArrays(array, other, equalFunc, customizer, bitmask, stack) {
	  var isPartial = bitmask & PARTIAL_COMPARE_FLAG,
	      arrLength = array.length,
	      othLength = other.length;

	  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
	    return false;
	  }
	  // Assume cyclic values are equal.
	  var stacked = stack.get(array);
	  if (stacked && stack.get(other)) {
	    return stacked == other;
	  }
	  var index = -1,
	      result = true,
	      seen = (bitmask & UNORDERED_COMPARE_FLAG) ? new SetCache : undefined;

	  stack.set(array, other);
	  stack.set(other, array);

	  // Ignore non-index properties.
	  while (++index < arrLength) {
	    var arrValue = array[index],
	        othValue = other[index];

	    if (customizer) {
	      var compared = isPartial
	        ? customizer(othValue, arrValue, index, other, array, stack)
	        : customizer(arrValue, othValue, index, array, other, stack);
	    }
	    if (compared !== undefined) {
	      if (compared) {
	        continue;
	      }
	      result = false;
	      break;
	    }
	    // Recursively compare arrays (susceptible to call stack limits).
	    if (seen) {
	      if (!arraySome(other, function(othValue, othIndex) {
	            if (!seen.has(othIndex) &&
	                (arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
	              return seen.add(othIndex);
	            }
	          })) {
	        result = false;
	        break;
	      }
	    } else if (!(
	          arrValue === othValue ||
	            equalFunc(arrValue, othValue, customizer, bitmask, stack)
	        )) {
	      result = false;
	      break;
	    }
	  }
	  stack['delete'](array);
	  stack['delete'](other);
	  return result;
	}

	/**
	 * A specialized version of `baseIsEqualDeep` for comparing objects of
	 * the same `toStringTag`.
	 *
	 * **Note:** This function only supports comparing values with tags of
	 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {string} tag The `toStringTag` of the objects to compare.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
	 *  for more details.
	 * @param {Object} stack Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function equalByTag(object, other, tag, equalFunc, customizer, bitmask, stack) {
	  switch (tag) {
	    case dataViewTag:
	      if ((object.byteLength != other.byteLength) ||
	          (object.byteOffset != other.byteOffset)) {
	        return false;
	      }
	      object = object.buffer;
	      other = other.buffer;

	    case arrayBufferTag:
	      if ((object.byteLength != other.byteLength) ||
	          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
	        return false;
	      }
	      return true;

	    case boolTag:
	    case dateTag:
	    case numberTag:
	      // Coerce booleans to `1` or `0` and dates to milliseconds.
	      // Invalid dates are coerced to `NaN`.
	      return eq(+object, +other);

	    case errorTag:
	      return object.name == other.name && object.message == other.message;

	    case regexpTag:
	    case stringTag:
	      // Coerce regexes to strings and treat strings, primitives and objects,
	      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
	      // for more details.
	      return object == (other + '');

	    case mapTag:
	      var convert = mapToArray;

	    case setTag:
	      var isPartial = bitmask & PARTIAL_COMPARE_FLAG;
	      convert || (convert = setToArray);

	      if (object.size != other.size && !isPartial) {
	        return false;
	      }
	      // Assume cyclic values are equal.
	      var stacked = stack.get(object);
	      if (stacked) {
	        return stacked == other;
	      }
	      bitmask |= UNORDERED_COMPARE_FLAG;

	      // Recursively compare objects (susceptible to call stack limits).
	      stack.set(object, other);
	      var result = equalArrays(convert(object), convert(other), equalFunc, customizer, bitmask, stack);
	      stack['delete'](object);
	      return result;

	    case symbolTag:
	      if (symbolValueOf) {
	        return symbolValueOf.call(object) == symbolValueOf.call(other);
	      }
	  }
	  return false;
	}

	/**
	 * A specialized version of `baseIsEqualDeep` for objects with support for
	 * partial deep comparisons.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
	 *  for more details.
	 * @param {Object} stack Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function equalObjects(object, other, equalFunc, customizer, bitmask, stack) {
	  var isPartial = bitmask & PARTIAL_COMPARE_FLAG,
	      objProps = keys(object),
	      objLength = objProps.length,
	      othProps = keys(other),
	      othLength = othProps.length;

	  if (objLength != othLength && !isPartial) {
	    return false;
	  }
	  var index = objLength;
	  while (index--) {
	    var key = objProps[index];
	    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
	      return false;
	    }
	  }
	  // Assume cyclic values are equal.
	  var stacked = stack.get(object);
	  if (stacked && stack.get(other)) {
	    return stacked == other;
	  }
	  var result = true;
	  stack.set(object, other);
	  stack.set(other, object);

	  var skipCtor = isPartial;
	  while (++index < objLength) {
	    key = objProps[index];
	    var objValue = object[key],
	        othValue = other[key];

	    if (customizer) {
	      var compared = isPartial
	        ? customizer(othValue, objValue, key, other, object, stack)
	        : customizer(objValue, othValue, key, object, other, stack);
	    }
	    // Recursively compare objects (susceptible to call stack limits).
	    if (!(compared === undefined
	          ? (objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack))
	          : compared
	        )) {
	      result = false;
	      break;
	    }
	    skipCtor || (skipCtor = key == 'constructor');
	  }
	  if (result && !skipCtor) {
	    var objCtor = object.constructor,
	        othCtor = other.constructor;

	    // Non `Object` object instances with different constructors are not equal.
	    if (objCtor != othCtor &&
	        ('constructor' in object && 'constructor' in other) &&
	        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
	          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
	      result = false;
	    }
	  }
	  stack['delete'](object);
	  stack['delete'](other);
	  return result;
	}

	/**
	 * Gets the data for `map`.
	 *
	 * @private
	 * @param {Object} map The map to query.
	 * @param {string} key The reference key.
	 * @returns {*} Returns the map data.
	 */
	function getMapData(map, key) {
	  var data = map.__data__;
	  return isKeyable(key)
	    ? data[typeof key == 'string' ? 'string' : 'hash']
	    : data.map;
	}

	/**
	 * Gets the property names, values, and compare flags of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the match data of `object`.
	 */
	function getMatchData(object) {
	  var result = keys(object),
	      length = result.length;

	  while (length--) {
	    var key = result[length],
	        value = object[key];

	    result[length] = [key, value, isStrictComparable(value)];
	  }
	  return result;
	}

	/**
	 * Gets the native function at `key` of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {string} key The key of the method to get.
	 * @returns {*} Returns the function if it's native, else `undefined`.
	 */
	function getNative(object, key) {
	  var value = getValue(object, key);
	  return baseIsNative(value) ? value : undefined;
	}

	/**
	 * Gets the `toStringTag` of `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	var getTag = baseGetTag;

	// Fallback for data views, maps, sets, and weak maps in IE 11,
	// for data views in Edge < 14, and promises in Node.js.
	if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
	    (Map && getTag(new Map) != mapTag) ||
	    (Promise && getTag(Promise.resolve()) != promiseTag) ||
	    (Set && getTag(new Set) != setTag) ||
	    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
	  getTag = function(value) {
	    var result = objectToString.call(value),
	        Ctor = result == objectTag ? value.constructor : undefined,
	        ctorString = Ctor ? toSource(Ctor) : undefined;

	    if (ctorString) {
	      switch (ctorString) {
	        case dataViewCtorString: return dataViewTag;
	        case mapCtorString: return mapTag;
	        case promiseCtorString: return promiseTag;
	        case setCtorString: return setTag;
	        case weakMapCtorString: return weakMapTag;
	      }
	    }
	    return result;
	  };
	}

	/**
	 * Checks if `path` exists on `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path to check.
	 * @param {Function} hasFunc The function to check properties.
	 * @returns {boolean} Returns `true` if `path` exists, else `false`.
	 */
	function hasPath(object, path, hasFunc) {
	  path = isKey(path, object) ? [path] : castPath(path);

	  var result,
	      index = -1,
	      length = path.length;

	  while (++index < length) {
	    var key = toKey(path[index]);
	    if (!(result = object != null && hasFunc(object, key))) {
	      break;
	    }
	    object = object[key];
	  }
	  if (result) {
	    return result;
	  }
	  var length = object ? object.length : 0;
	  return !!length && isLength(length) && isIndex(key, length) &&
	    (isArray(object) || isArguments(object));
	}

	/**
	 * Checks if `value` is a valid array-like index.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
	 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
	 */
	function isIndex(value, length) {
	  length = length == null ? MAX_SAFE_INTEGER : length;
	  return !!length &&
	    (typeof value == 'number' || reIsUint.test(value)) &&
	    (value > -1 && value % 1 == 0 && value < length);
	}

	/**
	 * Checks if `value` is a property name and not a property path.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {Object} [object] The object to query keys on.
	 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
	 */
	function isKey(value, object) {
	  if (isArray(value)) {
	    return false;
	  }
	  var type = typeof value;
	  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
	      value == null || isSymbol(value)) {
	    return true;
	  }
	  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
	    (object != null && value in Object(object));
	}

	/**
	 * Checks if `value` is suitable for use as unique object key.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
	 */
	function isKeyable(value) {
	  var type = typeof value;
	  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
	    ? (value !== '__proto__')
	    : (value === null);
	}

	/**
	 * Checks if `func` has its source masked.
	 *
	 * @private
	 * @param {Function} func The function to check.
	 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
	 */
	function isMasked(func) {
	  return !!maskSrcKey && (maskSrcKey in func);
	}

	/**
	 * Checks if `value` is likely a prototype object.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
	 */
	function isPrototype(value) {
	  var Ctor = value && value.constructor,
	      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

	  return value === proto;
	}

	/**
	 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` if suitable for strict
	 *  equality comparisons, else `false`.
	 */
	function isStrictComparable(value) {
	  return value === value && !isObject(value);
	}

	/**
	 * A specialized version of `matchesProperty` for source values suitable
	 * for strict equality comparisons, i.e. `===`.
	 *
	 * @private
	 * @param {string} key The key of the property to get.
	 * @param {*} srcValue The value to match.
	 * @returns {Function} Returns the new spec function.
	 */
	function matchesStrictComparable(key, srcValue) {
	  return function(object) {
	    if (object == null) {
	      return false;
	    }
	    return object[key] === srcValue &&
	      (srcValue !== undefined || (key in Object(object)));
	  };
	}

	/**
	 * Converts `string` to a property path array.
	 *
	 * @private
	 * @param {string} string The string to convert.
	 * @returns {Array} Returns the property path array.
	 */
	var stringToPath = memoize(function(string) {
	  string = toString(string);

	  var result = [];
	  if (reLeadingDot.test(string)) {
	    result.push('');
	  }
	  string.replace(rePropName, function(match, number, quote, string) {
	    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
	  });
	  return result;
	});

	/**
	 * Converts `value` to a string key if it's not a string or symbol.
	 *
	 * @private
	 * @param {*} value The value to inspect.
	 * @returns {string|symbol} Returns the key.
	 */
	function toKey(value) {
	  if (typeof value == 'string' || isSymbol(value)) {
	    return value;
	  }
	  var result = (value + '');
	  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
	}

	/**
	 * Converts `func` to its source code.
	 *
	 * @private
	 * @param {Function} func The function to process.
	 * @returns {string} Returns the source code.
	 */
	function toSource(func) {
	  if (func != null) {
	    try {
	      return funcToString.call(func);
	    } catch (e) {}
	    try {
	      return (func + '');
	    } catch (e) {}
	  }
	  return '';
	}

	/**
	 * Creates an object composed of keys generated from the results of running
	 * each element of `collection` thru `iteratee`. The order of grouped values
	 * is determined by the order they occur in `collection`. The corresponding
	 * value of each key is an array of elements responsible for generating the
	 * key. The iteratee is invoked with one argument: (value).
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Collection
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {Function} [iteratee=_.identity]
	 *  The iteratee to transform keys.
	 * @returns {Object} Returns the composed aggregate object.
	 * @example
	 *
	 * _.groupBy([6.1, 4.2, 6.3], Math.floor);
	 * // => { '4': [4.2], '6': [6.1, 6.3] }
	 *
	 * // The `_.property` iteratee shorthand.
	 * _.groupBy(['one', 'two', 'three'], 'length');
	 * // => { '3': ['one', 'two'], '5': ['three'] }
	 */
	var groupBy = createAggregator(function(result, value, key) {
	  if (hasOwnProperty.call(result, key)) {
	    result[key].push(value);
	  } else {
	    result[key] = [value];
	  }
	});

	/**
	 * Creates a function that memoizes the result of `func`. If `resolver` is
	 * provided, it determines the cache key for storing the result based on the
	 * arguments provided to the memoized function. By default, the first argument
	 * provided to the memoized function is used as the map cache key. The `func`
	 * is invoked with the `this` binding of the memoized function.
	 *
	 * **Note:** The cache is exposed as the `cache` property on the memoized
	 * function. Its creation may be customized by replacing the `_.memoize.Cache`
	 * constructor with one whose instances implement the
	 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
	 * method interface of `delete`, `get`, `has`, and `set`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Function
	 * @param {Function} func The function to have its output memoized.
	 * @param {Function} [resolver] The function to resolve the cache key.
	 * @returns {Function} Returns the new memoized function.
	 * @example
	 *
	 * var object = { 'a': 1, 'b': 2 };
	 * var other = { 'c': 3, 'd': 4 };
	 *
	 * var values = _.memoize(_.values);
	 * values(object);
	 * // => [1, 2]
	 *
	 * values(other);
	 * // => [3, 4]
	 *
	 * object.a = 2;
	 * values(object);
	 * // => [1, 2]
	 *
	 * // Modify the result cache.
	 * values.cache.set(object, ['a', 'b']);
	 * values(object);
	 * // => ['a', 'b']
	 *
	 * // Replace `_.memoize.Cache`.
	 * _.memoize.Cache = WeakMap;
	 */
	function memoize(func, resolver) {
	  if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {
	    throw new TypeError(FUNC_ERROR_TEXT);
	  }
	  var memoized = function() {
	    var args = arguments,
	        key = resolver ? resolver.apply(this, args) : args[0],
	        cache = memoized.cache;

	    if (cache.has(key)) {
	      return cache.get(key);
	    }
	    var result = func.apply(this, args);
	    memoized.cache = cache.set(key, result);
	    return result;
	  };
	  memoized.cache = new (memoize.Cache || MapCache);
	  return memoized;
	}

	// Assign cache to `_.memoize`.
	memoize.Cache = MapCache;

	/**
	 * Performs a
	 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * comparison between two values to determine if they are equivalent.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 * var other = { 'a': 1 };
	 *
	 * _.eq(object, object);
	 * // => true
	 *
	 * _.eq(object, other);
	 * // => false
	 *
	 * _.eq('a', 'a');
	 * // => true
	 *
	 * _.eq('a', Object('a'));
	 * // => false
	 *
	 * _.eq(NaN, NaN);
	 * // => true
	 */
	function eq(value, other) {
	  return value === other || (value !== value && other !== other);
	}

	/**
	 * Checks if `value` is likely an `arguments` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArguments(function() { return arguments; }());
	 * // => true
	 *
	 * _.isArguments([1, 2, 3]);
	 * // => false
	 */
	function isArguments(value) {
	  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
	  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&
	    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
	}

	/**
	 * Checks if `value` is classified as an `Array` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
	 * @example
	 *
	 * _.isArray([1, 2, 3]);
	 * // => true
	 *
	 * _.isArray(document.body.children);
	 * // => false
	 *
	 * _.isArray('abc');
	 * // => false
	 *
	 * _.isArray(_.noop);
	 * // => false
	 */
	var isArray = Array.isArray;

	/**
	 * Checks if `value` is array-like. A value is considered array-like if it's
	 * not a function and has a `value.length` that's an integer greater than or
	 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	 * @example
	 *
	 * _.isArrayLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLike(document.body.children);
	 * // => true
	 *
	 * _.isArrayLike('abc');
	 * // => true
	 *
	 * _.isArrayLike(_.noop);
	 * // => false
	 */
	function isArrayLike(value) {
	  return value != null && isLength(value.length) && !isFunction(value);
	}

	/**
	 * This method is like `_.isArrayLike` except that it also checks if `value`
	 * is an object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array-like object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArrayLikeObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLikeObject(document.body.children);
	 * // => true
	 *
	 * _.isArrayLikeObject('abc');
	 * // => false
	 *
	 * _.isArrayLikeObject(_.noop);
	 * // => false
	 */
	function isArrayLikeObject(value) {
	  return isObjectLike(value) && isArrayLike(value);
	}

	/**
	 * Checks if `value` is classified as a `Function` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
	 * @example
	 *
	 * _.isFunction(_);
	 * // => true
	 *
	 * _.isFunction(/abc/);
	 * // => false
	 */
	function isFunction(value) {
	  // The use of `Object#toString` avoids issues with the `typeof` operator
	  // in Safari 8-9 which returns 'object' for typed array and other constructors.
	  var tag = isObject(value) ? objectToString.call(value) : '';
	  return tag == funcTag || tag == genTag;
	}

	/**
	 * Checks if `value` is a valid array-like length.
	 *
	 * **Note:** This method is loosely based on
	 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	 * @example
	 *
	 * _.isLength(3);
	 * // => true
	 *
	 * _.isLength(Number.MIN_VALUE);
	 * // => false
	 *
	 * _.isLength(Infinity);
	 * // => false
	 *
	 * _.isLength('3');
	 * // => false
	 */
	function isLength(value) {
	  return typeof value == 'number' &&
	    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	}

	/**
	 * Checks if `value` is the
	 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
	 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(_.noop);
	 * // => true
	 *
	 * _.isObject(null);
	 * // => false
	 */
	function isObject(value) {
	  var type = typeof value;
	  return !!value && (type == 'object' || type == 'function');
	}

	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return !!value && typeof value == 'object';
	}

	/**
	 * Checks if `value` is classified as a `Symbol` primitive or object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
	 * @example
	 *
	 * _.isSymbol(Symbol.iterator);
	 * // => true
	 *
	 * _.isSymbol('abc');
	 * // => false
	 */
	function isSymbol(value) {
	  return typeof value == 'symbol' ||
	    (isObjectLike(value) && objectToString.call(value) == symbolTag);
	}

	/**
	 * Checks if `value` is classified as a typed array.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 * @example
	 *
	 * _.isTypedArray(new Uint8Array);
	 * // => true
	 *
	 * _.isTypedArray([]);
	 * // => false
	 */
	var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

	/**
	 * Converts `value` to a string. An empty string is returned for `null`
	 * and `undefined` values. The sign of `-0` is preserved.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to process.
	 * @returns {string} Returns the string.
	 * @example
	 *
	 * _.toString(null);
	 * // => ''
	 *
	 * _.toString(-0);
	 * // => '-0'
	 *
	 * _.toString([1, 2, 3]);
	 * // => '1,2,3'
	 */
	function toString(value) {
	  return value == null ? '' : baseToString(value);
	}

	/**
	 * Gets the value at `path` of `object`. If the resolved value is
	 * `undefined`, the `defaultValue` is returned in its place.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.7.0
	 * @category Object
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path of the property to get.
	 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
	 * @returns {*} Returns the resolved value.
	 * @example
	 *
	 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
	 *
	 * _.get(object, 'a[0].b.c');
	 * // => 3
	 *
	 * _.get(object, ['a', '0', 'b', 'c']);
	 * // => 3
	 *
	 * _.get(object, 'a.b.c', 'default');
	 * // => 'default'
	 */
	function get(object, path, defaultValue) {
	  var result = object == null ? undefined : baseGet(object, path);
	  return result === undefined ? defaultValue : result;
	}

	/**
	 * Checks if `path` is a direct or inherited property of `object`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Object
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path to check.
	 * @returns {boolean} Returns `true` if `path` exists, else `false`.
	 * @example
	 *
	 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
	 *
	 * _.hasIn(object, 'a');
	 * // => true
	 *
	 * _.hasIn(object, 'a.b');
	 * // => true
	 *
	 * _.hasIn(object, ['a', 'b']);
	 * // => true
	 *
	 * _.hasIn(object, 'b');
	 * // => false
	 */
	function hasIn(object, path) {
	  return object != null && hasPath(object, path, baseHasIn);
	}

	/**
	 * Creates an array of the own enumerable property names of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects. See the
	 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	 * for more details.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.keys(new Foo);
	 * // => ['a', 'b'] (iteration order is not guaranteed)
	 *
	 * _.keys('hi');
	 * // => ['0', '1']
	 */
	function keys(object) {
	  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
	}

	/**
	 * This method returns the first argument it receives.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Util
	 * @param {*} value Any value.
	 * @returns {*} Returns `value`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 *
	 * console.log(_.identity(object) === object);
	 * // => true
	 */
	function identity(value) {
	  return value;
	}

	/**
	 * Creates a function that returns the value at `path` of a given object.
	 *
	 * @static
	 * @memberOf _
	 * @since 2.4.0
	 * @category Util
	 * @param {Array|string} path The path of the property to get.
	 * @returns {Function} Returns the new accessor function.
	 * @example
	 *
	 * var objects = [
	 *   { 'a': { 'b': 2 } },
	 *   { 'a': { 'b': 1 } }
	 * ];
	 *
	 * _.map(objects, _.property('a.b'));
	 * // => [2, 1]
	 *
	 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
	 * // => [1, 2]
	 */
	function property(path) {
	  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
	}

	module.exports = groupBy;
	});

	var HeaderTransformer_1 = createCommonjsModule(function (module, exports) {
	var __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.HeaderTransformer = void 0;
	const lodash_isundefined_1 = __importDefault(lodash_isundefined);
	const lodash_isfunction_1 = __importDefault(lodash_isfunction);
	const lodash_uniq_1 = __importDefault(lodash_uniq);
	const lodash_groupby_1 = __importDefault(lodash_groupby);
	class HeaderTransformer {
	    constructor(parserOptions) {
	        this.headers = null;
	        this.receivedHeaders = false;
	        this.shouldUseFirstRow = false;
	        this.processedFirstRow = false;
	        this.headersLength = 0;
	        this.parserOptions = parserOptions;
	        if (parserOptions.headers === true) {
	            this.shouldUseFirstRow = true;
	        }
	        else if (Array.isArray(parserOptions.headers)) {
	            this.setHeaders(parserOptions.headers);
	        }
	        else if (lodash_isfunction_1.default(parserOptions.headers)) {
	            this.headersTransform = parserOptions.headers;
	        }
	    }
	    transform(row, cb) {
	        if (!this.shouldMapRow(row)) {
	            return cb(null, { row: null, isValid: true });
	        }
	        return cb(null, this.processRow(row));
	    }
	    shouldMapRow(row) {
	        const { parserOptions } = this;
	        if (!this.headersTransform && parserOptions.renameHeaders && !this.processedFirstRow) {
	            if (!this.receivedHeaders) {
	                throw new Error('Error renaming headers: new headers must be provided in an array');
	            }
	            this.processedFirstRow = true;
	            return false;
	        }
	        if (!this.receivedHeaders && Array.isArray(row)) {
	            if (this.headersTransform) {
	                this.setHeaders(this.headersTransform(row));
	            }
	            else if (this.shouldUseFirstRow) {
	                this.setHeaders(row);
	            }
	            else {
	                // dont do anything with the headers if we didnt receive a transform or shouldnt use the first row.
	                return true;
	            }
	            return false;
	        }
	        return true;
	    }
	    processRow(row) {
	        if (!this.headers) {
	            return { row: row, isValid: true };
	        }
	        const { parserOptions } = this;
	        if (!parserOptions.discardUnmappedColumns && row.length > this.headersLength) {
	            if (!parserOptions.strictColumnHandling) {
	                throw new Error(`Unexpected Error: column header mismatch expected: ${this.headersLength} columns got: ${row.length}`);
	            }
	            return {
	                row: row,
	                isValid: false,
	                reason: `Column header mismatch expected: ${this.headersLength} columns got: ${row.length}`,
	            };
	        }
	        if (parserOptions.strictColumnHandling && row.length < this.headersLength) {
	            return {
	                row: row,
	                isValid: false,
	                reason: `Column header mismatch expected: ${this.headersLength} columns got: ${row.length}`,
	            };
	        }
	        return { row: this.mapHeaders(row), isValid: true };
	    }
	    mapHeaders(row) {
	        const rowMap = {};
	        const { headers, headersLength } = this;
	        for (let i = 0; i < headersLength; i += 1) {
	            const header = headers[i];
	            if (!lodash_isundefined_1.default(header)) {
	                const val = row[i];
	                // eslint-disable-next-line no-param-reassign
	                if (lodash_isundefined_1.default(val)) {
	                    rowMap[header] = '';
	                }
	                else {
	                    rowMap[header] = val;
	                }
	            }
	        }
	        return rowMap;
	    }
	    setHeaders(headers) {
	        var _a;
	        const filteredHeaders = headers.filter((h) => !!h);
	        if (lodash_uniq_1.default(filteredHeaders).length !== filteredHeaders.length) {
	            const grouped = lodash_groupby_1.default(filteredHeaders);
	            const duplicates = Object.keys(grouped).filter((dup) => grouped[dup].length > 1);
	            throw new Error(`Duplicate headers found ${JSON.stringify(duplicates)}`);
	        }
	        this.headers = headers;
	        this.receivedHeaders = true;
	        this.headersLength = ((_a = this.headers) === null || _a === void 0 ? void 0 : _a.length) || 0;
	    }
	}
	exports.HeaderTransformer = HeaderTransformer;

	});

	unwrapExports(HeaderTransformer_1);
	var HeaderTransformer_2 = HeaderTransformer_1.HeaderTransformer;

	var transforms = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.HeaderTransformer = exports.RowTransformerValidator = void 0;

	Object.defineProperty(exports, "RowTransformerValidator", { enumerable: true, get: function () { return RowTransformerValidator_1.RowTransformerValidator; } });

	Object.defineProperty(exports, "HeaderTransformer", { enumerable: true, get: function () { return HeaderTransformer_1.HeaderTransformer; } });

	});

	unwrapExports(transforms);
	var transforms_1 = transforms.HeaderTransformer;
	var transforms_2 = transforms.RowTransformerValidator;

	var Token_1 = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.Token = void 0;
	class Token {
	    constructor(tokenArgs) {
	        this.token = tokenArgs.token;
	        this.startCursor = tokenArgs.startCursor;
	        this.endCursor = tokenArgs.endCursor;
	    }
	    static isTokenRowDelimiter(token) {
	        const content = token.token;
	        return content === '\r' || content === '\n' || content === '\r\n';
	    }
	    static isTokenCarriageReturn(token, parserOptions) {
	        return token.token === parserOptions.carriageReturn;
	    }
	    static isTokenComment(token, parserOptions) {
	        return parserOptions.supportsComments && !!token && token.token === parserOptions.comment;
	    }
	    static isTokenEscapeCharacter(token, parserOptions) {
	        return token.token === parserOptions.escapeChar;
	    }
	    static isTokenQuote(token, parserOptions) {
	        return token.token === parserOptions.quote;
	    }
	    static isTokenDelimiter(token, parserOptions) {
	        return token.token === parserOptions.delimiter;
	    }
	}
	exports.Token = Token;

	});

	unwrapExports(Token_1);
	var Token_2 = Token_1.Token;

	var Scanner_1 = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.Scanner = void 0;

	const ROW_DELIMITER = /((?:\r\n)|\n|\r)/;
	class Scanner {
	    constructor(args) {
	        this.cursor = 0;
	        this.line = args.line;
	        this.lineLength = this.line.length;
	        this.parserOptions = args.parserOptions;
	        this.hasMoreData = args.hasMoreData;
	        this.cursor = args.cursor || 0;
	    }
	    get hasMoreCharacters() {
	        return this.lineLength > this.cursor;
	    }
	    get nextNonSpaceToken() {
	        const { lineFromCursor } = this;
	        const regex = this.parserOptions.NEXT_TOKEN_REGEXP;
	        if (lineFromCursor.search(regex) === -1) {
	            return null;
	        }
	        const match = regex.exec(lineFromCursor);
	        if (match == null) {
	            return null;
	        }
	        const token = match[1];
	        const startCursor = this.cursor + (match.index || 0);
	        return new Token_1.Token({
	            token,
	            startCursor,
	            endCursor: startCursor + token.length - 1,
	        });
	    }
	    get nextCharacterToken() {
	        const { cursor, lineLength } = this;
	        if (lineLength <= cursor) {
	            return null;
	        }
	        return new Token_1.Token({
	            token: this.line[cursor],
	            startCursor: cursor,
	            endCursor: cursor,
	        });
	    }
	    get lineFromCursor() {
	        return this.line.substr(this.cursor);
	    }
	    advancePastLine() {
	        const match = ROW_DELIMITER.exec(this.lineFromCursor);
	        if (!match) {
	            if (this.hasMoreData) {
	                return null;
	            }
	            this.cursor = this.lineLength;
	            return this;
	        }
	        this.cursor += (match.index || 0) + match[0].length;
	        return this;
	    }
	    advanceTo(cursor) {
	        this.cursor = cursor;
	        return this;
	    }
	    advanceToToken(token) {
	        this.cursor = token.startCursor;
	        return this;
	    }
	    advancePastToken(token) {
	        this.cursor = token.endCursor + 1;
	        return this;
	    }
	    truncateToCursor() {
	        this.line = this.lineFromCursor;
	        this.lineLength = this.line.length;
	        this.cursor = 0;
	        return this;
	    }
	}
	exports.Scanner = Scanner;

	});

	unwrapExports(Scanner_1);
	var Scanner_2 = Scanner_1.Scanner;

	var ColumnFormatter_1 = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.ColumnFormatter = void 0;
	class ColumnFormatter {
	    constructor(parserOptions) {
	        if (parserOptions.trim) {
	            this.format = (col) => col.trim();
	        }
	        else if (parserOptions.ltrim) {
	            this.format = (col) => col.trimLeft();
	        }
	        else if (parserOptions.rtrim) {
	            this.format = (col) => col.trimRight();
	        }
	        else {
	            this.format = (col) => col;
	        }
	    }
	}
	exports.ColumnFormatter = ColumnFormatter;

	});

	unwrapExports(ColumnFormatter_1);
	var ColumnFormatter_2 = ColumnFormatter_1.ColumnFormatter;

	var NonQuotedColumnParser_1 = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.NonQuotedColumnParser = void 0;


	class NonQuotedColumnParser {
	    constructor(parserOptions) {
	        this.parserOptions = parserOptions;
	        this.columnFormatter = new ColumnFormatter_1.ColumnFormatter(parserOptions);
	    }
	    parse(scanner) {
	        if (!scanner.hasMoreCharacters) {
	            return null;
	        }
	        const { parserOptions } = this;
	        const characters = [];
	        let nextToken = scanner.nextCharacterToken;
	        for (; nextToken; nextToken = scanner.nextCharacterToken) {
	            if (Token_1.Token.isTokenDelimiter(nextToken, parserOptions) || Token_1.Token.isTokenRowDelimiter(nextToken)) {
	                break;
	            }
	            characters.push(nextToken.token);
	            scanner.advancePastToken(nextToken);
	        }
	        return this.columnFormatter.format(characters.join(''));
	    }
	}
	exports.NonQuotedColumnParser = NonQuotedColumnParser;

	});

	unwrapExports(NonQuotedColumnParser_1);
	var NonQuotedColumnParser_2 = NonQuotedColumnParser_1.NonQuotedColumnParser;

	var QuotedColumnParser_1 = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.QuotedColumnParser = void 0;


	class QuotedColumnParser {
	    constructor(parserOptions) {
	        this.parserOptions = parserOptions;
	        this.columnFormatter = new ColumnFormatter_1.ColumnFormatter(parserOptions);
	    }
	    parse(scanner) {
	        if (!scanner.hasMoreCharacters) {
	            return null;
	        }
	        const originalCursor = scanner.cursor;
	        const { foundClosingQuote, col } = this.gatherDataBetweenQuotes(scanner);
	        if (!foundClosingQuote) {
	            // reset the cursor to the original
	            scanner.advanceTo(originalCursor);
	            // if we didnt find a closing quote but we potentially have more data then skip the parsing
	            // and return the original scanner.
	            if (!scanner.hasMoreData) {
	                throw new Error(`Parse Error: missing closing: '${this.parserOptions.quote || ''}' in line: at '${scanner.lineFromCursor.replace(/[\r\n]/g, "\\n'")}'`);
	            }
	            return null;
	        }
	        this.checkForMalformedColumn(scanner);
	        return col;
	    }
	    gatherDataBetweenQuotes(scanner) {
	        const { parserOptions } = this;
	        let foundStartingQuote = false;
	        let foundClosingQuote = false;
	        const characters = [];
	        let nextToken = scanner.nextCharacterToken;
	        for (; !foundClosingQuote && nextToken !== null; nextToken = scanner.nextCharacterToken) {
	            const isQuote = Token_1.Token.isTokenQuote(nextToken, parserOptions);
	            // ignore first quote
	            if (!foundStartingQuote && isQuote) {
	                foundStartingQuote = true;
	            }
	            else if (foundStartingQuote) {
	                if (Token_1.Token.isTokenEscapeCharacter(nextToken, parserOptions)) {
	                    // advance past the escape character so we can get the next one in line
	                    scanner.advancePastToken(nextToken);
	                    const tokenFollowingEscape = scanner.nextCharacterToken;
	                    // if the character following the escape is a quote character then just add
	                    // the quote and advance to that character
	                    if (tokenFollowingEscape !== null &&
	                        (Token_1.Token.isTokenQuote(tokenFollowingEscape, parserOptions) ||
	                            Token_1.Token.isTokenEscapeCharacter(tokenFollowingEscape, parserOptions))) {
	                        characters.push(tokenFollowingEscape.token);
	                        nextToken = tokenFollowingEscape;
	                    }
	                    else if (isQuote) {
	                        // if the escape is also a quote then we found our closing quote and finish early
	                        foundClosingQuote = true;
	                    }
	                    else {
	                        // other wise add the escape token to the characters since it wast escaping anything
	                        characters.push(nextToken.token);
	                    }
	                }
	                else if (isQuote) {
	                    // we found our closing quote!
	                    foundClosingQuote = true;
	                }
	                else {
	                    // add the token to the characters
	                    characters.push(nextToken.token);
	                }
	            }
	            scanner.advancePastToken(nextToken);
	        }
	        return { col: this.columnFormatter.format(characters.join('')), foundClosingQuote };
	    }
	    checkForMalformedColumn(scanner) {
	        const { parserOptions } = this;
	        const { nextNonSpaceToken } = scanner;
	        if (nextNonSpaceToken) {
	            const isNextTokenADelimiter = Token_1.Token.isTokenDelimiter(nextNonSpaceToken, parserOptions);
	            const isNextTokenARowDelimiter = Token_1.Token.isTokenRowDelimiter(nextNonSpaceToken);
	            if (!(isNextTokenADelimiter || isNextTokenARowDelimiter)) {
	                // if the final quote was NOT followed by a column (,) or row(\n) delimiter then its a bad column
	                // tldr: only part of the column was quoted
	                const linePreview = scanner.lineFromCursor.substr(0, 10).replace(/[\r\n]/g, "\\n'");
	                throw new Error(`Parse Error: expected: '${parserOptions.escapedDelimiter}' OR new line got: '${nextNonSpaceToken.token}'. at '${linePreview}`);
	            }
	            scanner.advanceToToken(nextNonSpaceToken);
	        }
	        else if (!scanner.hasMoreData) {
	            scanner.advancePastLine();
	        }
	    }
	}
	exports.QuotedColumnParser = QuotedColumnParser;

	});

	unwrapExports(QuotedColumnParser_1);
	var QuotedColumnParser_2 = QuotedColumnParser_1.QuotedColumnParser;

	var ColumnParser_1 = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.ColumnParser = void 0;



	class ColumnParser {
	    constructor(parserOptions) {
	        this.parserOptions = parserOptions;
	        this.quotedColumnParser = new QuotedColumnParser_1.QuotedColumnParser(parserOptions);
	        this.nonQuotedColumnParser = new NonQuotedColumnParser_1.NonQuotedColumnParser(parserOptions);
	    }
	    parse(scanner) {
	        const { nextNonSpaceToken } = scanner;
	        if (nextNonSpaceToken !== null && Token_1.Token.isTokenQuote(nextNonSpaceToken, this.parserOptions)) {
	            scanner.advanceToToken(nextNonSpaceToken);
	            return this.quotedColumnParser.parse(scanner);
	        }
	        return this.nonQuotedColumnParser.parse(scanner);
	    }
	}
	exports.ColumnParser = ColumnParser;

	});

	unwrapExports(ColumnParser_1);
	var ColumnParser_2 = ColumnParser_1.ColumnParser;

	var column$1 = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.ColumnFormatter = exports.QuotedColumnParser = exports.NonQuotedColumnParser = exports.ColumnParser = void 0;

	Object.defineProperty(exports, "ColumnParser", { enumerable: true, get: function () { return ColumnParser_1.ColumnParser; } });

	Object.defineProperty(exports, "NonQuotedColumnParser", { enumerable: true, get: function () { return NonQuotedColumnParser_1.NonQuotedColumnParser; } });

	Object.defineProperty(exports, "QuotedColumnParser", { enumerable: true, get: function () { return QuotedColumnParser_1.QuotedColumnParser; } });

	Object.defineProperty(exports, "ColumnFormatter", { enumerable: true, get: function () { return ColumnFormatter_1.ColumnFormatter; } });

	});

	unwrapExports(column$1);
	var column_1 = column$1.ColumnFormatter;
	var column_2 = column$1.QuotedColumnParser;
	var column_3 = column$1.NonQuotedColumnParser;
	var column_4 = column$1.ColumnParser;

	var RowParser_1 = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.RowParser = void 0;


	const EMPTY_STRING = '';
	class RowParser {
	    constructor(parserOptions) {
	        this.parserOptions = parserOptions;
	        this.columnParser = new column$1.ColumnParser(parserOptions);
	    }
	    static isEmptyRow(row) {
	        return row.join(EMPTY_STRING).replace(/\s+/g, EMPTY_STRING) === EMPTY_STRING;
	    }
	    parse(scanner) {
	        const { parserOptions } = this;
	        const { hasMoreData } = scanner;
	        const currentScanner = scanner;
	        const columns = [];
	        let currentToken = this.getStartToken(currentScanner, columns);
	        while (currentToken) {
	            if (Token_1.Token.isTokenRowDelimiter(currentToken)) {
	                currentScanner.advancePastToken(currentToken);
	                // if ends with CR and there is more data, keep unparsed due to possible
	                // coming LF in CRLF
	                if (!currentScanner.hasMoreCharacters &&
	                    Token_1.Token.isTokenCarriageReturn(currentToken, parserOptions) &&
	                    hasMoreData) {
	                    return null;
	                }
	                currentScanner.truncateToCursor();
	                return columns;
	            }
	            if (!this.shouldSkipColumnParse(currentScanner, currentToken, columns)) {
	                const item = this.columnParser.parse(currentScanner);
	                if (item === null) {
	                    return null;
	                }
	                columns.push(item);
	            }
	            currentToken = currentScanner.nextNonSpaceToken;
	        }
	        if (!hasMoreData) {
	            currentScanner.truncateToCursor();
	            return columns;
	        }
	        return null;
	    }
	    getStartToken(scanner, columns) {
	        const currentToken = scanner.nextNonSpaceToken;
	        if (currentToken !== null && Token_1.Token.isTokenDelimiter(currentToken, this.parserOptions)) {
	            columns.push('');
	            return scanner.nextNonSpaceToken;
	        }
	        return currentToken;
	    }
	    shouldSkipColumnParse(scanner, currentToken, columns) {
	        const { parserOptions } = this;
	        if (Token_1.Token.isTokenDelimiter(currentToken, parserOptions)) {
	            scanner.advancePastToken(currentToken);
	            // if the delimiter is at the end of a line
	            const nextToken = scanner.nextCharacterToken;
	            if (!scanner.hasMoreCharacters || (nextToken !== null && Token_1.Token.isTokenRowDelimiter(nextToken))) {
	                columns.push('');
	                return true;
	            }
	            if (nextToken !== null && Token_1.Token.isTokenDelimiter(nextToken, parserOptions)) {
	                columns.push('');
	                return true;
	            }
	        }
	        return false;
	    }
	}
	exports.RowParser = RowParser;

	});

	unwrapExports(RowParser_1);
	var RowParser_2 = RowParser_1.RowParser;

	var Parser_1 = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.Parser = void 0;



	class Parser {
	    constructor(parserOptions) {
	        this.parserOptions = parserOptions;
	        this.rowParser = new RowParser_1.RowParser(this.parserOptions);
	    }
	    static removeBOM(line) {
	        // Catches EFBBBF (UTF-8 BOM) because the buffer-to-string
	        // conversion translates it to FEFF (UTF-16 BOM)
	        if (line && line.charCodeAt(0) === 0xfeff) {
	            return line.slice(1);
	        }
	        return line;
	    }
	    parse(line, hasMoreData) {
	        const scanner = new Scanner_1.Scanner({
	            line: Parser.removeBOM(line),
	            parserOptions: this.parserOptions,
	            hasMoreData,
	        });
	        if (this.parserOptions.supportsComments) {
	            return this.parseWithComments(scanner);
	        }
	        return this.parseWithoutComments(scanner);
	    }
	    parseWithoutComments(scanner) {
	        const rows = [];
	        let shouldContinue = true;
	        while (shouldContinue) {
	            shouldContinue = this.parseRow(scanner, rows);
	        }
	        return { line: scanner.line, rows };
	    }
	    parseWithComments(scanner) {
	        const { parserOptions } = this;
	        const rows = [];
	        for (let nextToken = scanner.nextCharacterToken; nextToken !== null; nextToken = scanner.nextCharacterToken) {
	            if (Token_1.Token.isTokenComment(nextToken, parserOptions)) {
	                const cursor = scanner.advancePastLine();
	                if (cursor === null) {
	                    return { line: scanner.lineFromCursor, rows };
	                }
	                if (!scanner.hasMoreCharacters) {
	                    return { line: scanner.lineFromCursor, rows };
	                }
	                scanner.truncateToCursor();
	            }
	            else if (!this.parseRow(scanner, rows)) {
	                break;
	            }
	        }
	        return { line: scanner.line, rows };
	    }
	    parseRow(scanner, rows) {
	        const nextToken = scanner.nextNonSpaceToken;
	        if (!nextToken) {
	            return false;
	        }
	        const row = this.rowParser.parse(scanner);
	        if (row === null) {
	            return false;
	        }
	        if (this.parserOptions.ignoreEmpty && RowParser_1.RowParser.isEmptyRow(row)) {
	            return true;
	        }
	        rows.push(row);
	        return true;
	    }
	}
	exports.Parser = Parser;

	});

	unwrapExports(Parser_1);
	var Parser_2 = Parser_1.Parser;

	var parser = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.QuotedColumnParser = exports.NonQuotedColumnParser = exports.ColumnParser = exports.Token = exports.Scanner = exports.RowParser = exports.Parser = void 0;

	Object.defineProperty(exports, "Parser", { enumerable: true, get: function () { return Parser_1.Parser; } });

	Object.defineProperty(exports, "RowParser", { enumerable: true, get: function () { return RowParser_1.RowParser; } });

	Object.defineProperty(exports, "Scanner", { enumerable: true, get: function () { return Scanner_1.Scanner; } });

	Object.defineProperty(exports, "Token", { enumerable: true, get: function () { return Token_1.Token; } });

	Object.defineProperty(exports, "ColumnParser", { enumerable: true, get: function () { return column$1.ColumnParser; } });
	Object.defineProperty(exports, "NonQuotedColumnParser", { enumerable: true, get: function () { return column$1.NonQuotedColumnParser; } });
	Object.defineProperty(exports, "QuotedColumnParser", { enumerable: true, get: function () { return column$1.QuotedColumnParser; } });

	});

	unwrapExports(parser);
	var parser_1 = parser.QuotedColumnParser;
	var parser_2 = parser.NonQuotedColumnParser;
	var parser_3 = parser.ColumnParser;
	var parser_4 = parser.Token;
	var parser_5 = parser.Scanner;
	var parser_6 = parser.RowParser;
	var parser_7 = parser.Parser;

	var CsvParserStream_1 = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.CsvParserStream = void 0;




	class CsvParserStream extends stream__default['default'].Transform {
	    constructor(parserOptions) {
	        super({ objectMode: parserOptions.objectMode });
	        this.lines = '';
	        this.rowCount = 0;
	        this.parsedRowCount = 0;
	        this.parsedLineCount = 0;
	        this.endEmitted = false;
	        this.headersEmitted = false;
	        this.parserOptions = parserOptions;
	        this.parser = new parser.Parser(parserOptions);
	        this.headerTransformer = new transforms.HeaderTransformer(parserOptions);
	        this.decoder = new string_decoder__default['default'].StringDecoder(parserOptions.encoding);
	        this.rowTransformerValidator = new transforms.RowTransformerValidator();
	    }
	    get hasHitRowLimit() {
	        return this.parserOptions.limitRows && this.rowCount >= this.parserOptions.maxRows;
	    }
	    get shouldEmitRows() {
	        return this.parsedRowCount > this.parserOptions.skipRows;
	    }
	    get shouldSkipLine() {
	        return this.parsedLineCount <= this.parserOptions.skipLines;
	    }
	    transform(transformFunction) {
	        this.rowTransformerValidator.rowTransform = transformFunction;
	        return this;
	    }
	    validate(validateFunction) {
	        this.rowTransformerValidator.rowValidator = validateFunction;
	        return this;
	    }
	    // eslint-disable-next-line @typescript-eslint/no-explicit-any
	    emit(event, ...rest) {
	        if (event === 'end') {
	            if (!this.endEmitted) {
	                this.endEmitted = true;
	                super.emit('end', this.rowCount);
	            }
	            return false;
	        }
	        return super.emit(event, ...rest);
	    }
	    _transform(data, encoding, done) {
	        // if we have hit our maxRows parsing limit then skip parsing
	        if (this.hasHitRowLimit) {
	            return done();
	        }
	        const wrappedCallback = CsvParserStream.wrapDoneCallback(done);
	        try {
	            const { lines } = this;
	            const newLine = lines + this.decoder.write(data);
	            const rows = this.parse(newLine, true);
	            return this.processRows(rows, wrappedCallback);
	        }
	        catch (e) {
	            return wrappedCallback(e);
	        }
	    }
	    _flush(done) {
	        const wrappedCallback = CsvParserStream.wrapDoneCallback(done);
	        // if we have hit our maxRows parsing limit then skip parsing
	        if (this.hasHitRowLimit) {
	            return wrappedCallback();
	        }
	        try {
	            const newLine = this.lines + this.decoder.end();
	            const rows = this.parse(newLine, false);
	            return this.processRows(rows, wrappedCallback);
	        }
	        catch (e) {
	            return wrappedCallback(e);
	        }
	    }
	    parse(data, hasMoreData) {
	        if (!data) {
	            return [];
	        }
	        const { line, rows } = this.parser.parse(data, hasMoreData);
	        this.lines = line;
	        return rows;
	    }
	    processRows(rows, cb) {
	        const rowsLength = rows.length;
	        const iterate = (i) => {
	            const callNext = (err) => {
	                if (err) {
	                    return cb(err);
	                }
	                if (i % 100 === 0) {
	                    // incase the transform are sync insert a next tick to prevent stack overflow
	                    setImmediate(() => iterate(i + 1));
	                    return undefined;
	                }
	                return iterate(i + 1);
	            };
	            this.checkAndEmitHeaders();
	            // if we have emitted all rows or we have hit the maxRows limit option
	            // then end
	            if (i >= rowsLength || this.hasHitRowLimit) {
	                return cb();
	            }
	            this.parsedLineCount += 1;
	            if (this.shouldSkipLine) {
	                return callNext();
	            }
	            const row = rows[i];
	            this.rowCount += 1;
	            this.parsedRowCount += 1;
	            const nextRowCount = this.rowCount;
	            return this.transformRow(row, (err, transformResult) => {
	                if (err) {
	                    this.rowCount -= 1;
	                    return callNext(err);
	                }
	                if (!transformResult) {
	                    return callNext(new Error('expected transform result'));
	                }
	                if (!transformResult.isValid) {
	                    this.emit('data-invalid', transformResult.row, nextRowCount, transformResult.reason);
	                }
	                else if (transformResult.row) {
	                    return this.pushRow(transformResult.row, callNext);
	                }
	                return callNext();
	            });
	        };
	        iterate(0);
	    }
	    transformRow(parsedRow, cb) {
	        try {
	            this.headerTransformer.transform(parsedRow, (err, withHeaders) => {
	                if (err) {
	                    return cb(err);
	                }
	                if (!withHeaders) {
	                    return cb(new Error('Expected result from header transform'));
	                }
	                if (!withHeaders.isValid) {
	                    if (this.shouldEmitRows) {
	                        return cb(null, { isValid: false, row: parsedRow });
	                    }
	                    // skipped because of skipRows option remove from total row count
	                    return this.skipRow(cb);
	                }
	                if (withHeaders.row) {
	                    if (this.shouldEmitRows) {
	                        return this.rowTransformerValidator.transformAndValidate(withHeaders.row, cb);
	                    }
	                    // skipped because of skipRows option remove from total row count
	                    return this.skipRow(cb);
	                }
	                // this is a header row dont include in the rowCount or parsedRowCount
	                this.rowCount -= 1;
	                this.parsedRowCount -= 1;
	                return cb(null, { row: null, isValid: true });
	            });
	        }
	        catch (e) {
	            cb(e);
	        }
	    }
	    checkAndEmitHeaders() {
	        if (!this.headersEmitted && this.headerTransformer.headers) {
	            this.headersEmitted = true;
	            this.emit('headers', this.headerTransformer.headers);
	        }
	    }
	    skipRow(cb) {
	        // skipped because of skipRows option remove from total row count
	        this.rowCount -= 1;
	        return cb(null, { row: null, isValid: true });
	    }
	    pushRow(row, cb) {
	        try {
	            if (!this.parserOptions.objectMode) {
	                this.push(JSON.stringify(row));
	            }
	            else {
	                this.push(row);
	            }
	            cb();
	        }
	        catch (e) {
	            cb(e);
	        }
	    }
	    static wrapDoneCallback(done) {
	        let errorCalled = false;
	        // eslint-disable-next-line @typescript-eslint/no-explicit-any
	        return (err, ...args) => {
	            if (err) {
	                if (errorCalled) {
	                    throw err;
	                }
	                errorCalled = true;
	                done(err);
	                return;
	            }
	            done(...args);
	        };
	    }
	}
	exports.CsvParserStream = CsvParserStream;

	});

	unwrapExports(CsvParserStream_1);
	var CsvParserStream_2 = CsvParserStream_1.CsvParserStream;

	var src$1 = createCommonjsModule(function (module, exports) {
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
	    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.parseString = exports.parseFile = exports.parseStream = exports.parse = exports.ParserOptions = exports.CsvParserStream = void 0;
	const fs = __importStar(fs__default['default']);



	__exportStar(types$1, exports);
	var CsvParserStream_2 = CsvParserStream_1;
	Object.defineProperty(exports, "CsvParserStream", { enumerable: true, get: function () { return CsvParserStream_2.CsvParserStream; } });
	var ParserOptions_2 = ParserOptions_1;
	Object.defineProperty(exports, "ParserOptions", { enumerable: true, get: function () { return ParserOptions_2.ParserOptions; } });
	exports.parse = (args) => new CsvParserStream_1.CsvParserStream(new ParserOptions_1.ParserOptions(args));
	exports.parseStream = (stream, options) => stream.pipe(new CsvParserStream_1.CsvParserStream(new ParserOptions_1.ParserOptions(options)));
	exports.parseFile = (location, options = {}) => fs.createReadStream(location).pipe(new CsvParserStream_1.CsvParserStream(new ParserOptions_1.ParserOptions(options)));
	exports.parseString = (string, options) => {
	    const rs = new stream__default['default'].Readable();
	    rs.push(string);
	    rs.push(null);
	    return rs.pipe(new CsvParserStream_1.CsvParserStream(new ParserOptions_1.ParserOptions(options)));
	};

	});

	unwrapExports(src$1);
	var src_1$1 = src$1.parseString;
	var src_2$1 = src$1.parseFile;
	var src_3$1 = src$1.parseStream;
	var src_4$1 = src$1.parse;
	var src_5$1 = src$1.ParserOptions;
	var src_6$1 = src$1.CsvParserStream;

	var src$2 = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.CsvParserStream = exports.ParserOptions = exports.parseFile = exports.parseStream = exports.parseString = exports.parse = exports.FormatterOptions = exports.CsvFormatterStream = exports.writeToPath = exports.writeToString = exports.writeToBuffer = exports.writeToStream = exports.write = exports.format = void 0;

	Object.defineProperty(exports, "format", { enumerable: true, get: function () { return src.format; } });
	Object.defineProperty(exports, "write", { enumerable: true, get: function () { return src.write; } });
	Object.defineProperty(exports, "writeToStream", { enumerable: true, get: function () { return src.writeToStream; } });
	Object.defineProperty(exports, "writeToBuffer", { enumerable: true, get: function () { return src.writeToBuffer; } });
	Object.defineProperty(exports, "writeToString", { enumerable: true, get: function () { return src.writeToString; } });
	Object.defineProperty(exports, "writeToPath", { enumerable: true, get: function () { return src.writeToPath; } });
	Object.defineProperty(exports, "CsvFormatterStream", { enumerable: true, get: function () { return src.CsvFormatterStream; } });
	Object.defineProperty(exports, "FormatterOptions", { enumerable: true, get: function () { return src.FormatterOptions; } });

	Object.defineProperty(exports, "parse", { enumerable: true, get: function () { return src$1.parse; } });
	Object.defineProperty(exports, "parseString", { enumerable: true, get: function () { return src$1.parseString; } });
	Object.defineProperty(exports, "parseStream", { enumerable: true, get: function () { return src$1.parseStream; } });
	Object.defineProperty(exports, "parseFile", { enumerable: true, get: function () { return src$1.parseFile; } });
	Object.defineProperty(exports, "ParserOptions", { enumerable: true, get: function () { return src$1.ParserOptions; } });
	Object.defineProperty(exports, "CsvParserStream", { enumerable: true, get: function () { return src$1.CsvParserStream; } });

	});

	unwrapExports(src$2);
	var src_1$2 = src$2.CsvParserStream;
	var src_2$2 = src$2.ParserOptions;
	var src_3$2 = src$2.parseFile;
	var src_4$2 = src$2.parseStream;
	var src_5$2 = src$2.parseString;
	var src_6$2 = src$2.parse;
	var src_7$1 = src$2.FormatterOptions;
	var src_8$1 = src$2.CsvFormatterStream;
	var src_9 = src$2.writeToPath;
	var src_10 = src$2.writeToString;
	var src_11 = src$2.writeToBuffer;
	var src_12 = src$2.writeToStream;
	var src_13 = src$2.write;
	var src_14 = src$2.format;

	var customParseFormat = createCommonjsModule(function (module, exports) {
	!function(t,e){module.exports=e();}(commonjsGlobal,function(){var t={LTS:"h:mm:ss A",LT:"h:mm A",L:"MM/DD/YYYY",LL:"MMMM D, YYYY",LLL:"MMMM D, YYYY h:mm A",LLLL:"dddd, MMMM D, YYYY h:mm A"},e=function(e,n){return e.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g,function(e,r,i){var o=i&&i.toUpperCase();return r||n[i]||t[i]||n[o].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g,function(t,e,n){return e||n.slice(1)})})},n=/(\[[^[]*\])|([-:/.()\s]+)|(A|a|YYYY|YY?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g,r=/\d\d/,i=/\d\d?/,o=/\d*[^\s\d-_:/()]+/,s={};var a=function(t){return function(e){this[t]=+e;}},f=[/[+-]\d\d:?(\d\d)?/,function(t){(this.zone||(this.zone={})).offset=function(t){if(!t)return 0;var e=t.match(/([+-]|\d\d)/g),n=60*e[1]+(+e[2]||0);return 0===n?0:"+"===e[0]?-n:n}(t);}],u=function(t){var e=s[t];return e&&(e.indexOf?e:e.s.concat(e.f))},h=function(t,e){var n,r=s.meridiem;if(r){for(var i=1;i<=24;i+=1)if(t.indexOf(r(i,0,e))>-1){n=i>12;break}}else n=t===(e?"pm":"PM");return n},d={A:[o,function(t){this.afternoon=h(t,!1);}],a:[o,function(t){this.afternoon=h(t,!0);}],S:[/\d/,function(t){this.milliseconds=100*+t;}],SS:[r,function(t){this.milliseconds=10*+t;}],SSS:[/\d{3}/,function(t){this.milliseconds=+t;}],s:[i,a("seconds")],ss:[i,a("seconds")],m:[i,a("minutes")],mm:[i,a("minutes")],H:[i,a("hours")],h:[i,a("hours")],HH:[i,a("hours")],hh:[i,a("hours")],D:[i,a("day")],DD:[r,a("day")],Do:[o,function(t){var e=s.ordinal,n=t.match(/\d+/);if(this.day=n[0],e)for(var r=1;r<=31;r+=1)e(r).replace(/\[|\]/g,"")===t&&(this.day=r);}],M:[i,a("month")],MM:[r,a("month")],MMM:[o,function(t){var e=u("months"),n=(u("monthsShort")||e.map(function(t){return t.substr(0,3)})).indexOf(t)+1;if(n<1)throw new Error;this.month=n%12||n;}],MMMM:[o,function(t){var e=u("months").indexOf(t)+1;if(e<1)throw new Error;this.month=e%12||e;}],Y:[/[+-]?\d+/,a("year")],YY:[r,function(t){t=+t,this.year=t+(t>68?1900:2e3);}],YYYY:[/\d{4}/,a("year")],Z:f,ZZ:f};var c=function(t,r,i){try{var o=function(t){for(var r=(t=e(t,s&&s.formats)).match(n),i=r.length,o=0;o<i;o+=1){var a=r[o],f=d[a],u=f&&f[0],h=f&&f[1];r[o]=h?{regex:u,parser:h}:a.replace(/^\[|\]$/g,"");}return function(t){for(var e={},n=0,o=0;n<i;n+=1){var s=r[n];if("string"==typeof s)o+=s.length;else {var a=s.regex,f=s.parser,u=t.substr(o),h=a.exec(u)[0];f.call(e,h),t=t.replace(h,"");}}return function(t){var e=t.afternoon;if(void 0!==e){var n=t.hours;e?n<12&&(t.hours+=12):12===n&&(t.hours=0),delete t.afternoon;}}(e),e}}(r)(t),a=o.year,f=o.month,u=o.day,h=o.hours,c=o.minutes,m=o.seconds,l=o.milliseconds,M=o.zone,Y=new Date,v=u||(a||f?1:Y.getDate()),p=a||Y.getFullYear(),D=0;a&&!f||(D=f>0?f-1:Y.getMonth());var y=h||0,L=c||0,g=m||0,$=l||0;return M?new Date(Date.UTC(p,D,v,y,L,g,$+60*M.offset*1e3)):i?new Date(Date.UTC(p,D,v,y,L,g,$)):new Date(p,D,v,y,L,g,$)}catch(t){return new Date("")}};return function(t,e,n){n.p.customParseFormat=!0;var r=e.prototype,i=r.parse;r.parse=function(t){var e=t.date,r=t.utc,o=t.args;this.$u=r;var a=o[1];if("string"==typeof a){var f=!0===o[2],u=!0===o[3],h=f||u,d=o[2];u&&(d=o[2]),s=this.$locale(),!f&&d&&(s=n.Ls[d]),this.$d=c(e,a,r),this.init(),d&&!0!==d&&(this.$L=this.locale(d).$L),h&&e!==this.format(a)&&(this.$d=new Date("")),s={};}else if(a instanceof Array)for(var m=a.length,l=1;l<=m;l+=1){o[1]=a[l-1];var M=n.apply(this,o);if(M.isValid()){this.$d=M.$d,this.$L=M.$L,this.init();break}l===m&&(this.$d=new Date(""));}else i.call(this,t);};}});
	});

	var utc = createCommonjsModule(function (module, exports) {
	!function(t,i){module.exports=i();}(commonjsGlobal,function(){return function(t,i,e){var s=i.prototype;e.utc=function(t){return new i({date:t,utc:!0,args:arguments})},s.utc=function(t){var i=e(this.toDate(),{locale:this.$L,utc:!0});return t?i.add(this.utcOffset(),"minute"):i},s.local=function(){return e(this.toDate(),{locale:this.$L,utc:!1})};var f=s.parse;s.parse=function(t){t.utc&&(this.$u=!0),this.$utils().u(t.$offset)||(this.$offset=t.$offset),f.call(this,t);};var n=s.init;s.init=function(){if(this.$u){var t=this.$d;this.$y=t.getUTCFullYear(),this.$M=t.getUTCMonth(),this.$D=t.getUTCDate(),this.$W=t.getUTCDay(),this.$H=t.getUTCHours(),this.$m=t.getUTCMinutes(),this.$s=t.getUTCSeconds(),this.$ms=t.getUTCMilliseconds();}else n.call(this);};var u=s.utcOffset;s.utcOffset=function(t,i){var e=this.$utils().u;if(e(t))return this.$u?0:e(this.$offset)?u.call(this):this.$offset;var s=Math.abs(t)<=16?60*t:t,f=this;if(i)return f.$offset=s,f.$u=0===t,f;if(0!==t){var n=this.$u?this.toDate().getTimezoneOffset():-1*this.utcOffset();(f=this.local().add(s+n,"minute")).$offset=s,f.$x.$localOffset=n;}else f=this.utc();return f};var o=s.format;s.format=function(t){var i=t||(this.$u?"YYYY-MM-DDTHH:mm:ss[Z]":"");return o.call(this,i)},s.valueOf=function(){var t=this.$utils().u(this.$offset)?0:this.$offset+(this.$x.$localOffset||(new Date).getTimezoneOffset());return this.$d.valueOf()-6e4*t},s.isUTC=function(){return !!this.$u},s.toISOString=function(){return this.toDate().toISOString()},s.toString=function(){return this.toDate().toUTCString()};var r=s.toDate;s.toDate=function(t){return "s"===t&&this.$offset?e(this.format("YYYY-MM-DD HH:mm:ss:SSS")).toDate():r.call(this)};var a=s.diff;s.diff=function(t,i,s){if(t&&this.$u===t.$u)return a.call(this,t,i,s);var f=this.local(),n=e(t).local();return a.call(f,n,i,s)};}});
	});

	var dayjs_min = createCommonjsModule(function (module, exports) {
	!function(t,e){module.exports=e();}(commonjsGlobal,function(){var t="millisecond",e="second",n="minute",r="hour",i="day",s="week",u="month",a="quarter",o="year",f="date",h=/^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[^0-9]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/,c=/\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g,d={name:"en",weekdays:"Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),months:"January_February_March_April_May_June_July_August_September_October_November_December".split("_")},$=function(t,e,n){var r=String(t);return !r||r.length>=e?t:""+Array(e+1-r.length).join(n)+t},l={s:$,z:function(t){var e=-t.utcOffset(),n=Math.abs(e),r=Math.floor(n/60),i=n%60;return (e<=0?"+":"-")+$(r,2,"0")+":"+$(i,2,"0")},m:function t(e,n){if(e.date()<n.date())return -t(n,e);var r=12*(n.year()-e.year())+(n.month()-e.month()),i=e.clone().add(r,u),s=n-i<0,a=e.clone().add(r+(s?-1:1),u);return +(-(r+(n-i)/(s?i-a:a-i))||0)},a:function(t){return t<0?Math.ceil(t)||0:Math.floor(t)},p:function(h){return {M:u,y:o,w:s,d:i,D:f,h:r,m:n,s:e,ms:t,Q:a}[h]||String(h||"").toLowerCase().replace(/s$/,"")},u:function(t){return void 0===t}},y="en",M={};M[y]=d;var m=function(t){return t instanceof S},D=function(t,e,n){var r;if(!t)return y;if("string"==typeof t)M[t]&&(r=t),e&&(M[t]=e,r=t);else {var i=t.name;M[i]=t,r=i;}return !n&&r&&(y=r),r||!n&&y},v=function(t,e){if(m(t))return t.clone();var n="object"==typeof e?e:{};return n.date=t,n.args=arguments,new S(n)},g=l;g.l=D,g.i=m,g.w=function(t,e){return v(t,{locale:e.$L,utc:e.$u,x:e.$x,$offset:e.$offset})};var S=function(){function d(t){this.$L=D(t.locale,null,!0),this.parse(t);}var $=d.prototype;return $.parse=function(t){this.$d=function(t){var e=t.date,n=t.utc;if(null===e)return new Date(NaN);if(g.u(e))return new Date;if(e instanceof Date)return new Date(e);if("string"==typeof e&&!/Z$/i.test(e)){var r=e.match(h);if(r){var i=r[2]-1||0,s=(r[7]||"0").substring(0,3);return n?new Date(Date.UTC(r[1],i,r[3]||1,r[4]||0,r[5]||0,r[6]||0,s)):new Date(r[1],i,r[3]||1,r[4]||0,r[5]||0,r[6]||0,s)}}return new Date(e)}(t),this.$x=t.x||{},this.init();},$.init=function(){var t=this.$d;this.$y=t.getFullYear(),this.$M=t.getMonth(),this.$D=t.getDate(),this.$W=t.getDay(),this.$H=t.getHours(),this.$m=t.getMinutes(),this.$s=t.getSeconds(),this.$ms=t.getMilliseconds();},$.$utils=function(){return g},$.isValid=function(){return !("Invalid Date"===this.$d.toString())},$.isSame=function(t,e){var n=v(t);return this.startOf(e)<=n&&n<=this.endOf(e)},$.isAfter=function(t,e){return v(t)<this.startOf(e)},$.isBefore=function(t,e){return this.endOf(e)<v(t)},$.$g=function(t,e,n){return g.u(t)?this[e]:this.set(n,t)},$.unix=function(){return Math.floor(this.valueOf()/1e3)},$.valueOf=function(){return this.$d.getTime()},$.startOf=function(t,a){var h=this,c=!!g.u(a)||a,d=g.p(t),$=function(t,e){var n=g.w(h.$u?Date.UTC(h.$y,e,t):new Date(h.$y,e,t),h);return c?n:n.endOf(i)},l=function(t,e){return g.w(h.toDate()[t].apply(h.toDate("s"),(c?[0,0,0,0]:[23,59,59,999]).slice(e)),h)},y=this.$W,M=this.$M,m=this.$D,D="set"+(this.$u?"UTC":"");switch(d){case o:return c?$(1,0):$(31,11);case u:return c?$(1,M):$(0,M+1);case s:var v=this.$locale().weekStart||0,S=(y<v?y+7:y)-v;return $(c?m-S:m+(6-S),M);case i:case f:return l(D+"Hours",0);case r:return l(D+"Minutes",1);case n:return l(D+"Seconds",2);case e:return l(D+"Milliseconds",3);default:return this.clone()}},$.endOf=function(t){return this.startOf(t,!1)},$.$set=function(s,a){var h,c=g.p(s),d="set"+(this.$u?"UTC":""),$=(h={},h[i]=d+"Date",h[f]=d+"Date",h[u]=d+"Month",h[o]=d+"FullYear",h[r]=d+"Hours",h[n]=d+"Minutes",h[e]=d+"Seconds",h[t]=d+"Milliseconds",h)[c],l=c===i?this.$D+(a-this.$W):a;if(c===u||c===o){var y=this.clone().set(f,1);y.$d[$](l),y.init(),this.$d=y.set(f,Math.min(this.$D,y.daysInMonth())).$d;}else $&&this.$d[$](l);return this.init(),this},$.set=function(t,e){return this.clone().$set(t,e)},$.get=function(t){return this[g.p(t)]()},$.add=function(t,a){var f,h=this;t=Number(t);var c=g.p(a),d=function(e){var n=v(h);return g.w(n.date(n.date()+Math.round(e*t)),h)};if(c===u)return this.set(u,this.$M+t);if(c===o)return this.set(o,this.$y+t);if(c===i)return d(1);if(c===s)return d(7);var $=(f={},f[n]=6e4,f[r]=36e5,f[e]=1e3,f)[c]||1,l=this.$d.getTime()+t*$;return g.w(l,this)},$.subtract=function(t,e){return this.add(-1*t,e)},$.format=function(t){var e=this;if(!this.isValid())return "Invalid Date";var n=t||"YYYY-MM-DDTHH:mm:ssZ",r=g.z(this),i=this.$locale(),s=this.$H,u=this.$m,a=this.$M,o=i.weekdays,f=i.months,h=function(t,r,i,s){return t&&(t[r]||t(e,n))||i[r].substr(0,s)},d=function(t){return g.s(s%12||12,t,"0")},$=i.meridiem||function(t,e,n){var r=t<12?"AM":"PM";return n?r.toLowerCase():r},l={YY:String(this.$y).slice(-2),YYYY:this.$y,M:a+1,MM:g.s(a+1,2,"0"),MMM:h(i.monthsShort,a,f,3),MMMM:h(f,a),D:this.$D,DD:g.s(this.$D,2,"0"),d:String(this.$W),dd:h(i.weekdaysMin,this.$W,o,2),ddd:h(i.weekdaysShort,this.$W,o,3),dddd:o[this.$W],H:String(s),HH:g.s(s,2,"0"),h:d(1),hh:d(2),a:$(s,u,!0),A:$(s,u,!1),m:String(u),mm:g.s(u,2,"0"),s:String(this.$s),ss:g.s(this.$s,2,"0"),SSS:g.s(this.$ms,3,"0"),Z:r};return n.replace(c,function(t,e){return e||l[t]||r.replace(":","")})},$.utcOffset=function(){return 15*-Math.round(this.$d.getTimezoneOffset()/15)},$.diff=function(t,f,h){var c,d=g.p(f),$=v(t),l=6e4*($.utcOffset()-this.utcOffset()),y=this-$,M=g.m(this,$);return M=(c={},c[o]=M/12,c[u]=M,c[a]=M/3,c[s]=(y-l)/6048e5,c[i]=(y-l)/864e5,c[r]=y/36e5,c[n]=y/6e4,c[e]=y/1e3,c)[d]||y,h?M:g.a(M)},$.daysInMonth=function(){return this.endOf(u).$D},$.$locale=function(){return M[this.$L]},$.locale=function(t,e){if(!t)return this.$L;var n=this.clone(),r=D(t,e,!0);return r&&(n.$L=r),n},$.clone=function(){return g.w(this.$d,this)},$.toDate=function(){return new Date(this.valueOf())},$.toJSON=function(){return this.isValid()?this.toISOString():null},$.toISOString=function(){return this.$d.toISOString()},$.toString=function(){return this.$d.toUTCString()},d}(),p=S.prototype;return v.prototype=p,[["$ms",t],["$s",e],["$m",n],["$H",r],["$W",i],["$M",u],["$y",o],["$D",f]].forEach(function(t){p[t[1]]=function(e){return this.$g(e,t[0],t[1])};}),v.extend=function(t,e){return t.$i||(t(e,S,v),t.$i=!0),v},v.locale=D,v.isDayjs=m,v.unix=function(t){return v(1e3*t)},v.en=M[y],v.Ls=M,v.p={},v});
	});

	const dayjs = dayjs_min.extend(customParseFormat).extend(utc);


	const {
	  fs: {exists},
	} = utils_1;

	/* eslint-disable quote-props */
	const SpecialValues = {
	  true: true,
	  false: false,
	  '#N/A': {error: '#N/A'},
	  '#REF!': {error: '#REF!'},
	  '#NAME?': {error: '#NAME?'},
	  '#DIV/0!': {error: '#DIV/0!'},
	  '#NULL!': {error: '#NULL!'},
	  '#VALUE!': {error: '#VALUE!'},
	  '#NUM!': {error: '#NUM!'},
	};
	/* eslint-ensable quote-props */

	class CSV {
	  constructor(workbook) {
	    this.workbook = workbook;
	    this.worksheet = null;
	  }

	  async readFile(filename, options) {
	    options = options || {};
	    if (!(await exists(filename))) {
	      throw new Error(`File not found: ${filename}`);
	    }
	    const stream = fs__default['default'].createReadStream(filename);
	    const worksheet = await this.read(stream, options);
	    stream.close();
	    return worksheet;
	  }

	  read(stream, options) {
	    options = options || {};

	    return new Promise((resolve, reject) => {
	      const worksheet = this.workbook.addWorksheet(options.sheetName);

	      const dateFormats = options.dateFormats || [
	        'YYYY-MM-DD[T]HH:mm:ssZ',
	        'YYYY-MM-DD[T]HH:mm:ss',
	        'MM-DD-YYYY',
	        'YYYY-MM-DD',
	      ];
	      const map =
	        options.map ||
	        function(datum) {
	          if (datum === '') {
	            return null;
	          }
	          const datumNumber = Number(datum);
	          if (!Number.isNaN(datumNumber) && datumNumber !== Infinity) {
	            return datumNumber;
	          }
	          const dt = dateFormats.reduce((matchingDate, currentDateFormat) => {
	            if (matchingDate) {
	              return matchingDate;
	            }
	            const dayjsObj = dayjs(datum, currentDateFormat, true);
	            if (dayjsObj.isValid()) {
	              return dayjsObj;
	            }
	            return null;
	          }, null);
	          if (dt) {
	            return new Date(dt.valueOf());
	          }
	          const special = SpecialValues[datum];
	          if (special !== undefined) {
	            return special;
	          }
	          return datum;
	        };

	      const csvStream = src$2
	        .parse(options.parserOptions)
	        .on('data', data => {
	          worksheet.addRow(data.map(map));
	        })
	        .on('end', () => {
	          csvStream.emit('worksheet', worksheet);
	        });

	      csvStream.on('worksheet', resolve).on('error', reject);

	      stream.pipe(csvStream);
	    });
	  }

	  /**
	   * @deprecated since version 4.0. You should use `CSV#read` instead. Please follow upgrade instruction: https://github.com/exceljs/exceljs/blob/master/UPGRADE-4.0.md
	   */
	  createInputStream() {
	    throw new Error(
	      '`CSV#createInputStream` is deprecated. You should use `CSV#read` instead. This method will be removed in version 5.0. Please follow upgrade instruction: https://github.com/exceljs/exceljs/blob/master/UPGRADE-4.0.md'
	    );
	  }

	  write(stream, options) {
	    return new Promise((resolve, reject) => {
	      options = options || {};
	      // const encoding = options.encoding || 'utf8';
	      // const separator = options.separator || ',';
	      // const quoteChar = options.quoteChar || '\'';

	      const worksheet = this.workbook.getWorksheet(options.sheetName || options.sheetId);

	      const csvStream = src$2.format(options.formatterOptions);
	      stream.on('finish', () => {
	        resolve();
	      });
	      csvStream.on('error', reject);
	      csvStream.pipe(stream);

	      const {dateFormat, dateUTC} = options;
	      const map =
	        options.map ||
	        (value => {
	          if (value) {
	            if (value.text || value.hyperlink) {
	              return value.hyperlink || value.text || '';
	            }
	            if (value.formula || value.result) {
	              return value.result || '';
	            }
	            if (value instanceof Date) {
	              if (dateFormat) {
	                return dateUTC
	                  ? dayjs.utc(value).format(dateFormat)
	                  : dayjs(value).format(dateFormat);
	              }
	              return dateUTC ? dayjs.utc(value).format() : dayjs(value).format();
	            }
	            if (value.error) {
	              return value.error;
	            }
	            if (typeof value === 'object') {
	              return JSON.stringify(value);
	            }
	          }
	          return value;
	        });

	      const includeEmptyRows = options.includeEmptyRows === undefined || options.includeEmptyRows;
	      let lastRow = 1;
	      if (worksheet) {
	        worksheet.eachRow((row, rowNumber) => {
	          if (includeEmptyRows) {
	            while (lastRow++ < rowNumber - 1) {
	              csvStream.write([]);
	            }
	          }
	          const {values} = row;
	          values.shift();
	          csvStream.write(values.map(map));
	          lastRow = rowNumber;
	        });
	      }
	      csvStream.end();
	    });
	  }

	  writeFile(filename, options) {
	    options = options || {};

	    const streamOptions = {
	      encoding: options.encoding || 'utf8',
	    };
	    const stream = fs__default['default'].createWriteStream(filename, streamOptions);

	    return this.write(stream, options);
	  }

	  async writeBuffer(options) {
	    const stream = new streamBuf();
	    await this.write(stream, options);
	    return stream.read();
	  }
	}

	var csv = CSV;

	// Workbook requirements
	//  Load and Save from file and stream
	//  Access/Add/Delete individual worksheets
	//  Manage String table, Hyperlink table, etc.
	//  Manage scaffolding for contained objects to write to/read from

	class Workbook {
	  constructor() {
	    this.created = new Date();
	    this.modified = this.created;
	    this.properties = {};
	    this.calcProperties = {};
	    this._worksheets = [];
	    this.views = [];
	    this.media = [];
	    this._definedNames = new definedNames();
	  }

	  get xlsx() {
	    if (!this._xlsx) this._xlsx = new xlsx(this);
	    return this._xlsx;
	  }

	  get csv() {
	    if (!this._csv) this._csv = new csv(this);
	    return this._csv;
	  }

	  get nextId() {
	    // find the next unique spot to add worksheet
	    for (let i = 1; i < this._worksheets.length; i++) {
	      if (!this._worksheets[i]) {
	        return i;
	      }
	    }
	    return this._worksheets.length || 1;
	  }

	  addWorksheet(name, options) {
	    const id = this.nextId;

	    if (name && name.length > 31) {
	      // eslint-disable-next-line no-console
	      console.warn(`Worksheet name ${name} exceeds 31 chars. This will be truncated`);
	    }

	    // Illegal character in worksheet name: asterisk (*), question mark (?),
	    // colon (:), forward slash (/ \), or bracket ([])
	    if (/[*?:/\\[\]]/.test(name)) {
	      throw new Error(
	        `Worksheet name ${name} cannot include any of the following characters: * ? : \\ / [ ]`
	      );
	    }

	    if (/(^')|('$)/.test(name)) {
	      throw new Error(
	        `The first or last character of worksheet name cannot be a single quotation mark: ${name}`
	      );
	    }

	    name = (name || `sheet${id}`).substring(0, 31);
	    if (this._worksheets.find(ws => ws && ws.name.toLowerCase() === name.toLowerCase())) {
	      throw new Error(`Worksheet name already exists: ${name}`);
	    }

	    // if options is a color, call it tabColor (and signal deprecated message)
	    if (options) {
	      if (typeof options === 'string') {
	        // eslint-disable-next-line no-console
	        console.trace(
	          'tabColor argument is now deprecated. Please use workbook.addWorksheet(name, {properties: { tabColor: { argb: "rbg value" } }'
	        );
	        options = {
	          properties: {
	            tabColor: {argb: options},
	          },
	        };
	      } else if (options.argb || options.theme || options.indexed) {
	        // eslint-disable-next-line no-console
	        console.trace(
	          'tabColor argument is now deprecated. Please use workbook.addWorksheet(name, {properties: { tabColor: { ... } }'
	        );
	        options = {
	          properties: {
	            tabColor: options,
	          },
	        };
	      }
	    }

	    const lastOrderNo = this._worksheets.reduce(
	      (acc, ws) => ((ws && ws.orderNo) > acc ? ws.orderNo : acc),
	      0
	    );
	    const worksheetOptions = Object.assign({}, options, {
	      id,
	      name,
	      orderNo: lastOrderNo + 1,
	      workbook: this,
	    });

	    const worksheet$1 = new worksheet(worksheetOptions);

	    this._worksheets[id] = worksheet$1;
	    return worksheet$1;
	  }

	  removeWorksheetEx(worksheet) {
	    delete this._worksheets[worksheet.id];
	  }

	  removeWorksheet(id) {
	    const worksheet = this.getWorksheet(id);
	    if (worksheet) {
	      worksheet.destroy();
	    }
	  }

	  getWorksheet(id) {
	    if (id === undefined) {
	      return this._worksheets.find(Boolean);
	    }
	    if (typeof id === 'number') {
	      return this._worksheets[id];
	    }
	    if (typeof id === 'string') {
	      return this._worksheets.find(worksheet => worksheet && worksheet.name === id);
	    }
	    return undefined;
	  }

	  get worksheets() {
	    // return a clone of _worksheets
	    return this._worksheets
	      .slice(1)
	      .sort((a, b) => a.orderNo - b.orderNo)
	      .filter(Boolean);
	  }

	  eachSheet(iteratee) {
	    this.worksheets.forEach(sheet => {
	      iteratee(sheet, sheet.id);
	    });
	  }

	  get definedNames() {
	    return this._definedNames;
	  }

	  clearThemes() {
	    // Note: themes are not an exposed feature, meddle at your peril!
	    this._themes = undefined;
	  }

	  addImage(image) {
	    // TODO:  validation?
	    const id = this.media.length;
	    this.media.push(Object.assign({}, image, {type: 'image'}));
	    return id;
	  }

	  getImage(id) {
	    return this.media[id];
	  }

	  get model() {
	    return {
	      creator: this.creator || 'Unknown',
	      lastModifiedBy: this.lastModifiedBy || 'Unknown',
	      lastPrinted: this.lastPrinted,
	      created: this.created,
	      modified: this.modified,
	      properties: this.properties,
	      worksheets: this.worksheets.map(worksheet => worksheet.model),
	      sheets: this.worksheets.map(ws => ws.model).filter(Boolean),
	      definedNames: this._definedNames.model,
	      views: this.views,
	      company: this.company,
	      manager: this.manager,
	      title: this.title,
	      subject: this.subject,
	      keywords: this.keywords,
	      category: this.category,
	      description: this.description,
	      language: this.language,
	      revision: this.revision,
	      contentStatus: this.contentStatus,
	      themes: this._themes,
	      media: this.media,
	      calcProperties: this.calcProperties,
	    };
	  }

	  set model(value) {
	    this.creator = value.creator;
	    this.lastModifiedBy = value.lastModifiedBy;
	    this.lastPrinted = value.lastPrinted;
	    this.created = value.created;
	    this.modified = value.modified;
	    this.company = value.company;
	    this.manager = value.manager;
	    this.title = value.title;
	    this.subject = value.subject;
	    this.keywords = value.keywords;
	    this.category = value.category;
	    this.description = value.description;
	    this.language = value.language;
	    this.revision = value.revision;
	    this.contentStatus = value.contentStatus;

	    this.properties = value.properties;
	    this.calcProperties = value.calcProperties;
	    this._worksheets = [];
	    value.worksheets.forEach(worksheetModel => {
	      const {id, name, state} = worksheetModel;
	      const orderNo = value.sheets && value.sheets.findIndex(ws => ws.id === id);
	      const worksheet$1 = (this._worksheets[id] = new worksheet({
	        id,
	        name,
	        orderNo,
	        state,
	        workbook: this,
	      }));

	      worksheet$1.model = worksheetModel;
	    });

	    this._definedNames.model = value.definedNames;
	    this.views = value.views;
	    this._themes = value.themes;
	    this.media = value.media || [];
	  }
	}

	var workbook = Workbook;

	/* eslint-disable import/no-extraneous-dependencies,node/no-unpublished-require */






	// required by core-js/modules/es.promise Promise.all

	// required by node_modules/saxes/saxes.js SaxesParser.captureTo

	// required by lib/doc/workbook.js Workbook.model

	// required by lib/doc/workbook.js Workbook.addWorksheet and Workbook.getWorksheet

	// required by node_modules/saxes/saxes.js SaxesParser.getCode10

	// required by lib/xlsx/xform/sheet/data-validations-xform.js DataValidationsXform.parseClose

	// required by lib/utils/utils.js utils.validInt and lib/csv/csv.js CSV.read



	const ExcelJS = {
	  Workbook: workbook,
	};

	// Object.assign mono-fill


	Object.keys(enums).forEach(key => {
	  ExcelJS[key] = enums[key];
	});

	var exceljs_browser = ExcelJS;
	var exceljs_browser_1 = exceljs_browser.Workbook;

	var workbook$1 = new exceljs_browser_1;

	exports.workbook = workbook$1;

	return exports;

}({}, crypto$1, fs, events, buffer, util, stream, string_decoder$1));
